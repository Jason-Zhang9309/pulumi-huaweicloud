// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export namespace Aom {
    export interface AlarmRuleDimension {
        /**
         * Specifies the dimension name. Changing this creates a new resource.
         */
        name: string;
        /**
         * Specifies the dimension value. Changing this creates a new resource.
         */
        value: string;
    }

    export interface ServiceDiscoveryRuleDiscoveryRule {
        /**
         * Specifies the matched value. This is a list of strings.
         */
        checkContents: string[];
        /**
         * Specifies the match condition. The values can be **contain** and **equals**.
         */
        checkMode: string;
        /**
         * Specifies the match type. The values can be **cmdLine**, **env** and **scope**.
         */
        checkType: string;
    }

    export interface ServiceDiscoveryRuleLogPathRule {
        /**
         * Specifies the input value.
         */
        args: string[];
        /**
         * Specifies the value type. The value can be **cmdLineHash**, **cmdLine**, **env**
         * and **str**.
         */
        nameType: string;
        /**
         * Specifies the application name, which is mandatory only when the value of
         * `nameType` is **cmdLineHash**.
         */
        values: string[];
    }

    export interface ServiceDiscoveryRuleNameRules {
        /**
         * Specifies the application name rule. If the value of `nameType` is
         * **cmdLine**, `args` is in the format of ["start", "end"], indicating that the characters between start and end in
         * the command are extracted. If the value of `nameType` is **env**, `args` is in the format of ["aa"], indicating that
         * the environment variable named aa is extracted. If the value of `nameType` is **str**, `args` is in the format of
         * ["fix"], indicating that the application name is suffixed with fix. If the value of `nameType` is **cmdLineHash**,
         * `args` is in the format of ["0001"] and `value` is in the format of ["ser"], indicating that the application name is
         * ser when the startup command is 0001. The object structure is documented below.
         */
        applicationNameRules: outputs.Aom.ServiceDiscoveryRuleNameRulesApplicationNameRule[];
        /**
         * Specifies the service name rule. If there are multiple objects in the array,
         * the character strings extracted from these objects constitute the service name. If the value of `nameType` is
         * **cmdLine**, `args` is in the format of ["start", "end"], indicating that the characters between start and end
         * in the command are extracted. If the value of `nameType` is **env**, `args` is in the format of ["aa"],
         * indicating that the environment variable named aa is extracted. If the value of `nameType` is **str**, `args` is in the
         * format of ["fix"], indicating that the service name is suffixed with fix. If the value of `nameType` is
         * **cmdLineHash**, `args` is in the format of ["0001"] and `value` is in the format of ["ser"], indicating that the
         * service name is ser when the startup command is 0001. The object structure is
         * documented below.
         */
        serviceNameRules: outputs.Aom.ServiceDiscoveryRuleNameRulesServiceNameRule[];
    }

    export interface ServiceDiscoveryRuleNameRulesApplicationNameRule {
        /**
         * Specifies the input value.
         */
        args: string[];
        /**
         * Specifies the value type. The value can be **cmdLineHash**, **cmdLine**, **env**
         * and **str**.
         */
        nameType: string;
        /**
         * Specifies the application name, which is mandatory only when the value of
         * `nameType` is **cmdLineHash**.
         */
        values?: string[];
    }

    export interface ServiceDiscoveryRuleNameRulesServiceNameRule {
        /**
         * Specifies the input value.
         */
        args: string[];
        /**
         * Specifies the value type. The value can be **cmdLineHash**, **cmdLine**, **env**
         * and **str**.
         */
        nameType: string;
        /**
         * Specifies the application name, which is mandatory only when the value of
         * `nameType` is **cmdLineHash**.
         */
        values?: string[];
    }

}

export namespace As {
    export interface BandwidthPolicyScalingPolicyAction {
        /**
         * Specifies the operation restrictions.
         * - If operation is not SET, this parameter takes effect and the unit is Mbit/s.
         * - If operation is set to ADD, this parameter indicates the maximum bandwidth allowed.
         * - If operation is set to REDUCE, this parameter indicates the minimum bandwidth allowed.
         */
        limits: number;
        /**
         * Specifies the operation to be performed. The default operation is ADD.
         * The options are as follows:
         * - **ADD**: indicates adding the bandwidth size.
         * - **REDUCE**: indicates reducing the bandwidth size.
         * - **SET**: indicates setting the bandwidth size to a specified value.
         */
        operation: string;
        /**
         * Specifies the bandwidth (Mbit/s).
         * The value is an integer from 1 to 2000. The default value is 1.
         */
        size: number;
    }

    export interface BandwidthPolicyScheduledPolicy {
        /**
         * Specifies the end time of the scaling action triggered periodically.
         * The time format complies with UTC. This parameter is mandatory when scalingPolicyType is set to RECURRENCE.
         * When the scaling action is triggered periodically, the end time cannot be earlier than the current and start time.
         * The time format is YYYY-MM-DDThh:mmZ.
         */
        endTime: string;
        /**
         * Specifies the time when the scaling action is triggered.
         * The time format complies with UTC.
         * - If scalingPolicyType is set to SCHEDULED, the time format is YYYY-MM-DDThh:mmZ.
         * - If scalingPolicyType is set to RECURRENCE, the time format is hh:mm.
         */
        launchTime: string;
        /**
         * Specifies the periodic triggering type.
         * This parameter is mandatory when scalingPolicyType is set to RECURRENCE. The options are as follows:
         * - **Daily**: indicates that the scaling action is triggered once a day.
         * - **Weekly**: indicates that the scaling action is triggered once a week.
         * - **Monthly**: indicates that the scaling action is triggered once a month.
         */
        recurrenceType: string;
        /**
         * Specifies the day when a periodic scaling action is triggered.
         * This parameter is mandatory when scalingPolicyType is set to RECURRENCE.
         * - If recurrenceType is set to Daily, the value is null, indicating that the scaling action is triggered once a day.
         * - If recurrenceType is set to Weekly, the value ranges from 1 (Sunday) to 7 (Saturday).
         * The digits refer to dates in each week and separated by a comma, such as 1,3,5.
         * - If recurrenceType is set to Monthly, the value ranges from 1 to 31.
         * The digits refer to the dates in each month and separated by a comma, such as 1,10,13,28.
         */
        recurrenceValue: string;
        /**
         * Specifies the start time of the scaling action triggered periodically.
         * The time format complies with UTC. The default value is the local time.
         * The time format is YYYY-MM-DDThh:mmZ.
         */
        startTime: string;
    }

    export interface ConfigurationInstanceConfig {
        /**
         * Specifies the disk group information. System disks are mandatory and
         * data disks are optional. The object structure is documented below.
         * Changing this will create a new resource.
         */
        disks: outputs.As.ConfigurationInstanceConfigDisk[];
        /**
         * Specifies the ECS flavor name. A maximum of 10 flavors can be selected.
         * Use a comma (,) to separate multiple flavor names. Changing this will create a new resource.
         */
        flavor: string;
        /**
         * Specifies the ECS image ID. Changing this will create a new resource.
         */
        image: string;
        /**
         * Specifies the ECS instance ID when using its specification
         * as the template to create AS configurations. In this case, `flavor`, `image`, and `disk` arguments do not take effect.
         * If this argument is not specified, `flavor`, `image`, and `disk` arguments are mandatory.
         * Changing this will create a new resource.
         */
        instanceId: string;
        /**
         * Specifies the name of the SSH key pair used to log in to the instance.
         * Changing this will create a new resource.
         */
        keyName: string;
        /**
         * Specifies the key/value pairs to make available from within the instance.
         * Changing this will create a new resource.
         */
        metadata?: {[key: string]: string};
        /**
         * Specifies the customize personality of an instance by defining one or
         * more files and their contents. The object structure is documented below.
         * Changing this will create a new resource.
         */
        personalities: outputs.As.ConfigurationInstanceConfigPersonality[];
        /**
         * Specifies the EIP of the ECS instance.
         * The object structure is documented below.
         * Changing this will create a new resource.
         */
        publicIp: outputs.As.ConfigurationInstanceConfigPublicIp;
        /**
         * Specifies the user data to provide when launching the instance.
         * The file content must be encoded with Base64. Changing this will create a new resource.
         */
        userData?: string;
    }

    export interface ConfigurationInstanceConfigDisk {
        /**
         * Specifies whether the disk is a system disk or a data disk.
         * Option **DATA** indicates a data disk, option **SYS** indicates a system disk.
         * Changing this will create a new resource.
         */
        diskType: string;
        /**
         * Specifies the encryption KMS ID of the **DATA** disk.
         * Changing this will create a new resource.
         */
        kmsId: string;
        /**
         * Specifies the bandwidth (Mbit/s). The value range for bandwidth billed by bandwidth
         * is 1 to 2000 and that for bandwidth billed by traffic is 1 to 300.
         * Changing this creates a new resource.
         */
        size: number;
        /**
         * Specifies the disk type. Changing this will create a new resource.
         * Available options are:
         * + `SAS`: high I/O disk type.
         * + `SSD`: ultra-high I/O disk type.
         * + `GPSSD`: general purpose SSD disk type.
         */
        volumeType: string;
    }

    export interface ConfigurationInstanceConfigPersonality {
        content: string;
        /**
         * Specifies the path of the injected file. Changing this creates a new resource.
         */
        path: string;
    }

    export interface ConfigurationInstanceConfigPublicIp {
        /**
         * Specifies the EIP configuration that will be automatically assigned to the instance.
         * The object structure is documented below. Changing this will create a new resource.
         */
        eip: outputs.As.ConfigurationInstanceConfigPublicIpEip;
    }

    export interface ConfigurationInstanceConfigPublicIpEip {
        /**
         * Specifies the bandwidth information. The object structure is documented below.
         * Changing this will create a new resource.
         */
        bandwidth: outputs.As.ConfigurationInstanceConfigPublicIpEipBandwidth;
        /**
         * Specifies the EIP type. Possible values are **5_bgp** (dynamic BGP)
         * and **5_sbgp** (static BGP). Changing this will create a new resource.
         */
        ipType: string;
    }

    export interface ConfigurationInstanceConfigPublicIpEipBandwidth {
        /**
         * Specifies whether the bandwidth is billed by traffic or by bandwidth
         * size. The value can be **traffic** or **bandwidth**. Changing this creates a new resource.
         */
        chargingMode: string;
        /**
         * Specifies the bandwidth sharing type. The system only supports
         * **PER** (indicates exclusive bandwidth). Changing this will create a new resource.
         */
        shareType: string;
        /**
         * Specifies the bandwidth (Mbit/s). The value range for bandwidth billed by bandwidth
         * is 1 to 2000 and that for bandwidth billed by traffic is 1 to 300.
         * Changing this creates a new resource.
         */
        size: number;
    }

    export interface GroupLbaasListener {
        /**
         * Specifies the backend ECS group ID.
         */
        poolId: string;
        /**
         * Specifies the backend protocol, which is the port on which a backend ECS listens for
         * traffic. The number of the port ranges from 1 to 65535.
         */
        protocolPort: number;
        /**
         * Specifies the weight, which determines the portion of requests a backend ECS processes
         * compared to other backend ECSs added to the same listener. The value of this parameter ranges from 0 to 100. The
         * default value is 1.
         */
        weight?: number;
    }

    export interface GroupNetwork {
        /**
         * The UUID of the security group.
         */
        id: string;
    }

    export interface GroupSecurityGroup {
        /**
         * The UUID of the security group.
         */
        id: string;
    }

    export interface PolicyScalingPolicyAction {
        /**
         * The number of instances to be operated. The default number is 1.
         */
        instanceNumber?: number;
        /**
         * The operation to be performed. The options include `ADD` (default), `REMOVE`,
         * and `SET`.
         */
        operation: string;
    }

    export interface PolicyScheduledPolicy {
        /**
         * The end time of the scaling action triggered periodically. The time format complies
         * with UTC. This argument is mandatory when `scalingPolicyType`
         * is set to `RECURRENCE`. The time format is YYYY-MM-DDThh:mmZ.
         */
        endTime: string;
        /**
         * The time when the scaling action is triggered.
         * + If `scalingPolicyType` is set to `SCHEDULED`, the time format is YYYY-MM-DDThh:mmZ.
         * + If `scalingPolicyType` is set to `RECURRENCE`, the time format is hh:mm.
         */
        launchTime: string;
        /**
         * The periodic triggering type. This argument is mandatory when
         * `scalingPolicyType` is set to `RECURRENCE`. The options include `Daily`, `Weekly`, and `Monthly`.
         */
        recurrenceType: string;
        /**
         * The frequency at which scaling actions are triggered.
         */
        recurrenceValue: string;
        /**
         * The start time of the scaling action triggered periodically. The time format
         * complies with UTC. The current time is used by default. The time format is YYYY-MM-DDThh:mmZ.
         */
        startTime?: string;
    }

}

export namespace Bcs {
    export interface InstanceBlockInfo {
        /**
         * Specifies the volume of the block, the unit is MB. The default value is 2.
         * Changing this creates a new instance.
         */
        blockSize?: number;
        /**
         * Specifies the block generation time, the unit is second. The defalt
         * value is 2. Changing this creates a new instance.
         */
        generationInterval?: number;
        /**
         * Specifies the number of transactions included in the block. The
         * defalt value is 500. Changing this creates a new instance.
         */
        transactionQuantity?: number;
    }

    export interface InstanceChannel {
        /**
         * Specifies the name of the channel. Changing this creates a new instance.
         */
        name: string;
        orgNames: string[];
    }

    export interface InstanceCouchdb {
        /**
         * Specifies the password of the couch datebase. The password consists of 8 to
         * 26 characters and must consist at least three of following: uppercase letters, lowercase letters, digits, special
         * charactors(!@$%^-_=+[{}]:,./?). Changing this creates a new instance.
         */
        password: string;
        /**
         * Specifies the user name of the couch datebase. Changing this creates a new
         * instance.
         */
        userName: string;
    }

    export interface InstanceKafka {
        /**
         * Specifies the availability zone in which to create the kafka. The
         * list must contain one or more than three availability zone. Please
         * following [reference](https://developer.huaweicloud.com/en-us/endpoint/?all) for the values. Changing this creates a
         * new instance.
         */
        availabilityZones: string[];
        /**
         * Specifies the kafka flavor type. Changing this creates a new instance.
         * + `c3.mini` : Mini type, the reference bandwidth is 100MB/s.
         * + `c3.small.2` : Small type, the reference bandwidth is 300MB/s.
         * + `c3.middle.2` : Middle type, the reference bandwidth is 600MB/s.
         * + `c3.high.2` : High type, the reference bandwidth is 1200MB/s.
         */
        flavor: string;
        /**
         * Specifies the name of the channel. Changing this creates a new instance.
         */
        name: string;
        /**
         * Specifies the kafka storage capacity. The storage capacity must be an
         * integral multiple of 100 and the maximum is 90000GB. Changing this creates a new instance.
         * + The minimum storage capacity of mini type is 600GB.
         * + The minimum storage capacity of small type is 1200GB.
         * + The minimum storage capacity of middle type is 2400GB.
         * + The minimum storage capacity of high type is 4800GB.
         */
        storageSize: number;
    }

    export interface InstancePeerOrg {
        addresses: outputs.Bcs.InstancePeerOrgAddress[];
        /**
         * Specifies the number of peers in organization. Changing this creates a new
         * instance.
         */
        count: number;
        /**
         * Specifies the name of the peer organization. Changing this creates a new
         * instance.
         */
        orgName: string;
        pvcName: string;
        /**
         * The status of the BCS instance.
         */
        status: string;
        statusDetail: string;
    }

    export interface InstancePeerOrgAddress {
        domainPort: string;
        ipPort: string;
    }

    export interface InstanceSfsTurbo {
        /**
         * Specifies the availability zone in which to create the kafka. The
         * list must contain one or more than three availability zone. Please
         * following [reference](https://developer.huaweicloud.com/en-us/endpoint/?all) for the values. Changing this creates a
         * new instance.
         */
        availabilityZone?: string;
        /**
         * Specifies the kafka flavor type. Changing this creates a new instance.
         * + `c3.mini` : Mini type, the reference bandwidth is 100MB/s.
         * + `c3.small.2` : Small type, the reference bandwidth is 300MB/s.
         * + `c3.middle.2` : Middle type, the reference bandwidth is 600MB/s.
         * + `c3.high.2` : High type, the reference bandwidth is 1200MB/s.
         */
        flavor?: string;
        /**
         * Specifies the share type of the SFS turbo. Changing this creates a new
         * instance.
         */
        shareType: string;
        /**
         * Specifies the type of SFS turbo. Changing this creates a new instance.
         */
        type?: string;
    }

}

export namespace Bms {
    export interface GetFlavorsFlavor {
        /**
         * Specifies the CPU architecture of the BMS flavor.
         * The value can be x8664 and aarch64, defaults to **x86_64**.
         */
        cpuArch: string;
        /**
         * The id or name of the BMS flavor.
         */
        id: string;
        /**
         * Specifies the memory size(GB) in the BMS flavor.
         */
        memory: number;
        /**
         * The operation status of the BMS flavor in an each AZs.
         */
        operation: string;
        /**
         * Specifies the number of vCPUs in the BMS flavor.
         */
        vcpus: number;
    }

    export interface InstanceDataDisk {
        /**
         * Specifies the data disk size, in GB. The value ranges form 10 to 32768. Changing
         * this creates a new instance.
         */
        size: number;
        /**
         * Specifies the BMS data disk type, which must be one of available disk types,
         * contains of *SSD*, *GPSSD* and *SAS*. Changing this creates a new instance.
         */
        type: string;
    }

    export interface InstanceNic {
        /**
         * Specifies a fixed IPv4 address to be used on this network. Changing this
         * creates a new instance.
         */
        ipAddress: string;
        macAddress: string;
        portId: string;
        /**
         * Specifies the ID of subnet to attach to the instance. Changing this creates
         * a new instance.
         */
        subnetId: string;
    }

}

export namespace Cbr {
    export interface GetVaultsVault {
        /**
         * The allocated capacity of the vault, in GB.
         */
        allocated: number;
        /**
         * Specifies whether to enable automatic expansion of the backup protection
         * type vault. Default to **false**.
         */
        autoExpandEnabled: boolean;
        /**
         * Specifies the backup specifications.
         * The valid values are as follows:
         * + **[crashConsistent](https://support.huaweicloud.com/intl/en-us/usermanual-cbr/cbr_03_0109.html)**
         * + **[appConsistent](https://support.huaweicloud.com/intl/en-us/usermanual-cbr/cbr_03_0109.html)**
         */
        consistentLevel: string;
        /**
         * Specifies a unique ID in UUID format of enterprise project.
         */
        enterpriseProjectId: string;
        /**
         * The vault ID in UUID format.
         */
        id: string;
        /**
         * Specifies a unique name of the CBR vault. This parameter can contain a maximum of 64
         * characters, which may consist of letters, digits, underscores(_) and hyphens (-).
         */
        name: string;
        /**
         * Specifies a policy to associate with the CBR vault.
         * The `policyId` cannot be used with the vault of replicate protection type.
         */
        policyId: string;
        /**
         * Specifies the protection type of the CBR vault.
         * The valid values are **backup** and **replication**. Vaults of type **disk** don't support **replication**.
         */
        protectionType: string;
        /**
         * An array of one or more resources to attach to the CBR vault.
         * The object structure is documented below.
         */
        resources: outputs.Cbr.GetVaultsVaultResource[];
        /**
         * Specifies the vault sapacity, in GB. The valid value range is `1` to `10,485,760`.
         */
        size: number;
        /**
         * The specification code.
         */
        specCode: string;
        /**
         * Specifies the CBR vault status, including **available**, **lock**, **frozen** and **error**.
         */
        status: string;
        /**
         * The name of the bucket for the vault.
         */
        storage: string;
        /**
         * The key/value pairs to associate with the CBR vault.
         */
        tags: {[key: string]: string};
        /**
         * Specifies the object type of the CBR vault. The vaild values are as follows:
         * + **server** (Cloud Servers)
         * + **disk** (EVS Disks)
         * + **turbo** (SFS Turbo file systems)
         */
        type: string;
        /**
         * The used capacity, in GB.
         */
        used: number;
    }

    export interface GetVaultsVaultResource {
        /**
         * An array of disk IDs which will be excluded in the backup.
         */
        excludes: string[];
        /**
         * An array of disk or SFS file system IDs which will be included in the backup.
         */
        includes: string[];
        /**
         * The ID of the ECS instance to be backed up.
         */
        serverId: string;
    }

    export interface PolicyBackupCycle {
        /**
         * Specifies the weekly backup day of backup schedule. It supports seven days a week (MO, TU,
         * WE, TH, FR, SA, SU) and this parameter is separated by a comma (,) without spaces, between date and date during the
         * configuration.
         */
        days?: string;
        /**
         * Specifies the backup time. Automated backups will be triggered at the backup
         * time. The current time is in the UTC format (HH:MM). The minutes in the list must be set to **00** and the hours
         * cannot be repeated. In the replication policy, you are advised to set one time point for one day.
         */
        executionTimes: string[];
        /**
         * Specifies the interval (in days) of backup schedule. The value range is `1` to `30`. This
         * parameter and `days` are alternative.
         */
        interval?: number;
    }

    export interface PolicyLongTermRetention {
        /**
         * - Specifies the latest backup of each day is saved in the long term.
         */
        daily?: number;
        /**
         * - Specifies the latest backup of each month is saved in the long term.
         */
        monthly?: number;
        /**
         * - Specifies the latest backup of each week is saved in the long term.
         */
        weekly?: number;
        /**
         * - Specifies the latest backup of each year is saved in the long term.
         */
        yearly?: number;
    }

    export interface VaultResource {
        /**
         * Specifies the array of disk IDs which will be excluded in the backup.
         * Only **server** vault support this parameter.
         */
        excludes: string[];
        /**
         * Specifies the array of disk or SFS file system IDs which will be included in the backup.
         * Only **disk** and **turbo** vault support this parameter.
         */
        includes: string[];
        /**
         * Specifies the ID of the ECS instance to be backed up.
         */
        serverId?: string;
    }

}

export namespace Cce {
    export interface AddonValues {
        /**
         * Specifies the key/value pairs vary depending on the add-on.
         * Only supports non-nested structure and only supports string type elements.
         * This is an alternative to `basicJson`, but it is not recommended.
         * Changing this parameter will create a new resource.
         */
        basic?: {[key: string]: string};
        /**
         * Specifies the json string vary depending on the add-on.
         * Changing this parameter will create a new resource.
         */
        basicJson?: string;
        /**
         * Specifies the key/value pairs vary depending on the add-on.
         * Only supports non-nested structure and only supports string type elements.
         * This is an alternative to `customJson`, but it is not recommended.
         * Changing this parameter will create a new resource.
         */
        custom?: {[key: string]: string};
        /**
         * Specifies the json string vary depending on the add-on.
         * Changing this parameter will create a new resource.
         */
        customJson?: string;
        /**
         * Specifies the key/value pairs vary depending on the add-on.
         * Only supports non-nested structure and only supports string type elements.
         * This is an alternative to `flavorJson`, but it is not recommended.
         * Changing this parameter will create a new resource.
         */
        flavor?: {[key: string]: string};
        /**
         * Specifies the json string vary depending on the add-on.
         * Changing this parameter will create a new resource.
         */
        flavorJson?: string;
    }

    export interface ClusterCertificateCluster {
        /**
         * The certificate data.
         */
        certificateAuthorityData: string;
        /**
         * Specifies the cluster name.
         * Changing this parameter will create a new cluster resource.
         */
        name: string;
        /**
         * The server IP address.
         */
        server: string;
    }

    export interface ClusterCertificateUser {
        /**
         * The client certificate data.
         */
        clientCertificateData: string;
        /**
         * The client key data.
         */
        clientKeyData: string;
        /**
         * Specifies the cluster name.
         * Changing this parameter will create a new cluster resource.
         */
        name: string;
    }

    export interface ClusterMaster {
        /**
         * Specifies the availability zone of the master node.
         * Changing this parameter will create a new cluster resource.
         */
        availabilityZone: string;
    }

    export interface GetAddonTemplateSupportVersion {
        bareMetals: string[];
        virtualMachines: string[];
    }

    export interface GetClusterCertificateCluster {
        /**
         * The certificate data.
         */
        certificateAuthorityData: string;
        /**
         * Specifies the name of the cluster.
         */
        name: string;
        /**
         * The server IP address.
         */
        server: string;
    }

    export interface GetClusterCertificateUser {
        /**
         * The client certificate data.
         */
        clientCertificateData: string;
        /**
         * The client key data.
         */
        clientKeyData: string;
        /**
         * Specifies the name of the cluster.
         */
        name: string;
    }

    export interface GetClusterEndpoint {
        /**
         * The type of the cluster access address.
         * + **Internal**: The user's subnet access address.
         * + **External**: The public network access address.
         */
        type: string;
        /**
         * The URL of the cluster access address.
         */
        url: string;
    }

    export interface GetClusterMaster {
        /**
         * The availability zone (AZ) of the master node.
         */
        availabilityZone: string;
    }

    export interface GetClustersCluster {
        /**
         * The authentication mode of the cluster, possible values are x509 and rbac. Defaults to **rbac**.
         */
        authenticationMode: string;
        /**
         * The charging mode of the cluster.
         */
        billingMode: number;
        /**
         * The certificate clusters. Structure is documented below.
         */
        certificateClusters: outputs.Cce.GetClustersClusterCertificateCluster[];
        /**
         * The certificate users. Structure is documented below.
         */
        certificateUsers: outputs.Cce.GetClustersClusterCertificateUser[];
        /**
         * Specifies the type of the cluster. Possible values: **VirtualMachine**, **BareMetal**.
         */
        clusterType: string;
        /**
         * The version of the cluster.
         */
        clusterVersion: string;
        /**
         * The container network segment.
         */
        containerNetworkCidr: string;
        /**
         * The container network type: **overlay_l2** , **underlay_ipvlan**, **vpc-router** or **eni**.
         */
        containerNetworkType: string;
        /**
         * The description of the cluster.
         */
        description: string;
        /**
         * The access addresses of kube-apiserver in the cluster. Structure is documented below.
         */
        endpoints: outputs.Cce.GetClustersClusterEndpoint[];
        /**
         * The ENI network segment.
         */
        eniSubnetCidr: string;
        /**
         * The ENI subnet ID.
         */
        eniSubnetId: string;
        /**
         * Specifies the enterprise project ID of the cluster.
         */
        enterpriseProjectId: string;
        /**
         * The specification of the cluster.
         */
        flavorId: string;
        /**
         * The ID of the cluster.
         */
        id: string;
        /**
         * The raw Kubernetes config to be used by kubectl and other compatible tools.
         */
        kubeConfigRaw: string;
        /**
         * The advanced configuration of master nodes.
         */
        masters: outputs.Cce.GetClustersClusterMaster[];
        /**
         * Specifies the name of the cluster.
         */
        name: string;
        /**
         * The security group ID of the cluster.
         */
        securityGroupId: string;
        /**
         * The service network segment.
         */
        serviceNetworkCidr: string;
        /**
         * Specifies the status of the cluster.
         */
        status: string;
        /**
         * The ID of the subnet used to create the node.
         */
        subnetId: string;
        /**
         * Specifies the VPC ID to which the cluster belongs.
         */
        vpcId: string;
    }

    export interface GetClustersClusterCertificateCluster {
        /**
         * The certificate data.
         */
        certificateAuthorityData: string;
        /**
         * Specifies the name of the cluster.
         */
        name: string;
        /**
         * The server IP address.
         */
        server: string;
    }

    export interface GetClustersClusterCertificateUser {
        /**
         * The client certificate data.
         */
        clientCertificateData: string;
        /**
         * The client key data.
         */
        clientKeyData: string;
        /**
         * Specifies the name of the cluster.
         */
        name: string;
    }

    export interface GetClustersClusterEndpoint {
        /**
         * The type of the cluster access address.
         * + **Internal**: The user's subnet access address.
         * + **External**: The public network access address.
         */
        type: string;
        /**
         * The URL of the cluster access address.
         */
        url: string;
    }

    export interface GetClustersClusterMaster {
        availabilityZone: string;
    }

    export interface GetNodeDataVolume {
        /**
         * Disk expansion parameters.
         */
        extendParams: {[key: string]: string};
        /**
         * Disk size in GB.
         */
        size: number;
        /**
         * Disk type.
         */
        volumetype: string;
    }

    export interface GetNodePoolDataVolume {
        /**
         * Disk expansion parameters.
         */
        extendParams: {[key: string]: string};
        /**
         * Disk size in GB.
         */
        size: number;
        /**
         * Disk type.
         */
        volumetype: string;
    }

    export interface GetNodePoolRootVolume {
        /**
         * Disk expansion parameters.
         */
        extendParams: {[key: string]: string};
        /**
         * Disk size in GB.
         */
        size: number;
        /**
         * Disk type.
         */
        volumetype: string;
    }

    export interface GetNodeRootVolume {
        /**
         * Disk expansion parameters.
         */
        extendParams: {[key: string]: string};
        /**
         * Disk size in GB.
         */
        size: number;
        /**
         * Disk type.
         */
        volumetype: string;
    }

    export interface GetNodesNode {
        /**
         * The available partitions where the node is located.
         */
        availabilityZone: string;
        /**
         * The node's billing mode: The value is 0 (on demand).
         */
        billingMode: number;
        /**
         * The data related configuration. Structure is documented below.
         */
        dataVolumes: outputs.Cce.GetNodesNodeDataVolume[];
        /**
         * The ID of ECS group to which the node belongs.
         */
        ecsGroupId: string;
        /**
         * The flavor ID to be used.
         */
        flavorId: string;
        /**
         * The ID of the node.
         */
        id: string;
        /**
         * The key pair name when logging in to select the key pair mode.
         */
        keyPair: string;
        /**
         * Specifies the of the node.
         */
        name: string;
        /**
         * The operating System of the node.
         */
        os: string;
        /**
         * The private IP of the node.
         */
        privateIp: string;
        /**
         * The elastic IP parameters of the node.
         */
        publicIp: string;
        /**
         * The system disk related configuration. Structure is documented below.
         */
        rootVolumes: outputs.Cce.GetNodesNodeRootVolume[];
        /**
         * The node's virtual machine ID in ECS.
         */
        serverId: string;
        /**
         * Specifies the status of the node.
         */
        status: string;
        /**
         * The ID of the subnet to which the NIC belongs.
         */
        subnetId: string;
        /**
         * The tags of a VM node, key/value pair format.
         */
        tags: {[key: string]: string};
    }

    export interface GetNodesNodeDataVolume {
        /**
         * Disk expansion parameters.
         */
        extendParams: {[key: string]: string};
        /**
         * Disk size in GB.
         */
        size: number;
        /**
         * Disk type.
         */
        volumetype: string;
    }

    export interface GetNodesNodeRootVolume {
        /**
         * Disk expansion parameters.
         */
        extendParams: {[key: string]: string};
        /**
         * Disk size in GB.
         */
        size: number;
        /**
         * Disk type.
         */
        volumetype: string;
    }

    export interface NodeAttachDataVolume {
        extendParam: string;
        extendParams: {[key: string]: string};
        hwPassthrough: boolean;
        kmsKeyId: string;
        size: number;
        volumetype: string;
    }

    export interface NodeAttachRootVolume {
        extendParam: string;
        extendParams: {[key: string]: string};
        hwPassthrough: boolean;
        size: number;
        volumetype: string;
    }

    export interface NodeAttachTaint {
        /**
         * Available options are NoSchedule, PreferNoSchedule, and NoExecute.
         * Changing this parameter will create a new resource.
         */
        effect: string;
        /**
         * A key must contain 1 to 63 characters starting with a letter or digit.
         * Only letters, digits, hyphens (-), underscores (_), and periods (.) are allowed. A DNS subdomain name can be used
         * as the prefix of a key. Changing this parameter will create a new resource.
         */
        key: string;
        /**
         * A value must start with a letter or digit and can contain a maximum of 63
         * characters, including letters, digits, hyphens (-), underscores (_), and periods (.). Changing this parameter will
         * create a new resource.
         */
        value: string;
    }

    export interface NodeDataVolume {
        /**
         * Specifies the extended parameter.
         * Changing this parameter will create a new resource.
         * The available keys are as follows:
         * + **agency_name**: The agency name to provide temporary credentials for CCE node to access other cloud services.
         * + **alpha.cce/NodeImageID**: The custom image ID used to create the BMS nodes.
         * + **dockerBaseSize**: The available disk space of a single docker container on the node in device mapper mode.
         * + **DockerLVMConfigOverride**: Specifies the data disk configurations of Docker.
         *
         * @deprecated use extend_params instead
         */
        extendParam?: string;
        /**
         * Specifies the disk expansion parameters.
         * Changing this parameter will create a new resource.
         */
        extendParams: {[key: string]: string};
        hwPassthrough?: boolean;
        /**
         * Specifies the ID of a KMS key. This is used to encrypt the volume.
         * Changing this parameter will create a new resource.
         */
        kmsKeyId: string;
        /**
         * Specifies the size of a virtual space. Only an integer percentage is supported.
         * Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
         * Changing this parameter will create a new resource.
         */
        size: number;
        /**
         * Specifies the disk type.
         * Changing this parameter will create a new resource.
         */
        volumetype: string;
    }

    export interface NodePoolDataVolume {
        /**
         * Specifies the extended parameter.
         * Changing this parameter will create a new resource.
         * The available keys are as follows:
         * + **agency_name**: The agency name to provide temporary credentials for CCE node to access other cloud services.
         * + **alpha.cce/NodeImageID**: The custom image ID used to create the BMS nodes.
         * + **dockerBaseSize**: The available disk space of a single docker container on the node in device mapper mode.
         * + **DockerLVMConfigOverride**: Specifies the data disk configurations of Docker.
         *
         * @deprecated use extend_params instead
         */
        extendParam?: string;
        /**
         * Specifies the disk expansion parameters.
         * Changing this parameter will create a new resource.
         */
        extendParams?: {[key: string]: string};
        hwPassthrough?: boolean;
        /**
         * Specifies the KMS key ID. This is used to encrypt the volume.
         * Changing this parameter will create a new resource.
         */
        kmsKeyId: string;
        /**
         * Specifies the disk size in GB. Changing this parameter will create a new resource.
         */
        size: number;
        /**
         * Specifies the disk type. Changing this parameter will create a new resource.
         */
        volumetype: string;
    }

    export interface NodePoolRootVolume {
        /**
         * Specifies the extended parameter.
         * Changing this parameter will create a new resource.
         * The available keys are as follows:
         * + **agency_name**: The agency name to provide temporary credentials for CCE node to access other cloud services.
         * + **alpha.cce/NodeImageID**: The custom image ID used to create the BMS nodes.
         * + **dockerBaseSize**: The available disk space of a single docker container on the node in device mapper mode.
         * + **DockerLVMConfigOverride**: Specifies the data disk configurations of Docker.
         *
         * @deprecated use extend_params instead
         */
        extendParam?: string;
        /**
         * Specifies the disk expansion parameters.
         * Changing this parameter will create a new resource.
         */
        extendParams?: {[key: string]: string};
        hwPassthrough?: boolean;
        /**
         * Specifies the disk size in GB. Changing this parameter will create a new resource.
         */
        size: number;
        /**
         * Specifies the disk type. Changing this parameter will create a new resource.
         */
        volumetype: string;
    }

    export interface NodePoolTaint {
        /**
         * Available options are NoSchedule, PreferNoSchedule, and NoExecute.
         */
        effect: string;
        /**
         * A key must contain 1 to 63 characters starting with a letter or digit. Only letters,
         * digits, hyphens (-), underscores (_), and periods (.) are allowed. A DNS subdomain name can be used as the
         * prefix of a key.
         */
        key: string;
        /**
         * A value must start with a letter or digit and can contain a maximum of 63 characters,
         * including letters, digits, hyphens (-), underscores (_), and periods (.).
         */
        value: string;
    }

    export interface NodeRootVolume {
        /**
         * Specifies the extended parameter.
         * Changing this parameter will create a new resource.
         * The available keys are as follows:
         * + **agency_name**: The agency name to provide temporary credentials for CCE node to access other cloud services.
         * + **alpha.cce/NodeImageID**: The custom image ID used to create the BMS nodes.
         * + **dockerBaseSize**: The available disk space of a single docker container on the node in device mapper mode.
         * + **DockerLVMConfigOverride**: Specifies the data disk configurations of Docker.
         *
         * @deprecated use extend_params instead
         */
        extendParam?: string;
        /**
         * Specifies the disk expansion parameters.
         * Changing this parameter will create a new resource.
         */
        extendParams: {[key: string]: string};
        hwPassthrough?: boolean;
        /**
         * Specifies the size of a virtual space. Only an integer percentage is supported.
         * Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
         * Changing this parameter will create a new resource.
         */
        size: number;
        /**
         * Specifies the disk type.
         * Changing this parameter will create a new resource.
         */
        volumetype: string;
    }

    export interface NodeStorage {
        /**
         * Specifies the storage group consists of multiple storage devices.
         * This is used to divide storage space. Structure is documented below.
         * Changing this parameter will create a new resource.
         */
        groups: outputs.Cce.NodeStorageGroup[];
        /**
         * Specifies the disk selection.
         * Matched disks are managed according to match labels and storage type. Structure is documented below.
         * Changing this parameter will create a new resource.
         */
        selectors: outputs.Cce.NodeStorageSelector[];
    }

    export interface NodeStorageGroup {
        /**
         * Specifies the whether the storage space is for **kubernetes** and
         * **runtime** components. Only one group can be set to true. The default value is **false**.
         * Changing this parameter will create a new resource.
         */
        cceManaged?: boolean;
        /**
         * Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
         * and **user** are supported. Changing this parameter will create a new resource.
         */
        name: string;
        /**
         * Specifies the list of names of seletors to match.
         * This parameter corresponds to name in `selectors`. A group can match multiple selectors,
         * but a selector can match only one group. Changing this parameter will create a new resource.
         */
        selectorNames: string[];
        /**
         * Specifies the detailed management of space configuration in a group.
         * Changing this parameter will create a new resource.
         */
        virtualSpaces: outputs.Cce.NodeStorageGroupVirtualSpace[];
    }

    export interface NodeStorageGroupVirtualSpace {
        /**
         * Specifies the LVM write mode, values can be **linear** and **striped**.
         * This parameter takes effect only in **kubernetes** and **user** configuration. Changing this parameter will create
         * a new resource.
         */
        lvmLvType?: string;
        /**
         * Specifies the absolute path to which the disk is attached.
         * This parameter takes effect only in **user** configuration. Changing this parameter will create a new resource.
         */
        lvmPath?: string;
        /**
         * Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
         * and **user** are supported. Changing this parameter will create a new resource.
         */
        name: string;
        /**
         * Specifies the LVM write mode, values can be **linear** and **striped**.
         * This parameter takes effect only in **runtime** configuration. Changing this parameter will create a new resource.
         */
        runtimeLvType?: string;
        /**
         * Specifies the size of a virtual space. Only an integer percentage is supported.
         * Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
         * Changing this parameter will create a new resource.
         */
        size: string;
    }

    export interface NodeStorageSelector {
        /**
         * Specifies the number of disks to be selected. If omitted,
         * all disks of this type are selected. Changing this parameter will create a new resource.
         */
        matchLabelCount?: string;
        /**
         * Specifies the cstomer master key ID of an encrypted
         * disk. Changing this parameter will create a new resource.
         */
        matchLabelMetadataCmkid?: string;
        /**
         * Specifies the disk encryption identifier.
         * Values can be: **0** indicates that the disk is not encrypted and **1** indicates that the disk is encrypted.
         * If omitted, whether the disk is encrypted is not limited. Changing this parameter will create a new resource.
         */
        matchLabelMetadataEncrypted?: string;
        /**
         * Specifies the matched disk size. If omitted,
         * the disk size is not limited. Example: 100. Changing this parameter will create a new resource.
         */
        matchLabelSize?: string;
        /**
         * Specifies the EVS disk type. Currently,
         * **SSD**, **GPSSD**, and **SAS** are supported. If omitted, the disk type is not limited.
         * Changing this parameter will create a new resource.
         */
        matchLabelVolumeType?: string;
        /**
         * Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
         * and **user** are supported. Changing this parameter will create a new resource.
         */
        name: string;
        /**
         * Specifies the storage type. Currently, only **evs (EVS volumes)** is supported.
         * The default value is **evs**. Changing this parameter will create a new resource.
         */
        type?: string;
    }

    export interface NodeTaint {
        /**
         * Available options are NoSchedule, PreferNoSchedule, and NoExecute.
         * Changing this parameter will create a new resource.
         */
        effect: string;
        /**
         * A key must contain 1 to 63 characters starting with a letter or digit.
         * Only letters, digits, hyphens (-), underscores (_), and periods (.) are allowed. A DNS subdomain name can be used
         * as the prefix of a key. Changing this parameter will create a new resource.
         */
        key: string;
        /**
         * A value must start with a letter or digit and can contain a maximum of 63
         * characters, including letters, digits, hyphens (-), underscores (_), and periods (.). Changing this parameter will
         * create a new resource.
         */
        value: string;
    }
}

export namespace Cci {
    export interface GetNamespacesNamespace {
        /**
         * Whether elastic scheduling is enabled.
         */
        autoExpendEnabled: boolean;
        /**
         * Whether container network is enabled.
         */
        containerNetworkEnabled: boolean;
        /**
         * The time when the namespace was created in UTC format, such as **2021-09-27T01:30:39Z**.
         */
        createdAt: string;
        /**
         * Specifies the enterprise project ID in UUID format.
         */
        enterpriseProjectId: string;
        /**
         * The VPC ID in UUID format.
         */
        id: string;
        /**
         * Specifies th name of the specified CCI namespace.
         * This parameter can contain a maximum of 63 characters, which may consist of lowercase letters, digits and hyphens,
         * and must start and end with lowercase letters and digits.
         */
        name: string;
        /**
         * The network information of the CCI namespace. The structure is documented below.
         */
        networks: outputs.Cci.GetNamespacesNamespaceNetwork[];
        /**
         * Whether Role-based access control is enabled.
         * After the RBAC permission is enabled, the user's use of resources under the namespace will be controlled by the RBAC
         * permission.
         */
        rbacEnabled: boolean;
        /**
         * The IP address recycling interval in hour.
         * The idle IP resources from the elastic expansion of the IP resource pool can be recycled within this time.
         */
        recyclingInterval: number;
        /**
         * The CCI namespace status.
         */
        status: string;
        /**
         * Specifies the CCI namespace type.
         * The valid values are **general-computing** and **gpu-accelerated**.
         */
        type: string;
        /**
         * The size of IP pool to warm-up.
         */
        warmupPoolSize: number;
    }

    export interface GetNamespacesNamespaceNetwork {
        /**
         * Specifies th name of the specified CCI namespace.
         * This parameter can contain a maximum of 63 characters, which may consist of lowercase letters, digits and hyphens,
         * and must start and end with lowercase letters and digits.
         */
        name: string;
        /**
         * The default security group ID in UUID format.
         */
        securityGroupId: string;
        /**
         * The network information of the VPC under the CCI network. The structure is documented below.
         */
        vpcs: outputs.Cci.GetNamespacesNamespaceNetworkVpc[];
    }

    export interface GetNamespacesNamespaceNetworkVpc {
        /**
         * The VPC ID in UUID format.
         */
        id: string;
        /**
         * The network ID of the VPC subnet in UUID format.
         */
        networkId: string;
        /**
         * The subnet CIDR block.
         */
        subnetCidr: string;
        /**
         * The VPC subnet ID in UUID format.
         */
        subnetId: string;
    }

}

export namespace Cdm {
    export interface ClusterInstance {
        /**
         * Instance ID.
         */
        id: string;
        /**
         * Management IP address.
         */
        manageIp: string;
        /**
         * Specifies cluster name. Changing this parameter will create a new resource.
         */
        name: string;
        /**
         * Private IP.
         */
        privateIp: string;
        /**
         * Public IP.
         */
        publicIp: string;
        /**
         * Instance role.
         */
        role: string;
        /**
         * Traffic IP.
         */
        trafficIp: string;
        /**
         * Instance type.
         */
        type: string;
    }

    export interface GetFlavorsFlavor {
        /**
         * The id of the cdm flavor.
         */
        id: string;
        /**
         * The name of the cdm flavor.
         */
        name: string;
    }

    export interface JobConfig {
        /**
         * Specifies group to which a job belongs. The default group is `DEFAULT`.
         */
        groupName?: string;
        /**
         * Specifies whether to automatically retry if a job fails to be executed.
         * The options are as follows:
         * + **NONE**: Do not retry.
         * + **RETRY_TRIPLE**: Retry three times.
         */
        retryType?: string;
        /**
         * Specifies cycle of a scheduled task. If `schedulerCycleType` is set to minute
         * and `schedulerCycle` is set to 10, the scheduled task is executed every 10 minutes.
         */
        schedulerCycle?: number;
        /**
         * Specifies cycle type of a scheduled task. The options are as follows:
         * `minute`, `hour`, `day`, `week`, `month`.
         */
        schedulerCycleType?: string;
        /**
         * Specifies whether to delete a job after the job is executed.
         * The options are as follows:
         * + **NONE**: The job will not be deleted after it is executed.
         * + **DELETE_AFTER_SUCCEED**: The job will be deleted only after it is successfully executed. It is applicable to
         * massive one-time jobs.
         * + **DELETE**: Thejob will be deleted after it is executed, regardless of the execution result.
         */
        schedulerDisposableType?: string;
        /**
         * Specifies whether to enable a scheduled task.  Default value is `false`.
         */
        schedulerEnabled?: boolean;
        /**
         * Specifies time when a scheduled task is triggered in a cycle. This parameter
         * is valid only when `schedulerCycleType` is set to `hour`, `week`, or `month`.
         * + If `schedulerCycleType` is set to month, cycle is set to 1, and runAt is set to 15, the scheduled task is executed
         * on the 15th day of each month. You can set runAt to multiple values and separate the values with commas (,).
         * For example, if runAt is set to 1,2,3,4,5, the scheduled task is executed on the first day, second day, third day,
         * fourth day, and fifth day of each month.
         * + If `schedulerCycleType` is set to week and runAt is set to mon,tue,wed,thu,fri, the scheduled task is executed on
         * Monday to Friday.
         * + If `schedulerCycleType` is set to hour and runAt is set to 27,57, the scheduled task is executed at the 27th and
         * 57th minute in the cycle.
         */
        schedulerRunAt?: string;
        /**
         * Specifies start time of a scheduled task.
         * For example, `2018-01-24 19:56:19`
         */
        schedulerStartDate?: string;
        /**
         * Specifies End time of a scheduled task. For example, `2018-01-27 23:59:00`.
         * If you do not set the end time, the scheduled task is always executed and will never stop.
         */
        schedulerStopDate?: string;
        /**
         * Specifies name of the OBS bucket to which dirty data is
         * written. This parameter is valid only when dirty data is written to `OBS`.
         */
        throttlingDirtyWriteToBucket?: string;
        /**
         * Specifies the directory in the OBS bucket or HDFS which
         * dirty data is written to. For example, `/data/dirtydata/`.
         */
        throttlingDirtyWriteToDirectory?: string;
        /**
         * Specifies the link name to which dirty data is written to.
         * The Dirty data can be written only to `OBS` or `HDFS`.
         */
        throttlingDirtyWriteToLink?: string;
        /**
         * Specifies maximum number of concurrent extraction jobs.
         */
        throttlingExtractorsNumber?: number;
        /**
         * Specifies maximum number of loading jobs. This parameter is available
         * only when HBase or Hive serves as the destination data source.
         */
        throttlingLoaderNumber?: number;
        /**
         * Specifies maximum number of error records in a single
         * shard. When the number of error records of a map exceeds the upper limit, the task automatically ends.
         */
        throttlingMaxErrorRecords?: number;
        /**
         * Specifies whether to write dirty data.
         */
        throttlingRecordDirtyData?: boolean;
    }

}

export namespace Cdn {
    export interface DomainCacheSettings {
        /**
         * Specifies whether to enable origin cache control.
         */
        followOrigin?: boolean;
        /**
         * Specifies the cache rules, which overwrite the previous rule configurations.
         * Blank rules are reset to default rules. The object structure is documented below.
         */
        rules?: outputs.Cdn.DomainCacheSettingsRule[];
    }

    export interface DomainCacheSettingsRule {
        /**
         * Specifies the content that matches `ruleType`. If `ruleType` is set to **0**,
         * this parameter is empty. If `ruleType` is set to **1**, the value of this parameter is a list of file name
         * extensions. A file name extension starts with a period (.). File name extensions are separated by semicolons (;),
         * for example, .jpg;.zip;.exe. If `ruleType` is set to **2**, the value of this parameter is a list of directories.
         * A directory starts with a slash (/). Directories are separated by semicolons (;), for example,
         * /test/folder01;/test/folder02.
         */
        content?: string;
        /**
         * Specifies the priority weight of this rule. The default value is 1.
         * A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
         */
        priority: number;
        /**
         * Specifies the rule type. Possible value are:
         * **0**: All types of files are matched. It is the default value.
         * **1**: Files are matched based on their suffixes.
         * **2**: Files are matched based on their directories.
         * **3**: Files are matched based on their full paths.
         */
        ruleType: number;
        /**
         * Specifies the cache age. The maximum cache age is 365 days.
         */
        ttl: number;
        /**
         * Specifies the unit of the cache age. Possible values: **1** (second), **2** (minute),
         * **3** (hour), and **4** (day).
         */
        ttlType: number;
    }

    export interface DomainConfigs {
        /**
         * Specifies the settings for caching URL parameters.
         * The object structure is documented below.
         */
        cacheUrlParameterFilter: outputs.Cdn.DomainConfigsCacheUrlParameterFilter;
        /**
         * Specifies the smart compression. The object structure
         * is documented below.
         */
        compress: outputs.Cdn.DomainConfigsCompress;
        /**
         * Specifies the force redirect.
         * The object structure is documented below.
         */
        forceRedirect: outputs.Cdn.DomainConfigsForceRedirect;
        /**
         * Specifies the HTTP response header settings.
         * The object structure is documented below.
         */
        httpResponseHeaders: outputs.Cdn.DomainConfigsHttpResponseHeader[];
        /**
         * Specifies the certificate configuration. The object
         * structure is documented below.
         */
        httpsSettings: outputs.Cdn.DomainConfigsHttpsSettings;
        /**
         * Specifies whether to enable IPv6.
         */
        ipv6Enable?: boolean;
        /**
         * Specifies the content retrieval protocol. Possible values:
         * + **follow**: same as user requests.
         * + **http**: HTTP, which is the default value.
         * + **https**: HTTPS.
         */
        originProtocol: string;
        /**
         * Specifies whether to enable range-based retrieval.
         */
        rangeBasedRetrievalEnabled?: boolean;
        /**
         * Specifies the retrieval request header settings.
         * The object structure is documented below.
         */
        retrievalRequestHeaders: outputs.Cdn.DomainConfigsRetrievalRequestHeader[];
        /**
         * Specifies the URL signing.
         * The object structure is documented below.
         */
        urlSigning: outputs.Cdn.DomainConfigsUrlSigning;
    }

    export interface DomainConfigsCacheUrlParameterFilter {
        /**
         * Specifies the operation type for caching URL parameters. Posiible values are:
         * **full_url**: cache all parameters
         * **ignore_url_params**: ignore all parameters
         * **del_args**: ignore specific URL parameters
         * **reserve_args**: reserve specified URL parameters
         */
        type: string;
        /**
         * Specifies the parameter values. Multiple values are separated by semicolons (;).
         */
        value?: string;
    }

    export interface DomainConfigsCompress {
        /**
         * Specifies the whether to enable force redirect or smart compression.
         */
        enabled: boolean;
        status: string;
        /**
         * Specifies the operation type for caching URL parameters. Posiible values are:
         * **full_url**: cache all parameters
         * **ignore_url_params**: ignore all parameters
         * **del_args**: ignore specific URL parameters
         * **reserve_args**: reserve specified URL parameters
         */
        type: string;
    }

    export interface DomainConfigsForceRedirect {
        /**
         * Specifies the whether to enable force redirect or smart compression.
         */
        enabled: boolean;
        status: string;
        /**
         * Specifies the operation type for caching URL parameters. Posiible values are:
         * **full_url**: cache all parameters
         * **ignore_url_params**: ignore all parameters
         * **del_args**: ignore specific URL parameters
         * **reserve_args**: reserve specified URL parameters
         */
        type: string;
    }

    export interface DomainConfigsHttpResponseHeader {
        /**
         * Specifies the operation type of request or response
         */
        action: string;
        /**
         * Specifies the request or response header.
         */
        name: string;
        /**
         * Specifies the parameter values. Multiple values are separated by semicolons (;).
         */
        value?: string;
    }

    export interface DomainConfigsHttpsSettings {
        /**
         * Specifies the content of the certificate used by the HTTPS protocol.
         * This parameter is mandatory when a certificate is configured. The value is in PEM format.
         */
        certificateBody: string;
        /**
         * Specifies the certificate name. The value contains 3 to 32 characters.
         * This parameter is mandatory when a certificate is configured.
         */
        certificateName: string;
        /**
         * Specifies the certificate type. Possible values are:
         * + **1**: Huawei-managed certificate.
         * + **0**: your own certificate.
         */
        certificateSource: number;
        /**
         * Specifies whether HTTP/2 is used.
         */
        http2Enabled: boolean;
        http2Status: string;
        /**
         * Specifies whether to enable HTTPS.
         */
        httpsEnabled: boolean;
        httpsStatus: string;
        /**
         * Specifies the private key used by the HTTPS protocol. This parameter is mandatory
         * when a certificate is configured. The value is in PEM format.
         */
        privateKey: string;
        /**
         * Specifies the transport Layer Security (TLS). Currently, **TLSv1.0**,
         * **TLSv1.1**, **TLSv1.2**, and **TLSv1.3** are supported. By default, all versions are enabled. You can enable
         * a single version or consecutive versions. To enable multiple versions, use commas (,) to separate versions,
         * for example, **TLSv1.1,TLSv1.2**.
         */
        tlsVersion: string;
    }

    export interface DomainConfigsRetrievalRequestHeader {
        /**
         * Specifies the operation type of request or response
         */
        action: string;
        /**
         * Specifies the request or response header.
         */
        name: string;
        /**
         * Specifies the parameter values. Multiple values are separated by semicolons (;).
         */
        value?: string;
    }

    export interface DomainConfigsUrlSigning {
        /**
         * Specifies the whether to enable force redirect or smart compression.
         */
        enabled: boolean;
        /**
         * Specifies the expiration time. The value ranges from **0** to **31536000**,
         * in seconds.
         */
        expireTime: number;
        /**
         * Specifies the authentication key contains 6 to 32 characters, including letters and digits.
         */
        key: string;
        status: string;
        /**
         * Specifies the time format. Possible values are:
         * **dec**: Decimal, can be used in Method A, Method B and Method C2.
         * **hex**: Hexadecimal, can be used in Method C1 and Method C2.
         */
        timeFormat: string;
        /**
         * Specifies the operation type for caching URL parameters. Posiible values are:
         * **full_url**: cache all parameters
         * **ignore_url_params**: ignore all parameters
         * **del_args**: ignore specific URL parameters
         * **reserve_args**: reserve specified URL parameters
         */
        type: string;
    }

    export interface DomainSource {
        /**
         * Whether an origin server is active or standby (1: active; 0: standby). The default value is
         * 1.
         */
        active?: number;
        /**
         * Specifies the HTTP port. Default value: **80**.
         */
        httpPort: number;
        /**
         * Specifies the HTTPS port. Default value: **443**.
         */
        httpsPort: number;
        /**
         * Whether to enable static website hosting for the OBS bucket.
         * This parameter is mandatory when the `originType` is **obs_bucket**.
         */
        obsWebHostingEnabled: boolean;
        /**
         * The domain name or IP address of the origin server.
         */
        origin: string;
        /**
         * The origin server type. The valid values are 'ipaddr', 'domain', and 'obs_bucket'.
         */
        originType: string;
        /**
         * Specifies the retrieval host. The default value is the acceleration domain name.
         */
        retrievalHost: string;
    }

}

export namespace Cse {
    export interface AlarmruleAlarmAction {
        /**
         * specifies the list of objects to be notified if the alarm status changes, the
         * maximum length is 5.
         */
        notificationLists: string[];
        /**
         * specifies the type of action triggered by an alarm. the value is notification.
         * notification: indicates that a notification will be sent to the user.
         */
        type: string;
    }

    export interface AlarmruleCondition {
        /**
         * Specifies the comparison condition of alarm thresholds. The value can be >,
         * =, <, >=, or <=.
         */
        comparisonOperator: string;
        /**
         * Specifies the number of consecutive occurrence times. The value ranges from 1 to 5.
         */
        count: number;
        /**
         * Specifies the data rollup methods. The value can be max, min, average, sum, and vaiance.
         */
        filter: string;
        /**
         * Specifies the alarm checking period in seconds. The value can be 0, 1, 300, 1200, 3600, 14400,
         * and 86400.
         */
        period: number;
        /**
         * Specifies the interval for triggering an alarm if the alarm persists.
         * Changing this creates a new resource. Possible values are as follows:
         * + **0**: Cloud Eye triggers the alarm only once;
         * + **300**: Cloud Eye triggers the alarm every 5 minutes;
         * + **600**: Cloud Eye triggers the alarm every 10 minutes;
         * + **900**: Cloud Eye triggers the alarm every 15 minutes;
         * + **1800**: Cloud Eye triggers the alarm every 30 minutes;
         * + **3600**: Cloud Eye triggers the alarm every hour;
         * + **10800**: Cloud Eye triggers the alarm every 3 hours;
         * + **21600**: Cloud Eye triggers the alarm every 6 hours;
         * + **43200**: Cloud Eye triggers the alarm every 12 hour;
         * + **86400**: Cloud Eye triggers the alarm every day.
         */
        suppressDuration?: number;
        /**
         * Specifies the data unit. Changing this creates a new resource.
         * For details, see [Services Interconnected with Cloud Eye](https://support.huaweicloud.com/intl/en-us/api-ces/ces_03_0059.html).
         */
        unit?: string;
        /**
         * Specifies the alarm threshold. The value ranges from 0 to Number of
         * 1.7976931348623157e+308.
         */
        value: number;
    }

    export interface AlarmruleInsufficientdataAction {
        /**
         * specifies the list of objects to be notified if the alarm status changes, the
         * maximum length is 5.
         */
        notificationLists: string[];
        /**
         * specifies the type of action triggered by an alarm. the value is notification.
         * notification: indicates that a notification will be sent to the user.
         */
        type: string;
    }

    export interface AlarmruleMetric {
        /**
         * Specifies the list of metric dimensions. The structure is described below.
         * Changing this creates a new resource.
         */
        dimensions?: outputs.Cse.AlarmruleMetricDimension[];
        /**
         * Specifies the metric name. The value can be a string of 1 to 64
         * characters that must start with a letter and contain only letters, digits, and underscores (_).
         * Changing this creates a new resource.
         * For details, see [Services Interconnected with Cloud Eye](https://support.huaweicloud.com/intl/en-us/api-ces/ces_03_0059.html).
         */
        metricName: string;
        /**
         * Specifies the namespace in **service.item** format. **service** and **item**
         * each must be a string that starts with a letter and contains only letters, digits, and underscores (_).
         * Changing this creates a new resource.
         * For details, see [Services Interconnected with Cloud Eye](https://support.huaweicloud.com/intl/en-us/api-ces/ces_03_0059.html).
         */
        namespace: string;
    }

    export interface AlarmruleMetricDimension {
        /**
         * Specifies the dimension name. The value can be a string of 1 to 32 characters
         * that must start with a letter and contain only letters, digits, underscores (_), and hyphens (-).
         * Changing this creates a new resource.
         */
        name: string;
        /**
         * Specifies the alarm threshold. The value ranges from 0 to Number of
         * 1.7976931348623157e+308.
         */
        value: string;
    }

    export interface AlarmruleOkAction {
        /**
         * specifies the list of objects to be notified if the alarm status changes, the
         * maximum length is 5.
         */
        notificationLists: string[];
        /**
         * specifies the type of action triggered by an alarm. the value is notification.
         * notification: indicates that a notification will be sent to the user.
         */
        type: string;
    }

    export interface MicroserviceEngineConfigCenterAddress {
        /**
         * The internal access address.
         */
        private: string;
        /**
         * The public access address. This address is only set when EIP is bound.
         */
        public: string;
    }

    export interface MicroserviceEngineServiceRegistryAddress {
        /**
         * The internal access address.
         */
        private: string;
        /**
         * The public access address. This address is only set when EIP is bound.
         */
        public: string;
    }

    export interface MicroserviceInstanceDataCenter {
        /**
         * Specifies the custom availability zone name of the data center.
         * Changing this will create a new microservice instance.
         */
        availabilityZone: string;
        /**
         * Specifies the data center name.
         * Changing this will create a new microservice instance.
         */
        name: string;
        /**
         * Specifies the custom region name of the data center.
         * Changing this will create a new microservice instance.
         */
        region: string;
    }

    export interface MicroserviceInstanceHealthCheck {
        /**
         * Specifies the heartbeat interval. The unit is **s** (second).
         * Changing this will create a new microservice instance.
         */
        interval: number;
        /**
         * Specifies the maximum retries.
         * Changing this will create a new microservice instance.
         */
        maxRetries: number;
        /**
         * Specifies the heartbeat mode. The valid values are **push** and **pull**.
         * Changing this will create a new microservice instance.
         */
        mode: string;
        /**
         * Specifies the port number.
         * Changing this will create a new microservice instance.
         */
        port: number;
    }

}

export namespace Css {
    export interface ClusterBackupStrategy {
        /**
         * Specifies the IAM agency used to access OBS.
         */
        agency: string;
        /**
         * Specifies the storage path of the snapshot in the OBS bucket.
         */
        backupPath: string;
        /**
         * Specifies the OBS bucket used for index data backup. If there is snapshot data in an OBS
         * bucket, only the OBS bucket is used and cannot be changed.
         */
        bucket: string;
        /**
         * Specifies the number of days to retain the generated snapshots. Snapshots are reserved
         * for seven days by default.
         */
        keepDays?: number;
        /**
         * Specifies the prefix of the snapshot that is automatically created. The default value
         * is "snapshot".
         */
        prefix?: string;
        /**
         * Specifies the time when a snapshot is automatically created everyday. Snapshots can
         * only be created on the hour. The time format is the time followed by the time zone, specifically, **HH:mm z**. In the
         * format, HH:mm refers to the hour time and z refers to the time zone. For example, "00:00 GMT+08:00"
         * and "01:00 GMT+08:00".
         */
        startTime: string;
    }

    export interface ClusterClientNodeConfig {
        /**
         * Specifies the flavor name. For example: value range of flavor ess.spec-2u8g:
         * 40 GB to 800 GB, value range of flavor ess.spec-4u16g: 40 GB to 1600 GB, value range of flavor ess.spec-8u32g: 80 GB
         * to 3200 GB, value range of flavor ess.spec-16u64g: 100 GB to 6400 GB, value range of flavor ess.spec-32u128g: 100 GB
         * to 10240 GB. Changing this parameter will create a new resource.
         */
        flavor: string;
        /**
         * Specifies the number of cluster instances.
         * + When it is `essNodeConfig`, The value range is 1 to 200.
         * + When it is `masterNodeConfig`, The value range is 3 to 10.
         * + When it is `clientNodeConfig`, The value range is 1 to 32.
         * + When it is `coldNodeConfig`, The value range is 1 to 32.
         */
        instanceNumber: number;
        /**
         * Specifies the information about the volume.
         * The volume structure is documented below.
         */
        volume: outputs.Css.ClusterClientNodeConfigVolume;
    }

    export interface ClusterClientNodeConfigVolume {
        /**
         * Specifies the volume size in GB, which must be a multiple of 10.
         */
        size: number;
        /**
         * Specifies the volume type. COMMON: Common I/O. The SATA disk is used.
         * HIGH: High I/O. The SAS disk is used. ULTRAHIGH: Ultra-high I/O. The solid-state drive (SSD) is used. Changing this
         * parameter will create a new resource.
         */
        volumeType: string;
    }

    export interface ClusterColdNodeConfig {
        /**
         * Specifies the flavor name. For example: value range of flavor ess.spec-2u8g:
         * 40 GB to 800 GB, value range of flavor ess.spec-4u16g: 40 GB to 1600 GB, value range of flavor ess.spec-8u32g: 80 GB
         * to 3200 GB, value range of flavor ess.spec-16u64g: 100 GB to 6400 GB, value range of flavor ess.spec-32u128g: 100 GB
         * to 10240 GB. Changing this parameter will create a new resource.
         */
        flavor: string;
        /**
         * Specifies the number of cluster instances.
         * + When it is `essNodeConfig`, The value range is 1 to 200.
         * + When it is `masterNodeConfig`, The value range is 3 to 10.
         * + When it is `clientNodeConfig`, The value range is 1 to 32.
         * + When it is `coldNodeConfig`, The value range is 1 to 32.
         */
        instanceNumber: number;
        /**
         * Specifies the information about the volume.
         * The volume structure is documented below.
         */
        volume: outputs.Css.ClusterColdNodeConfigVolume;
    }

    export interface ClusterColdNodeConfigVolume {
        /**
         * Specifies the volume size in GB, which must be a multiple of 10.
         */
        size: number;
        /**
         * Specifies the volume type. COMMON: Common I/O. The SATA disk is used.
         * HIGH: High I/O. The SAS disk is used. ULTRAHIGH: Ultra-high I/O. The solid-state drive (SSD) is used. Changing this
         * parameter will create a new resource.
         */
        volumeType: string;
    }

    export interface ClusterEssNodeConfig {
        /**
         * Specifies the flavor name. For example: value range of flavor ess.spec-2u8g:
         * 40 GB to 800 GB, value range of flavor ess.spec-4u16g: 40 GB to 1600 GB, value range of flavor ess.spec-8u32g: 80 GB
         * to 3200 GB, value range of flavor ess.spec-16u64g: 100 GB to 6400 GB, value range of flavor ess.spec-32u128g: 100 GB
         * to 10240 GB. Changing this parameter will create a new resource.
         */
        flavor: string;
        /**
         * Specifies the number of cluster instances.
         * + When it is `essNodeConfig`, The value range is 1 to 200.
         * + When it is `masterNodeConfig`, The value range is 3 to 10.
         * + When it is `clientNodeConfig`, The value range is 1 to 32.
         * + When it is `coldNodeConfig`, The value range is 1 to 32.
         */
        instanceNumber: number;
        /**
         * Specifies the information about the volume.
         * The volume structure is documented below.
         */
        volume: outputs.Css.ClusterEssNodeConfigVolume;
    }

    export interface ClusterEssNodeConfigVolume {
        /**
         * Specifies the volume size in GB, which must be a multiple of 10.
         */
        size: number;
        /**
         * Specifies the volume type. COMMON: Common I/O. The SATA disk is used.
         * HIGH: High I/O. The SAS disk is used. ULTRAHIGH: Ultra-high I/O. The solid-state drive (SSD) is used. Changing this
         * parameter will create a new resource.
         */
        volumeType: string;
    }

    export interface ClusterKibanaPublicAccess {
        /**
         * Specifies the public network bandwidth.
         */
        bandwidth: number;
        publicIp: string;
        /**
         * Specifies the whitelist of access control.
         * Separate the whitelisted Account IDs with commas (,), and each of them must be unique.
         */
        whitelist?: string;
        /**
         * Specifies whether to enable the public network access control.
         */
        whitelistEnabled: boolean;
    }

    export interface ClusterMasterNodeConfig {
        /**
         * Specifies the flavor name. For example: value range of flavor ess.spec-2u8g:
         * 40 GB to 800 GB, value range of flavor ess.spec-4u16g: 40 GB to 1600 GB, value range of flavor ess.spec-8u32g: 80 GB
         * to 3200 GB, value range of flavor ess.spec-16u64g: 100 GB to 6400 GB, value range of flavor ess.spec-32u128g: 100 GB
         * to 10240 GB. Changing this parameter will create a new resource.
         */
        flavor: string;
        /**
         * Specifies the number of cluster instances.
         * + When it is `essNodeConfig`, The value range is 1 to 200.
         * + When it is `masterNodeConfig`, The value range is 3 to 10.
         * + When it is `clientNodeConfig`, The value range is 1 to 32.
         * + When it is `coldNodeConfig`, The value range is 1 to 32.
         */
        instanceNumber: number;
        /**
         * Specifies the information about the volume.
         * The volume structure is documented below.
         */
        volume: outputs.Css.ClusterMasterNodeConfigVolume;
    }

    export interface ClusterMasterNodeConfigVolume {
        /**
         * Specifies the volume size in GB, which must be a multiple of 10.
         */
        size: number;
        /**
         * Specifies the volume type. COMMON: Common I/O. The SATA disk is used.
         * HIGH: High I/O. The SAS disk is used. ULTRAHIGH: Ultra-high I/O. The solid-state drive (SSD) is used. Changing this
         * parameter will create a new resource.
         */
        volumeType: string;
    }

    export interface ClusterNode {
        /**
         * Specifies the availability zone name.
         * Separate multiple AZs with commas (,), for example, az1,az2. AZs must be unique. The number of nodes must be greater
         * than or equal to the number of AZs. If the number of nodes is a multiple of the number of AZs, the nodes are evenly
         * distributed to each AZ. If the number of nodes is not a multiple of the number of AZs, the absolute difference
         * between node quantity in any two AZs is 1 at most.
         * Changing this parameter will create a new resource.
         */
        availabilityZone: string;
        /**
         * Instance ID.
         */
        id: string;
        /**
         * Specifies the cluster name. It contains 4 to 32 characters.
         * Only letters, digits, hyphens (-), and underscores (_) are allowed. The value must start with a letter.
         * Changing this parameter will create a new resource.
         */
        name: string;
        specCode: string;
        /**
         * The cluster status
         * + `100`: The operation, such as instance creation, is in progress.
         * + `200`: The cluster is available.
         * + `303`: The cluster is unavailable.
         */
        status: string;
        /**
         * Node type. The options are as follows:
         */
        type: string;
    }

    export interface ClusterNodeConfig {
        /**
         * Specifies the availability zone name.
         * Separate multiple AZs with commas (,), for example, az1,az2. AZs must be unique. The number of nodes must be greater
         * than or equal to the number of AZs. If the number of nodes is a multiple of the number of AZs, the nodes are evenly
         * distributed to each AZ. If the number of nodes is not a multiple of the number of AZs, the absolute difference
         * between node quantity in any two AZs is 1 at most.
         * Changing this parameter will create a new resource.
         */
        availabilityZone: string;
        /**
         * Specifies the flavor name. For example: value range of flavor ess.spec-2u8g:
         * 40 GB to 800 GB, value range of flavor ess.spec-4u16g: 40 GB to 1600 GB, value range of flavor ess.spec-8u32g: 80 GB
         * to 3200 GB, value range of flavor ess.spec-16u64g: 100 GB to 6400 GB, value range of flavor ess.spec-32u128g: 100 GB
         * to 10240 GB. Changing this parameter will create a new resource.
         */
        flavor: string;
        networkInfo: outputs.Css.ClusterNodeConfigNetworkInfo;
        /**
         * Specifies the information about the volume.
         * The volume structure is documented below.
         */
        volume: outputs.Css.ClusterNodeConfigVolume;
    }

    export interface ClusterNodeConfigNetworkInfo {
        /**
         * Specifies Security group ID.
         * Changing this parameter will create a new resource.
         */
        securityGroupId: string;
        /**
         * Specifies the Subnet ID. Changing this parameter will create a new resource.
         */
        subnetId: string;
        /**
         * Specifies the VPC ID. Changing this parameter will create a new resource.
         */
        vpcId: string;
    }

    export interface ClusterNodeConfigVolume {
        /**
         * Specifies the volume size in GB, which must be a multiple of 10.
         */
        size: number;
        /**
         * Specifies the volume type. COMMON: Common I/O. The SATA disk is used.
         * HIGH: High I/O. The SAS disk is used. ULTRAHIGH: Ultra-high I/O. The solid-state drive (SSD) is used. Changing this
         * parameter will create a new resource.
         */
        volumeType: string;
    }

    export interface ClusterPublicAccess {
        /**
         * Specifies the public network bandwidth.
         */
        bandwidth: number;
        publicIp: string;
        /**
         * Specifies the whitelist of access control.
         * Separate the whitelisted Account IDs with commas (,), and each of them must be unique.
         */
        whitelist?: string;
        /**
         * Specifies whether to enable the public network access control.
         */
        whitelistEnabled: boolean;
    }

    export interface ClusterVpcepEndpoint {
        /**
         * Specifies whether to enable the private domain name.
         */
        endpointWithDnsName: boolean;
        /**
         * Specifies the whitelist of access control.
         * Separate the whitelisted Account IDs with commas (,), and each of them must be unique.
         */
        whitelists?: string[];
    }

    export interface GetFlavorsFlavor {
        /**
         * The disk capacity range of an instance, in GB.
         */
        diskRange: string;
        /**
         * The ID of CSS flavor.
         */
        id: string;
        /**
         * Specifies the memory size(GB) in the CSS flavor.
         */
        memory: number;
        /**
         * Specifies the name of the CSS flavor.
         */
        name: string;
        /**
         * Specifies the region in which to obtain the CSS flavors. If omitted, the
         * provider-level region will be used.
         */
        region: string;
        /**
         * Specifies the node instance type. The options are `ess`, `ess-cold`, `ess-master`
         * and `ess-client`.
         */
        type: string;
        /**
         * Specifies the number of vCPUs in the CSS flavor.
         */
        vcpus: number;
        /**
         * Specifies the engine version. The options are `5.5.1`, `6.2.3`, `6.5.4`, `7.1.1`,
         * `7.6.2` and `7.9.3`.
         */
        version: string;
    }

}

export namespace Cts {
    export interface NotificationOperation {
        /**
         * Specifies the resource type.
         */
        resource: string;
        /**
         * Specifies the cloud service.
         */
        service: string;
        /**
         * Specifies an array of trace names.
         */
        traceNames: string[];
    }

    export interface NotificationOperationUser {
        /**
         * Specifies the IAM user group name.
         */
        group: string;
        /**
         * Specifies an array of IAM users in the group.
         */
        users: string[];
    }

}

export namespace Dcs {
    export interface GetFlavorsFlavor {
        /**
         * An array of available zones where the cache specification can be used.
         */
        availableZones: string[];
        /**
         * The mode of a cache engine. The valid values are as follows:
         */
        cacheMode: string;
        /**
         * The total memory of the cache, in GB.
         * + **Redis4.0 and Redis5.0**: Stand-alone and active/standby type instance values:
         * `0.125`, `0.25`, `0.5`, `1`, `2`, `4`, `8`, `16`, `32` and `64`.
         * Cluster instance specifications support `24`, `32`, `48`, `64`, `96`, `128`, `192`, `256`, `384`, `512`, `768` and
         * `1024`.
         * + **Redis3.0**: Stand-alone and active/standby type instance values: `2`, `4`, `8`, `16`, `32` and `64`.
         * Proxy cluster instance specifications support `64`, `128`, `256`, `512`, and `1024`.
         * + **Memcached**: Stand-alone and active/standby type instance values: `2`, `4`, `8`, `16`, `32` and `64`.
         */
        capacity: number;
        /**
         * The charging modes for the specification cache instance.
         */
        chargingModes: string[];
        /**
         * The CPU architecture of cache instance.
         * Valid values *x86_64* and *aarch64*.
         */
        cpuArchitecture: string;
        /**
         * The engine of the cache instance. Valid values are *Redis* and *Memcached*.
         * Default value is *Redis*.
         */
        engine: string;
        /**
         * Supported versions of the specification.
         */
        engineVersions: string;
        /**
         * Number of IP addresses corresponding to the specifications.
         */
        ipCount: number;
        /**
         * The flavor name of the cache instance.
         */
        name: string;
    }

    export interface InstanceBackupPolicy {
        /**
         * Day in a week on which backup starts, the value ranges from 1 to 7.
         * Where: 1 indicates Monday; 7 indicates Sunday.
         */
        backupAts: number[];
        /**
         * Backup type. Default value is `auto`. The valid values are as follows:
         * + `auto`: automatic backup.
         * + `manual`: manual backup.
         */
        backupType?: string;
        /**
         * Time at which backup starts.
         * Format: `hh24:00-hh24:00`, "00:00-01:00" indicates that backup starts at 00:00:00.
         */
        beginAt: string;
        /**
         * Interval at which backup is performed. Default value is `weekly`.
         * Currently, only weekly backup is supported.
         */
        periodType?: string;
        /**
         * Retention time. Unit: day, the value ranges from 1 to 7.
         */
        saveDays?: number;
    }

    export interface InstanceWhitelist {
        /**
         * Specifies the name of IP address group.
         */
        groupName: string;
        /**
         * Specifies the list of IP address or CIDR which can be whitelisted for an instance.
         * The maximum is 20.
         */
        ipAddresses: string[];
    }

}

export namespace Dds {
    export interface DatabaseRoleInheritedPrivilege {
        /**
         * The operation permission list.
         */
        actions: string[];
        /**
         * The details of the resource to which the privilege belongs.
         * The object structure is documented below.
         */
        resources: outputs.Dds.DatabaseRoleInheritedPrivilegeResource[];
    }

    export interface DatabaseRoleInheritedPrivilegeResource {
        /**
         * The database collection type.
         */
        collection: string;
        /**
         * Specifies the database name to which this owned role belongs.
         * Changing this parameter will create a new role.
         */
        dbName: string;
    }

    export interface DatabaseRolePrivilege {
        /**
         * The operation permission list.
         */
        actions: string[];
        /**
         * The details of the resource to which the privilege belongs.
         * The object structure is documented below.
         */
        resources: outputs.Dds.DatabaseRolePrivilegeResource[];
    }

    export interface DatabaseRolePrivilegeResource {
        /**
         * The database collection type.
         */
        collection: string;
        /**
         * Specifies the database name to which this owned role belongs.
         * Changing this parameter will create a new role.
         */
        dbName: string;
    }

    export interface DatabaseRoleRole {
        /**
         * Specifies the database name to which this owned role belongs.
         * Changing this parameter will create a new role.
         */
        dbName: string;
        /**
         * Specifies the name of role owned by the current role.
         * The name can contain `1` to `64` characters, only letters, digits, underscores (_), hyphens (-) and dots (.) are
         * allowed. Changing this parameter will create a new role.
         */
        name: string;
    }

    export interface DatabaseUserInheritedPrivilege {
        /**
         * The operation permission list.
         */
        actions: string[];
        /**
         * The details of the resource to which the privilege belongs.
         * The object structure is documented below.
         */
        resources: outputs.Dds.DatabaseUserInheritedPrivilegeResource[];
    }

    export interface DatabaseUserInheritedPrivilegeResource {
        /**
         * The database collection type.
         */
        collection: string;
        /**
         * Specifies the database name to which this owned role belongs.
         * Changing this parameter will create a new user.
         */
        dbName: string;
    }

    export interface DatabaseUserPrivilege {
        /**
         * The operation permission list.
         */
        actions: string[];
        /**
         * The details of the resource to which the privilege belongs.
         * The object structure is documented below.
         */
        resources: outputs.Dds.DatabaseUserPrivilegeResource[];
    }

    export interface DatabaseUserPrivilegeResource {
        /**
         * The database collection type.
         */
        collection: string;
        /**
         * Specifies the database name to which this owned role belongs.
         * Changing this parameter will create a new user.
         */
        dbName: string;
    }

    export interface DatabaseUserRole {
        /**
         * Specifies the database name to which this owned role belongs.
         * Changing this parameter will create a new user.
         */
        dbName: string;
        /**
         * Specifies the name of role owned by the current user.
         * The name can contain `1` to `64` characters, only letters, digits, underscores (_), hyphens (-) and dots (.) are
         * allowed. Changing this parameter will create a new user.
         */
        name: string;
    }

    export interface GetFlavorsFlavor {
        /**
         * Specifies the ram of the dds flavor in GB.
         */
        memory: string;
        /**
         * The name of the dds flavor.
         */
        specCode: string;
        /**
         * Specifies the type of the dds falvor. "mongos", "shard", "config", "replica" and "single"
         * are supported.
         */
        type: string;
        /**
         * Specifies the vcpus of the dds flavor.
         */
        vcpus: string;
    }

    export interface InstanceBackupStrategy {
        /**
         * Specifies the number of days to retain the generated backup files. The value range is
         * from 0 to 732.
         * + If this parameter is set to 0, the automated backup policy is not set.
         * + If this parameter is not transferred, the automated backup policy is enabled by default. Backup files are stored
         * for seven days by default.
         */
        keepDays: number;
        /**
         * Specifies the backup time window. Automated backups will be triggered during the
         * backup time window. The value cannot be empty. It must be a valid value in the
         * "hh:mm-HH:MM" format. The current time is in the UTC format.
         * + The HH value must be 1 greater than the hh value.
         * + The values from mm and MM must be the same and must be set to any of the following 00, 15, 30, or 45.
         */
        startTime: string;
    }

    export interface InstanceDatastore {
        /**
         * Specifies the storage engine of the DB instance. DDS Community Edition
         * supports wiredTiger engine, and the Enhanced Edition supports rocksDB engine.
         */
        storageEngine?: string;
        /**
         * Specifies the node type. Valid value:
         * + For a Community Edition cluster instance, the value can be mongos, shard, or config.
         * + For an Enhanced Edition cluster instance, the value is shard.
         * + For a Community Edition replica set instance, the value is replica.
         * + For a Community Edition single node instance, the value is single.
         */
        type: string;
        /**
         * Specifies the DB instance version. For the Community Edition, the valid
         * values are 3.2, 3.4, or 4.0. For the Enhanced Edition, only 3.4 is supported now.
         */
        version: string;
    }

    export interface InstanceFlavor {
        /**
         * Specifies the node quantity. Valid value:
         * + In a Community Edition cluster instance,the number of mongos ranges from 2 to 16.
         * + In a Community Edition cluster instance,the number of shards ranges from 2 to 16.
         * + In an Enhanced Edition cluster instance, the number of shards ranges from 2 to 12.
         * + config: the value is 1.
         * + replica: the value is 1.
         * + single: The value is 1. This parameter can be updated when the value of `type` is mongos or shard.
         */
        num: number;
        /**
         * Specifies the disk size. The value must be a multiple of 10. The unit is GB. This parameter
         * is mandatory for nodes except mongos and invalid for mongos. This parameter can be updated when the value of `type` is
         * shard, replica or single.
         */
        size?: number;
        /**
         * Specifies the resource specification code. In a cluster instance, multiple
         * specifications need to be specified. All specifications must be of the same series, that is, general-purpose (s6),
         * enhanced (c3), or enhanced II (c6). For example:
         * + dds.mongodb.s6.large.4.mongos and dds.mongodb.s6.large.4.config have the same specifications.
         * + dds.mongodb.s6.large.4.mongos and dds.mongodb.c3.large.4.config are not of the same specifications. This parameter
         * can be updated when the value of `type` is mongos, shard, replica or single.
         */
        specCode: string;
        /**
         * Specifies the disk type. Valid value: ULTRAHIGH which indicates the type SSD.
         */
        storage?: string;
        /**
         * Specifies the node type. Valid value:
         * + For a Community Edition cluster instance, the value can be mongos, shard, or config.
         * + For an Enhanced Edition cluster instance, the value is shard.
         * + For a Community Edition replica set instance, the value is replica.
         * + For a Community Edition single node instance, the value is single.
         */
        type: string;
    }

    export interface InstanceNode {
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the DB instance name. The DB instance name of the same type is unique in the
         * same tenant.
         */
        name: string;
        /**
         * Indicates the private IP address of a node. This parameter is valid only for mongos nodes, replica set
         * instances, and single node instances.
         */
        privateIp: string;
        /**
         * Indicates the EIP that has been bound on a node. This parameter is valid only for mongos nodes of
         * cluster instances, primary nodes and secondary nodes of replica set instances, and single node instances.
         */
        publicIp: string;
        /**
         * Indicates the node role.
         */
        role: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Specifies the node type. Valid value:
         * + For a Community Edition cluster instance, the value can be mongos, shard, or config.
         * + For an Enhanced Edition cluster instance, the value is shard.
         * + For a Community Edition replica set instance, the value is replica.
         * + For a Community Edition single node instance, the value is single.
         */
        type: string;
    }

}

export namespace DedicatedApig {
    export interface ApiBackendParam {
        /**
         * Specifies the description of the constant or system parameter, which contain a
         * maximum of 255 characters, and the angle brackets (< and >) are not allowed.
         */
        description?: string;
        /**
         * Specifies the location of the backend parameter. The valid values are **PATH**,
         * **QUERY** and **HEADER**.
         */
        location: string;
        /**
         * Specifies the backend policy name, which can contains of 3 to 64 characters and start with
         * a letter. Only letters, digits, and underscores (_) are allowed.
         */
        name: string;
        /**
         * Specifies the condition type of the backend policy. The valid values are **Equal**,
         * **Enumerated** and **Matching**, default to **Equal**.
         */
        type: string;
        /**
         * Specifies the condition type. For a condition with the input parameter source:
         * + If the condition type is **Enumerated**, separate condition values with commas.
         * + If the condition type is **Matching**, enter a regular expression compatible with PERL.
         */
        value: string;
    }

    export interface ApiFuncGraph {
        /**
         * Specifies the ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * Specifies the URN of the function graph.
         */
        functionUrn: string;
        /**
         * Specifies the invocation mode. The valid values are **async** and **sync**,
         * default to **sync**.
         */
        invocationType?: string;
        /**
         * Specifies the timeout, in ms, which allowed for APIG to request the backend service. The
         * valid value is range from 1 to 600,000, default to 5,000.
         */
        timeout?: number;
        /**
         * Specifies the version of the function graph.
         */
        version?: string;
    }

    export interface ApiFuncGraphPolicy {
        /**
         * Specifies the ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * Specifies an array of one or more backend parameters. The maximum of request
         * parameters is 50. The object structure is documented above.
         */
        backendParams?: outputs.DedicatedApig.ApiFuncGraphPolicyBackendParam[];
        /**
         * Specifies an array of one or more policy conditions. Up to five conditions can be set.
         * The object structure is documented below.
         */
        conditions: outputs.DedicatedApig.ApiFuncGraphPolicyCondition[];
        /**
         * Specifies the effective mode of the backend policy. The valid values are **ALL**
         * and **ANY**, default to **ANY**.
         */
        effectiveMode?: string;
        /**
         * Specifies the URN of the function graph.
         */
        functionUrn: string;
        /**
         * Specifies the invocation mode of the function graph. The valid values are
         * **async** and **sync**, default to **sync**.
         */
        invocationMode?: string;
        /**
         * Specifies the backend policy name, which can contains of 3 to 64 characters and start with
         * a letter. Only letters, digits, and underscores (_) are allowed.
         */
        name: string;
        /**
         * Specifies the timeout, in ms, which allowed for APIG to request the backend service. The
         * valid value is range from 1 to 600,000, default to 5,000.
         */
        timeout?: number;
        /**
         * Specifies the version of the function graph.
         */
        version?: string;
    }

    export interface ApiFuncGraphPolicyBackendParam {
        /**
         * Specifies the description of the constant or system parameter, which contain a
         * maximum of 255 characters, and the angle brackets (< and >) are not allowed.
         */
        description?: string;
        /**
         * Specifies the location of the backend parameter. The valid values are **PATH**,
         * **QUERY** and **HEADER**.
         */
        location: string;
        /**
         * Specifies the backend policy name, which can contains of 3 to 64 characters and start with
         * a letter. Only letters, digits, and underscores (_) are allowed.
         */
        name: string;
        /**
         * Specifies the condition type of the backend policy. The valid values are **Equal**,
         * **Enumerated** and **Matching**, default to **Equal**.
         */
        type: string;
        /**
         * Specifies the condition type. For a condition with the input parameter source:
         * + If the condition type is **Enumerated**, separate condition values with commas.
         * + If the condition type is **Matching**, enter a regular expression compatible with PERL.
         */
        value: string;
    }

    export interface ApiFuncGraphPolicyCondition {
        /**
         * Specifies the request parameter name. This parameter is required if the policy type
         * is param.
         */
        paramName?: string;
        /**
         * Specifies the policy type. The valid values are **param** and **source**, default to
         * **source**.
         */
        source?: string;
        /**
         * Specifies the condition type of the backend policy. The valid values are **Equal**,
         * **Enumerated** and **Matching**, default to **Equal**.
         */
        type?: string;
        /**
         * Specifies the condition type. For a condition with the input parameter source:
         * + If the condition type is **Enumerated**, separate condition values with commas.
         * + If the condition type is **Matching**, enter a regular expression compatible with PERL.
         */
        value: string;
    }

    export interface ApiMock {
        /**
         * Specifies the ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * Specifies the response of the backend policy, which contain a maximum of 2,048
         * characters, and the angle brackets (< and >) are not allowed.
         */
        response?: string;
    }

    export interface ApiMockPolicy {
        /**
         * Specifies the ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * Specifies an array of one or more backend parameters. The maximum of request
         * parameters is 50. The object structure is documented above.
         */
        backendParams?: outputs.DedicatedApig.ApiMockPolicyBackendParam[];
        /**
         * Specifies an array of one or more policy conditions. Up to five conditions can be set.
         * The object structure is documented below.
         */
        conditions: outputs.DedicatedApig.ApiMockPolicyCondition[];
        /**
         * Specifies the effective mode of the backend policy. The valid values are **ALL**
         * and **ANY**, default to **ANY**.
         */
        effectiveMode?: string;
        /**
         * Specifies the backend policy name, which can contains of 3 to 64 characters and start with
         * a letter. Only letters, digits, and underscores (_) are allowed.
         */
        name: string;
        /**
         * Specifies the response of the backend policy, which contain a maximum of 2,048
         * characters, and the angle brackets (< and >) are not allowed.
         */
        response?: string;
    }

    export interface ApiMockPolicyBackendParam {
        /**
         * Specifies the description of the constant or system parameter, which contain a
         * maximum of 255 characters, and the angle brackets (< and >) are not allowed.
         */
        description?: string;
        /**
         * Specifies the location of the backend parameter. The valid values are **PATH**,
         * **QUERY** and **HEADER**.
         */
        location: string;
        /**
         * Specifies the backend policy name, which can contains of 3 to 64 characters and start with
         * a letter. Only letters, digits, and underscores (_) are allowed.
         */
        name: string;
        /**
         * Specifies the condition type of the backend policy. The valid values are **Equal**,
         * **Enumerated** and **Matching**, default to **Equal**.
         */
        type: string;
        /**
         * Specifies the condition type. For a condition with the input parameter source:
         * + If the condition type is **Enumerated**, separate condition values with commas.
         * + If the condition type is **Matching**, enter a regular expression compatible with PERL.
         */
        value: string;
    }

    export interface ApiMockPolicyCondition {
        /**
         * Specifies the request parameter name. This parameter is required if the policy type
         * is param.
         */
        paramName?: string;
        /**
         * Specifies the policy type. The valid values are **param** and **source**, default to
         * **source**.
         */
        source?: string;
        /**
         * Specifies the condition type of the backend policy. The valid values are **Equal**,
         * **Enumerated** and **Matching**, default to **Equal**.
         */
        type?: string;
        /**
         * Specifies the condition type. For a condition with the input parameter source:
         * + If the condition type is **Enumerated**, separate condition values with commas.
         * + If the condition type is **Matching**, enter a regular expression compatible with PERL.
         */
        value: string;
    }

    export interface ApiPublishmentHistory {
        /**
         * Specifies the description of the current publishment.
         */
        description: string;
        /**
         * Specifies the version ID of the current publishment.
         */
        versionId: string;
    }

    export interface ApiRequestParam {
        /**
         * Specifies the default value of the request parameter, which contain a maximum of 255
         * characters, and the angle brackets (< and >) are not allowed.
         */
        default?: string;
        /**
         * Specifies the description of the constant or system parameter, which contain a
         * maximum of 255 characters, and the angle brackets (< and >) are not allowed.
         */
        description?: string;
        /**
         * Specifies the example value of the request parameter, which contain a maximum of 255
         * characters, and the angle brackets (< and >) are not allowed.
         */
        example?: string;
        /**
         * Specifies the location of the backend parameter. The valid values are **PATH**,
         * **QUERY** and **HEADER**.
         */
        location?: string;
        /**
         * Specifies the maximum value or size of the request parameter.
         */
        maximum?: number;
        /**
         * Specifies the minimum value or size of the request parameter. For string type,
         * The `maximum` and `minimum` means size. For number type, they means value.
         */
        minimum?: number;
        /**
         * Specifies the backend policy name, which can contains of 3 to 64 characters and start with
         * a letter. Only letters, digits, and underscores (_) are allowed.
         */
        name: string;
        /**
         * Specifies whether the request parameter is required.
         */
        required: boolean;
        /**
         * Specifies the condition type of the backend policy. The valid values are **Equal**,
         * **Enumerated** and **Matching**, default to **Equal**.
         */
        type?: string;
    }

    export interface ApiWeb {
        /**
         * Specifies the ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * Specifies the backend service address, which consists of a domain name or IP
         * address, and a port number, with not more than 255 characters. The backend service address must be in the format "Host
         * name:Port number", for example, apig.example.com:7443. If the port number is not specified, the default HTTPS port 443
         * or the default HTTP port 80 is used. The backend service address can contain environment variables, each starting with
         * a letter and consisting of 3 to 32 characters. Only letters, digits, hyphens (-), and underscores (_) are allowed.
         */
        backendAddress?: string;
        /**
         * Specifies the proxy host header. The host header can be customized for requests to
         * be forwarded to cloud servers through the VPC channel. By default, the original host header of the request is used.
         */
        hostHeader?: string;
        /**
         * Specifies the backend request address, which can contain a maximum of 512 characters and
         * must comply with URI specifications.
         * + The request address can contain request parameters enclosed with brackets ({}).
         * + The request address can contain special characters, such as asterisks (*), percent signs (%), hyphens (-) and
         * underscores (_) and must comply with URI specifications.
         * + The address can contain environment variables, each starting with a letter and consisting of 3 to 32 characters.
         * Only letters, digits, hyphens (-), and underscores (_) are allowed in environment variables.
         */
        path: string;
        /**
         * Specifies the backend request method of the API. The valid types are **GET**,
         * **POST**, **PUT**, **DELETE**, **HEAD**, **PATCH**, **OPTIONS** and **ANY**.
         */
        requestMethod?: string;
        /**
         * Specifies the backend request protocol. The valid values are **HTTP** and
         * **HTTPS**, default to **HTTPS**.
         */
        requestProtocol?: string;
        /**
         * Specifies the indicates whether to enable two-way authentication, default to false.
         */
        sslEnable?: boolean;
        /**
         * Specifies the timeout, in ms, which allowed for APIG to request the backend service. The
         * valid value is range from 1 to 600,000, default to 5,000.
         */
        timeout?: number;
        /**
         * Specifies the VPC channel ID. This parameter and `backendAddress` are
         * alternative.
         */
        vpcChannelId?: string;
    }

    export interface ApiWebPolicy {
        /**
         * Specifies the ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * Specifies the backend service address, which consists of a domain name or IP
         * address, and a port number, with not more than 255 characters. The backend service address must be in the format "Host
         * name:Port number", for example, apig.example.com:7443. If the port number is not specified, the default HTTPS port 443
         * or the default HTTP port 80 is used. The backend service address can contain environment variables, each starting with
         * a letter and consisting of 3 to 32 characters. Only letters, digits, hyphens (-), and underscores (_) are allowed.
         */
        backendAddress?: string;
        /**
         * Specifies an array of one or more backend parameters. The maximum of request
         * parameters is 50. The object structure is documented above.
         */
        backendParams?: outputs.DedicatedApig.ApiWebPolicyBackendParam[];
        /**
         * Specifies an array of one or more policy conditions. Up to five conditions can be set.
         * The object structure is documented below.
         */
        conditions: outputs.DedicatedApig.ApiWebPolicyCondition[];
        /**
         * Specifies the effective mode of the backend policy. The valid values are **ALL**
         * and **ANY**, default to **ANY**.
         */
        effectiveMode?: string;
        /**
         * Specifies the proxy host header. The host header can be customized for requests to
         * be forwarded to cloud servers through the VPC channel. By default, the original host header of the request is used.
         */
        hostHeader?: string;
        /**
         * Specifies the backend policy name, which can contains of 3 to 64 characters and start with
         * a letter. Only letters, digits, and underscores (_) are allowed.
         */
        name: string;
        /**
         * Specifies the backend request address, which can contain a maximum of 512 characters and
         * must comply with URI specifications.
         * + The request address can contain request parameters enclosed with brackets ({}).
         * + The request address can contain special characters, such as asterisks (*), percent signs (%), hyphens (-) and
         * underscores (_) and must comply with URI specifications.
         * + The address can contain environment variables, each starting with a letter and consisting of 3 to 32 characters.
         * Only letters, digits, hyphens (-), and underscores (_) are allowed in environment variables.
         */
        path: string;
        /**
         * Specifies the backend request method of the API. The valid types are **GET**,
         * **POST**, **PUT**, **DELETE**, **HEAD**, **PATCH**, **OPTIONS** and **ANY**.
         */
        requestMethod: string;
        /**
         * Specifies the backend request protocol. The valid values are **HTTP** and
         * **HTTPS**, default to **HTTPS**.
         */
        requestProtocol?: string;
        /**
         * Specifies the timeout, in ms, which allowed for APIG to request the backend service. The
         * valid value is range from 1 to 600,000, default to 5,000.
         */
        timeout?: number;
        /**
         * Specifies the VPC channel ID. This parameter and `backendAddress` are
         * alternative.
         */
        vpcChannelId?: string;
    }

    export interface ApiWebPolicyBackendParam {
        /**
         * Specifies the description of the constant or system parameter, which contain a
         * maximum of 255 characters, and the angle brackets (< and >) are not allowed.
         */
        description?: string;
        /**
         * Specifies the location of the backend parameter. The valid values are **PATH**,
         * **QUERY** and **HEADER**.
         */
        location: string;
        /**
         * Specifies the backend policy name, which can contains of 3 to 64 characters and start with
         * a letter. Only letters, digits, and underscores (_) are allowed.
         */
        name: string;
        /**
         * Specifies the condition type of the backend policy. The valid values are **Equal**,
         * **Enumerated** and **Matching**, default to **Equal**.
         */
        type: string;
        /**
         * Specifies the condition type. For a condition with the input parameter source:
         * + If the condition type is **Enumerated**, separate condition values with commas.
         * + If the condition type is **Matching**, enter a regular expression compatible with PERL.
         */
        value: string;
    }

    export interface ApiWebPolicyCondition {
        /**
         * Specifies the request parameter name. This parameter is required if the policy type
         * is param.
         */
        paramName?: string;
        /**
         * Specifies the policy type. The valid values are **param** and **source**, default to
         * **source**.
         */
        source?: string;
        /**
         * Specifies the condition type of the backend policy. The valid values are **Equal**,
         * **Enumerated** and **Matching**, default to **Equal**.
         */
        type?: string;
        /**
         * Specifies the condition type. For a condition with the input parameter source:
         * + If the condition type is **Enumerated**, separate condition values with commas.
         * + If the condition type is **Matching**, enter a regular expression compatible with PERL.
         */
        value: string;
    }

    export interface CustomAuthorizerIdentity {
        /**
         * Specifies the parameter location, which support 'HEADER' and 'QUERY'.
         * Changing this will create a new custom authorizer resource.
         */
        location: string;
        /**
         * Specifies the name of the parameter to be verified.
         * The parameter includes front-end and back-end parameters.
         * Changing this will create a new custom authorizer resource.
         */
        name: string;
        /**
         * Specifies the parameter verification expression.
         * If omitted, the custom authorizer will not perform verification.
         * The valid value is range form 1 to 2,048.
         * Changing this will create a new custom authorizer resource.
         */
        validation?: string;
    }

    export interface GetEnvironmentsEnvironment {
        /**
         * Time when the APIG environment was created, in RFC-3339 format.
         */
        createTime: string;
        /**
         * The description about the API environment.
         */
        description: string;
        /**
         * ID of the APIG environment.
         */
        id: string;
        /**
         * Specifies the name of the API environment. The API environment name consists of 3 to 64
         * characters, starting with a letter. Only letters, digits and underscores (_) are allowed.
         */
        name: string;
    }

    export interface GroupEnvironment {
        /**
         * Specifies the APIG environment ID of the associated APIG group.
         */
        environmentId: string;
        /**
         * Specifies an array of one or more APIG environment variables. The object structure is
         * documented below. The environment variables of different groups are isolated in the same environment.
         */
        variables: outputs.DedicatedApig.GroupEnvironmentVariable[];
    }

    export interface GroupEnvironmentVariable {
        /**
         * Specifies the variable name, which can contains of 3 to 32 characters, starting with a
         * letter. Only letters, digits, hyphens (-), and underscores (_) are allowed. In the definition of an API, `name` (
         * case-sensitive) indicates a variable, such as #Name#. It is replaced by the actual value when the API is published in
         * an environment. The variable names are not allowed to be repeated for an API group.
         */
        name: string;
        /**
         * Specifies the environment ariable value, which can contains of 1 to 255 characters. Only
         * letters, digits and special characters (_-/.:) are allowed.
         */
        value: string;
        variableId: string;
    }

    export interface ResponseRule {
        /**
         * Specifies the body template of the API response rule, e.g.
         * `{\"code\":\"$context.authorizer.frontend.code\",\"message\":\"$context.authorizer.frontend.message\"}`
         */
        body: string;
        /**
         * Specifies the type of the API custom response rule.
         * + **AUTH_FAILURE**: Authentication failed.
         * + **AUTH_HEADER_MISSING**: The identity source is missing.
         * + **AUTHORIZER_FAILURE**: Custom authentication failed.
         * + **AUTHORIZER_CONF_FAILURE**: There has been a custom authorizer error.
         * + **AUTHORIZER_IDENTITIES_FAILURE**: The identity source of the custom authorizer is invalid.
         * + **BACKEND_UNAVAILABLE**: The backend service is unavailable.
         * + **BACKEND_TIMEOUT**: Communication with the backend service timed out.
         * + **THROTTLED**: The request was rejected due to request throttling.
         * + **UNAUTHORIZED**: The app you are using has not been authorized to call the API.
         * + **ACCESS_DENIED**: Access denied.
         * + **NOT_FOUND**: No API is found.
         * + **REQUEST_PARAMETERS_FAILURE**: The request parameters are incorrect.
         * + **DEFAULT_4XX**: Another 4XX error occurred.
         * + **DEFAULT_5XX**: Another 5XX error occurred.
         */
        errorType: string;
        /**
         * Specifies the HTTP status code of the API response rule.
         */
        statusCode?: number;
    }

    export interface ThrottlingPolicyAppThrottle {
        /**
         * ID of the special application throttling policy.
         */
        id: string;
        /**
         * Specifies the maximum number of times an API can be accessed within a specified
         * period.
         */
        maxApiRequests: number;
        /**
         * Specifies the object ID which the special throttling policy belongs.
         */
        throttlingObjectId: string;
        /**
         * The object name which the special application throttling policy belongs.
         */
        throttlingObjectName: string;
    }

    export interface ThrottlingPolicyUserThrottle {
        /**
         * ID of the special application throttling policy.
         */
        id: string;
        /**
         * Specifies the maximum number of times an API can be accessed within a specified
         * period.
         */
        maxApiRequests: number;
        /**
         * Specifies the object ID which the special throttling policy belongs.
         */
        throttlingObjectId: string;
        /**
         * The object name which the special application throttling policy belongs.
         */
        throttlingObjectName: string;
    }

    export interface VpcChannelMember {
        /**
         * Specifies the ECS ID for each backend servers.
         * Required if `memberType` is *ECS*.
         * This parameter and `ipAddress` are alternative.
         */
        id?: string;
        /**
         * Specifies the IP address each backend servers.
         * Required if `memberType` is *EIP*.
         */
        ipAddress?: string;
        /**
         * Specifies the backend server weight.
         * The valid values are range from 1 to 100, default to 1.
         */
        weight?: number;
    }

}

export namespace DedicatedElb {
    export interface GetFlavorsFlavor {
        /**
         * Specifies the bandwidth size(Mbit/s) in the flavor.
         */
        bandwidth: number;
        /**
         * Specifies the cps in the flavor.
         */
        cps: number;
        /**
         * ID of the flavor.
         */
        id: string;
        /**
         * Specifies the maximum connections in the flavor.
         */
        maxConnections: number;
        /**
         * Name of the flavor.
         */
        name: string;
        /**
         * Specifies the qps in the L7 flavor.
         */
        qps: number;
        /**
         * Specifies the flavor type. Valid values are L4 and L7.
         */
        type: string;
    }

    export interface GetPoolsPool {
        /**
         * Specifies the description of the ELB pool.
         */
        description: string;
        /**
         * Specifies the health monitor ID of the ELB pool.
         */
        healthmonitorId: string;
        /**
         * The listener, loadbalancer or member ID.
         */
        id: string;
        /**
         * The IP version of the LB pool.
         */
        ipVersion: string;
        /**
         * Specifies the method of the ELB pool. Must be one of ROUND_ROBIN, LEAST_CONNECTIONS,
         * or SOURCE_IP.
         */
        lbMethod: string;
        /**
         * The listener list. The object structure is documented below.
         */
        listeners: outputs.DedicatedElb.GetPoolsPoolListener[];
        /**
         * The loadbalancer list. The object structure is documented below.
         */
        loadbalancers: outputs.DedicatedElb.GetPoolsPoolLoadbalancer[];
        /**
         * The member list. The object structure is documented below.
         */
        members: outputs.DedicatedElb.GetPoolsPoolMember[];
        /**
         * Specifies the name of the ELB pool.
         */
        name: string;
        /**
         * Indicates whether connections in the same session will be processed by the same pool member or not.
         * The object structure is documented below.
         */
        persistences: outputs.DedicatedElb.GetPoolsPoolPersistence[];
        /**
         * Specifies the protocol of the ELB pool. This can either be TCP, UDP or HTTP.
         */
        protocol: string;
    }

    export interface GetPoolsPoolListener {
        /**
         * The listener, loadbalancer or member ID.
         */
        id: string;
    }

    export interface GetPoolsPoolLoadbalancer {
        /**
         * The listener, loadbalancer or member ID.
         */
        id: string;
    }

    export interface GetPoolsPoolMember {
        /**
         * The listener, loadbalancer or member ID.
         */
        id: string;
    }

    export interface GetPoolsPoolPersistence {
        /**
         * The name of the cookie if persistence mode is set appropriately.
         */
        cookieName: string;
        /**
         * The type of persistence mode.
         */
        type: string;
    }

    export interface IpgroupIpList {
        /**
         * Human-readable description for the ip.
         */
        description?: string;
        /**
         * IP address or CIDR block.
         */
        ip: string;
    }

    export interface PoolPersistence {
        /**
         * The name of the cookie if persistence mode is set appropriately. Required
         * if `type = APP_COOKIE`.
         */
        cookieName?: string;
        /**
         * The type of persistence mode. The current specification supports SOURCE_IP,
         * HTTP_COOKIE, and APP_COOKIE.
         */
        type: string;
    }
}

export namespace Dew {
    export interface GetKeypairsKeypair {
        /**
         * Specifies the fingerprint of the keypair.
         */
        fingerprint: string;
        /**
         * Specifies whether the private key is managed by HuaweiCloud.
         */
        isManaged: boolean;
        /**
         * Specifies the name of the keypair.
         */
        name: string;
        /**
         * Specifies the imported OpenSSH-formatted public key.
         */
        publicKey: string;
        /**
         * Indicates the scope of key pair. The value can be **account**or **user**.
         */
        scope: string;
    }

}

export namespace Dis {
    export interface StreamPartition {
        /**
         * Possible value range of the hash key used by each partition.
         */
        hashRange: string;
        /**
         * The ID of the partition.
         */
        id: string;
        /**
         * Sequence number range of each partition.
         */
        sequenceNumberRange: string;
        /**
         * The status of the partition.
         */
        status: string;
    }

}

export namespace Dli {
    export interface SparkJobDependentPackage {
        groupName: string;
        packages: outputs.Dli.SparkJobDependentPackagePackage[];
    }

    export interface SparkJobDependentPackagePackage {
        /**
         * Specifies the resource name of the package.
         * Changing this parameter will submit a new spark job.
         */
        packageName: string;
        /**
         * Specifies the resource type of the package.
         * Changing this parameter will submit a new spark job.
         */
        type: string;
    }

    export interface SqlJobConf {
        /**
         * Sets the job running timeout interval. If the timeout interval
         * expires, the job is canceled. Unit: `ms`. Changing this parameter will create a new resource.
         */
        dliSqlJobTimeout?: number;
        /**
         * Specifies whether DDL and DCL statements are executed
         * asynchronously. The value true indicates that asynchronous execution is enabled. Default value is `false`.
         * Changing this parameter will create a new resource.
         */
        dliSqlSqlasyncEnabled?: boolean;
        /**
         * Maximum size of the table that
         * displays all working nodes when a connection is executed. You can set this parameter to -1 to disable the display.
         * Default value is `209715200`. Changing this parameter will create a new resource.
         */
        sparkSqlAutoBroadcastJoinThreshold?: number;
        /**
         * Path of bad records. Changing this parameter will create
         * a new resource.
         */
        sparkSqlBadRecordsPath?: string;
        /**
         * In dynamic mode, Spark does not delete
         * the previous partitions and only overwrites the partitions without data during execution. Default value is `false`.
         * Changing this parameter will create a new resource.
         */
        sparkSqlDynamicPartitionOverwriteEnabled?: boolean;
        /**
         * Maximum number of bytes to be packed into a
         * single partition when a file is read. Default value is `134217728`. Changing this parameter will create a new
         * resource.
         */
        sparkSqlFilesMaxPartitionBytes?: number;
        /**
         * Maximum number of records to be written
         * into a single file. If the value is zero or negative, there is no limit. Default value is `0`.
         * Changing this parameter will create a new resource.
         */
        sparkSqlMaxRecordsPerFile?: number;
        /**
         * Default number of partitions used to filter
         * data for join or aggregation. Default value is `4096`. Changing this parameter will create a new resource.
         */
        sparkSqlShufflePartitions?: number;
    }

    export interface TableColumn {
        /**
         * Specifies the description of column. Changing this parameter will
         * create a new resource.
         */
        description?: string;
        /**
         * Specifies whether the column is a partition column. The value
         * `true` indicates a partition column, and the value false indicates a non-partition column. The default value
         * is false. Changing this parameter will create a new resource.
         */
        isPartition?: boolean;
        /**
         * Specifies the name of column. Changing this parameter will create a new
         * resource.
         */
        name: string;
        /**
         * Specifies data type of column. Changing this parameter will create a new
         * resource.
         */
        type: string;
    }

}

export namespace Dms {
    export interface GetFlavorsFlavor {
        /**
         * The list of supported CPU architectures.
         */
        archTypes: string[];
        /**
         * The list of supported billing modes.
         */
        chargingModes: string[];
        /**
         * The flavor ID.
         */
        id: string;
        /**
         * The list of supported disk IO types.
         * The object structure is documented below.
         */
        ios: outputs.Dms.GetFlavorsFlavorIo[];
        /**
         * The function property details.
         * The object structure is documented below.
         */
        properties: outputs.Dms.GetFlavorsFlavorProperty[];
        /**
         * The list of features supported by the current specification.
         * The object structure is documented below.
         */
        supportFeatures: outputs.Dms.GetFlavorsFlavorSupportFeature[];
        /**
         * Specifies flavor type. The valid values are **single** and **cluster**.
         */
        type: string;
        /**
         * The underlying VM specification.
         */
        vmSpecification: string;
    }

    export interface GetFlavorsFlavorIo {
        /**
         * Specifies the list of availability zones with available resources.
         */
        availabilityZones: string[];
        /**
         * Specifies the disk IO encoding.
         * + **dms.physical.storage.high.v2**: Type of the disk that uses high I/O.
         * + **dms.physical.storage.ultra.v2**: Type of the disk that uses ultra-high I/O.
         */
        storageSpecCode: string;
        /**
         * Specifies flavor type. The valid values are **single** and **cluster**.
         */
        type: string;
        /**
         * The list of unavailability zones with available resources.
         */
        unavailabilityZones: string[];
    }

    export interface GetFlavorsFlavorProperty {
        /**
         * The flavor ID alias.
         */
        flavorAlias: string;
        /**
         * The maximum bandwidth per broker.
         */
        maxBandwidthPerBroker: number;
        /**
         * The maximum number of brokers.
         */
        maxBroker: number;
        /**
         * The maximum number of consumers per broker.
         */
        maxConsumerPerBroker: number;
        /**
         * The maximum number of partitions per broker.
         */
        maxPartitionPerBroker: number;
        /**
         * The maximum storage per node. The unit is GB.
         */
        maxStoragePerNode: number;
        /**
         * The maximum TPS per broker.
         */
        maxTpsPerBroker: number;
        /**
         * The minimum number of brokers.
         */
        minBroker: number;
        /**
         * The minimum storage per node. The unit is GB.
         */
        minStoragePerNode: number;
    }

    export interface GetFlavorsFlavorSupportFeature {
        /**
         * The function name, e.g. **connector_obs**.
         */
        name: string;
        /**
         * The function property details.
         * The object structure is documented below.
         */
        properties: outputs.Dms.GetFlavorsFlavorSupportFeatureProperty[];
    }

    export interface GetFlavorsFlavorSupportFeatureProperty {
        /**
         * The maximum number of nodes for the dump function.
         */
        maxNode: number;
        /**
         * The maximum number of tasks for the dump function.
         */
        maxTask: number;
        /**
         * The minimum number of nodes for the dump function.
         */
        minNode: number;
        /**
         * The minimum number of tasks for the dump function.
         */
        minTask: number;
    }

    export interface GetInstancesInstance {
        /**
         * The access username.
         */
        accessUser: string;
        /**
         * The list of AZ names.
         */
        availabilityZones: string[];
        /**
         * The IP address for instance connection.
         */
        connectAddress: string;
        /**
         * Indicates the Access information of cross-VPC. The structure is documented below.
         */
        crossVpcAccesses: outputs.Dms.GetInstancesInstanceCrossVpcAccess[];
        /**
         * The instance description.
         */
        description: string;
        /**
         * Whether to dumping is enabled.
         */
        dumping: boolean;
        /**
         * Whether to enable automatic topic creation.
         */
        enableAutoTopic: boolean;
        /**
         * Whether public access to the instance is enabled.
         */
        enablePublicIp: boolean;
        /**
         * The kafka engine version.
         */
        engineVersion: string;
        /**
         * Specifies the enterprise project ID to which all instances of the list
         * belong.
         */
        enterpriseProjectId: string;
        /**
         * The instance ID.
         */
        id: string;
        /**
         * The time at which a maintenance time window starts, the format is `HH:mm`.
         */
        maintainBegin: string;
        /**
         * The time at which a maintenance time window ends, the format is `HH:mm`.
         */
        maintainEnd: string;
        /**
         * The username for logging in to the Kafka Manager.
         */
        managerUser: string;
        /**
         * The connection address of the Kafka manager of an instance.
         */
        manegementConnectAddress: string;
        /**
         * Specifies the kafka instance name for data-source queries.
         */
        name: string;
        /**
         * The subnet ID to which the instance belongs.
         */
        networkId: string;
        /**
         * The maximum number of topics in the DMS kafka instance.
         */
        partitionNum: number;
        /**
         * The port number.
         */
        port: number;
        /**
         * The product ID used by the instance.
         */
        productId: string;
        /**
         * The instance public access address.
         * The format of each connection address is `{IP address}:{port}`.
         */
        publicConnAddresses: string;
        /**
         * The IDs of the elastic IP address (EIP).
         */
        publicIpIds: string[];
        /**
         * The resource specifications identifier.
         */
        resourceSpecCode: string;
        retentionPolicy: string;
        /**
         * The security group ID associated with the instance.
         */
        securityGroupId: string;
        /**
         * Whether the Kafka SASL_SSL is enabled.
         */
        sslEnable: boolean;
        /**
         * Specifies the kafka instance status for data-source queries.
         */
        status: string;
        /**
         * The message storage capacity, in GB unit.
         */
        storageSpace: number;
        /**
         * The storage I/O specification.
         */
        storageSpecCode: string;
        /**
         * The key/value pairs to associate with the instance.
         */
        tags: {[key: string]: string};
        /**
         * The instance type.
         */
        type: string;
        /**
         * The used message storage space, in GB unit.
         */
        usedStorageSpace: number;
        /**
         * The user ID who created the instance.
         */
        userId: string;
        /**
         * The username who created the instance.
         */
        userName: string;
        /**
         * The VPC ID to which the instance belongs.
         */
        vpcId: string;
    }

    export interface GetInstancesInstanceCrossVpcAccess {
        /**
         * The advertised IP Address.
         */
        advertisedIp: string;
        /**
         * The listener IP address.
         */
        lisenterIp: string;
        /**
         * The port number.
         */
        port: number;
        /**
         * The port ID associated with the address.
         */
        portId: string;
    }

    export interface KafkaInstanceCrossVpcAccess {
        /**
         * -(Optional, String) The advertised IP Address or domain name.
         */
        advertisedIp: string;
        /**
         * The listener IP address.
         */
        lisenterIp: string;
        /**
         * The port number.
         */
        port: number;
        /**
         * The port ID associated with the address.
         */
        portId: string;
    }

    export interface KafkaPermissionsPolicy {
        /**
         * -(Required, String) Specifies the permissions type. The value can be:
         * + **all**: publish and subscribe permissions.
         * + **pub**: publish permissions.
         * + **sub**: subscribe permissions.
         */
        accessPolicy: string;
        /**
         * -(Required, String) Specifies the user name.
         */
        userName: string;
    }

}

export namespace Dns {
    export interface ZoneRouter {
        /**
         * ID of the associated VPC.
         */
        routerId: string;
        /**
         * The region of the VPC.
         */
        routerRegion?: string;
    }

}

export namespace Drs {
    export interface JobDestinationDb {
        /**
         * Specifies the engine type of database. Changing this parameter will
         * create a new resource. The options are as follows: `mysql`, `mongodb`, `gaussdbv5`.
         */
        engineType: string;
        /**
         * Specifies the instance id of database when it is a RDS database.
         * Changing this parameter will create a new resource.
         */
        instanceId?: string;
        /**
         * Specifies the IP of database. Changing this parameter will create a new resource.
         */
        ip: string;
        /**
         * Specifies the job name. The name consists of 4 to 50 characters, starting with
         * a letter. Only letters, digits, underscores (\_) and hyphens (-) are allowed.
         */
        name: string;
        /**
         * Specifies the password of database.
         * Changing this parameter will create a new resource.
         */
        password: string;
        /**
         * Specifies the port of database. Changing this parameter will create a new resource.
         */
        port: number;
        /**
         * Specifies the region which the database belongs when it is a RDS database.
         * Changing this parameter will create a new resource.
         */
        region: string;
        /**
         * Specifies the checksum of SSL certificate content.
         * It is mandatory when `sslEnabled` is `true`. Changing this parameter will create a new resource.
         */
        sslCertCheckSum?: string;
        /**
         * Specifies the SSL certificate content, encrypted with base64.
         * It is mandatory when `sslEnabled` is `true`. Changing this parameter will create a new resource.
         */
        sslCertKey?: string;
        /**
         * Specifies SSL certificate name.
         * It is mandatory when `sslEnabled` is `true`. Changing this parameter will create a new resource.
         */
        sslCertName?: string;
        /**
         * Specifies SSL certificate password. It is mandatory when
         * `sslEnabled` is `true` and the certificate file suffix is `.p12`. Changing this parameter will create a new resource.
         */
        sslCertPassword?: string;
        /**
         * Specifies whether to enable SSL connection.
         * Changing this parameter will create a new resource.
         */
        sslEnabled?: boolean;
        /**
         * Specifies subnet ID of database when it is a RDS database.
         * It is mandatory when `direction` is `down`. Changing this parameter will create a new resource.
         */
        subnetId?: string;
        /**
         * Specifies the user name of database.
         * Changing this parameter will create a new resource.
         */
        user: string;
    }

    export interface JobLimitSpeed {
        /**
         * Specifies the time to end speed limit, this time is UTC time. The input must
         * end at 59 minutes, the format is `hh:mm`, for example: 15:59. Changing this parameter will create a new resource.
         */
        endTime: string;
        /**
         * Specifies the transmission speed, the value range is 1 to 9999, unit: `MB/s`.
         * Changing this parameter will create a new resource.
         */
        speed: string;
        /**
         * Specifies the time to start speed limit, this time is UTC time. The start
         * time is the whole hour, if there is a minute, it will be ignored, the format is `hh:mm`, and the hour number
         * is two digits, for example: 01:00. Changing this parameter will create a new resource.
         */
        startTime: string;
    }

    export interface JobSourceDb {
        /**
         * Specifies the engine type of database. Changing this parameter will
         * create a new resource. The options are as follows: `mysql`, `mongodb`, `gaussdbv5`.
         */
        engineType: string;
        /**
         * Specifies the instance id of database when it is a RDS database.
         * Changing this parameter will create a new resource.
         */
        instanceId?: string;
        /**
         * Specifies the IP of database. Changing this parameter will create a new resource.
         */
        ip: string;
        /**
         * Specifies the job name. The name consists of 4 to 50 characters, starting with
         * a letter. Only letters, digits, underscores (\_) and hyphens (-) are allowed.
         */
        name: string;
        /**
         * Specifies the password of database.
         * Changing this parameter will create a new resource.
         */
        password: string;
        /**
         * Specifies the port of database. Changing this parameter will create a new resource.
         */
        port: number;
        /**
         * Specifies the region which the database belongs when it is a RDS database.
         * Changing this parameter will create a new resource.
         */
        region: string;
        /**
         * Specifies the checksum of SSL certificate content.
         * It is mandatory when `sslEnabled` is `true`. Changing this parameter will create a new resource.
         */
        sslCertCheckSum?: string;
        /**
         * Specifies the SSL certificate content, encrypted with base64.
         * It is mandatory when `sslEnabled` is `true`. Changing this parameter will create a new resource.
         */
        sslCertKey?: string;
        /**
         * Specifies SSL certificate name.
         * It is mandatory when `sslEnabled` is `true`. Changing this parameter will create a new resource.
         */
        sslCertName?: string;
        /**
         * Specifies SSL certificate password. It is mandatory when
         * `sslEnabled` is `true` and the certificate file suffix is `.p12`. Changing this parameter will create a new resource.
         */
        sslCertPassword?: string;
        /**
         * Specifies whether to enable SSL connection.
         * Changing this parameter will create a new resource.
         */
        sslEnabled?: boolean;
        /**
         * Specifies subnet ID of database when it is a RDS database.
         * It is mandatory when `direction` is `down`. Changing this parameter will create a new resource.
         */
        subnetId?: string;
        /**
         * Specifies the user name of database.
         * Changing this parameter will create a new resource.
         */
        user: string;
    }

}

export namespace Dws {
    export interface ClusterEndpoint {
        /**
         * (Optional, String) Private network connection information.
         */
        connectInfo: string;
        /**
         * (Optional, String)
         * JDBC URL. The following is the default format:
         * jdbc:postgresql://< public_connect_info>/<YOUR_DATABASE_NAME>
         */
        jdbcUrl: string;
    }

    export interface ClusterPublicEndpoint {
        /**
         * (Optional, String)
         * JDBC URL. The following is the default format:
         * jdbc:postgresql://< public_connect_info>/<YOUR_DATABASE_NAME>
         */
        jdbcUrl: string;
        /**
         * (Optional, String)
         * Public network connection information.
         */
        publicConnectInfo: string;
    }

    export interface ClusterPublicIp {
        /**
         * EIP ID.
         */
        eipId: string;
        /**
         * Binding type of an EIP. The value can be either of the following:
         * autoAssign not_use bindExisting The default value is not_use.
         */
        publicBindType: string;
    }

    export interface GetFlaovrsFlavor {
        /**
         * Specifies the availability zone name.
         */
        availabilityZone: string;
        /**
         * The name of the dws node flavor. It is referenced by `nodeType` in `huaweicloud.Dws.getFlaovrs`.
         */
        flavorId: string;
        /**
         * Specifies the ram of the dws node flavor in GB.
         */
        memory: number;
        /**
         * Indicates the Disk size in GB.
         */
        size: number;
        /**
         * Specifies the vcpus of the dws node flavor.
         */
        vcpus: number;
        /**
         * Indicates Disk type.
         * + **LOCAL_DISK**: common I/O disk
         * + **SSD**: ultra-high I/O disk
         */
        volumetype: string;
    }

}

export namespace Ecs {
    export interface GetInstanceNetwork {
        /**
         * Specifies the IPv4 addresses of the ECS.
         */
        fixedIpV4: string;
        /**
         * The Fixed IPv6 address of the instance on that network.
         */
        fixedIpV6: string;
        /**
         * The MAC address of the NIC on that network.
         */
        mac: string;
        /**
         * The port ID corresponding to the IP address on that network.
         */
        port: string;
        /**
         * The network UUID to attach to the server.
         */
        uuid: string;
    }

    export interface GetInstanceSchedulerHint {
        /**
         * The UUID of a Server Group where the instance will be placed into.
         */
        group: string;
    }

    export interface GetInstanceVolumeAttached {
        /**
         * The volume boot index on that attachment.
         */
        bootIndex: number;
        /**
         * The volume pci address on that attachment.
         */
        pciAddress: string;
        /**
         * The volume size on that attachment.
         */
        size: number;
        /**
         * The volume type on that attachment.
         */
        type: string;
        /**
         * The volume id on that attachment.
         */
        volumeId: string;
    }

    export interface GetInstancesInstance {
        /**
         * Specifies the availability zone where the instance is located.
         * Please following [reference](https://developer.huaweicloud.com/intl/en-us/endpoint?ECS) for this argument.
         */
        availabilityZone: string;
        /**
         * Specifies the enterprise project ID.
         */
        enterpriseProjectId: string;
        /**
         * Specifies the flavor ID.
         */
        flavorId: string;
        /**
         * Specifies the flavor name of the instance.
         */
        flavorName: string;
        /**
         * The instance ID in UUID format.
         */
        id: string;
        /**
         * Specifies the image ID of the instance.
         */
        imageId: string;
        /**
         * Specifies the key pair that is used to authenticate the instance.
         */
        keyPair: string;
        /**
         * Specifies the instance name, which can be queried with a regular expression.
         * The instance name supports fuzzy matching query too.
         */
        name: string;
        /**
         * The scheduler with hints on how the instance should be launched.
         * The object structure is documented below.
         */
        schedulerHints?: outputs.Ecs.GetInstancesInstanceSchedulerHint[];
        /**
         * An array of one or more security group IDs to associate with the instance.
         */
        securityGroupIds: string[];
        /**
         * Specifies the status of the instance. The valid values are as follows:
         * + **ACTIVE**: The instance is running properly.
         * + **SHUTOFF**: The instance has been properly stopped.
         * + **ERROR**: An error has occurred on the instance.
         */
        status: string;
        /**
         * The key/value pairs to associate with the instance.
         */
        tags: {[key: string]: string};
        /**
         * The user data (information after encoding) configured during instance creation.
         */
        userData: string;
        /**
         * An array of one or more disks to attach to the instance. The object structure is documented below.
         */
        volumeAttacheds: outputs.Ecs.GetInstancesInstanceVolumeAttached[];
    }

    export interface GetInstancesInstanceSchedulerHint {
        /**
         * The UUID of a server group where the instance will be placed into.
         */
        group: string;
    }

    export interface GetInstancesInstanceVolumeAttached {
        /**
         * Whether the volume is the system disk.
         */
        isSysVolume: boolean;
        /**
         * The volume id on that attachment.
         */
        volumeId: string;
    }

    export interface InstanceBandwidth {
        /**
         * Specifies the bandwidth billing mode. The value can be *traffic* or *bandwidth*.
         * Changing this creates a new instance.
         */
        chargeMode?: string;
        /**
         * Specifies the **shared** bandwidth id. This parameter is mandatory when
         * `shareType` is set to **WHOLE**. Changing this creates a new instance.
         */
        id?: string;
        /**
         * Specifies the bandwidth sharing type. Changing this creates a new instance.
         * Possible values are as follows:
         * + **PER**: Dedicated bandwidth
         * + **WHOLE**: Shared bandwidth
         */
        shareType: string;
        /**
         * Specifies the bandwidth size. The value ranges from 1 to 300 Mbit/s.
         * This parameter is mandatory when `shareType` is set to **PER**. Changing this creates a new instance.
         */
        size?: number;
    }

    export interface InstanceBlockDevice {
        bootIndex?: number;
        deleteOnTermination?: boolean;
        destinationType?: string;
        guestFormat?: string;
        sourceType: string;
        /**
         * Specifies the network UUID to attach to the instance.
         * Changing this creates a new instance.
         */
        uuid?: string;
        volumeSize?: number;
    }

    export interface InstanceDataDisk {
        /**
         * Specifies the bandwidth size. The value ranges from 1 to 300 Mbit/s.
         * This parameter is mandatory when `shareType` is set to **PER**. Changing this creates a new instance.
         */
        size: number;
        snapshotId?: string;
        /**
         * Specifies the ECS data disk type, which must be one of available disk types,
         * contains of *SSD*, *GPSSD* and *SAS*. Changing this creates a new instance.
         */
        type: string;
    }

    export interface InstanceNetwork {
        /**
         * Specifies if this network should be used for provisioning access.
         * Accepts true or false. Defaults to false.
         */
        accessNetwork?: boolean;
        /**
         * Specifies a fixed IPv4 address to be used on this network.
         * Changing this creates a new instance.
         */
        fixedIpV4: string;
        fixedIpV6: string;
        /**
         * Specifies whether the IPv6 function is enabled for the nic.
         * Defaults to false. Changing this creates a new instance.
         */
        ipv6Enable?: boolean;
        mac: string;
        port: string;
        /**
         * Specifies whether the ECS processes only traffic that is destined specifically
         * for it. This function is enabled by default but should be disabled if the ECS functions as a SNAT server or has a
         * virtual IP address bound to it.
         */
        sourceDestCheck?: boolean;
        /**
         * Specifies the network UUID to attach to the instance.
         * Changing this creates a new instance.
         */
        uuid: string;
    }

    export interface InstanceSchedulerHint {
        /**
         * Specifies the ID of DeH.
         * This parameter takes effect only when the value of tenancy is dedicated. Changing this creates a new instance.
         */
        dehId?: string;
        faultDomain?: string;
        /**
         * Specifies a UUID of a Server Group.
         * The instance will be placed into that group. Changing this creates a new instance.
         */
        group: string;
        /**
         * Specifies the tenancy specifies whether the ECS is to be created on a
         * Dedicated Host
         * (DeH) or in a shared pool. Changing this creates a new instance.
         */
        tenancy?: string;
    }

    export interface InstanceVolumeAttached {
        bootIndex: number;
        pciAddress: string;
        /**
         * Specifies the bandwidth size. The value ranges from 1 to 300 Mbit/s.
         * This parameter is mandatory when `shareType` is set to **PER**. Changing this creates a new instance.
         */
        size: number;
        /**
         * Specifies the ECS data disk type, which must be one of available disk types,
         * contains of *SSD*, *GPSSD* and *SAS*. Changing this creates a new instance.
         */
        type: string;
        volumeId: string;
    }
}

export namespace Eip {
    export interface GetBandwidthPublicip {
        /**
         * The ID of the EIP or IPv6 port that uses the bandwidth.
         */
        id: string;
        /**
         * The IPv4 or IPv6 address.
         */
        ipAddress: string;
        /**
         * The IP version, either 4 or 6.
         */
        ipVersion: number;
        /**
         * The EIP type. Possible values are *5_bgp* (dynamic BGP) and *5_sbgp* (static BGP).
         */
        type: string;
    }

    export interface GetEipsEip {
        /**
         * The bandwidth id of the EIP.
         */
        bandwidthId: string;
        /**
         * The bandwidth name of the EIP.
         */
        bandwidthName: string;
        /**
         * The bandwidth share type of the EIP.
         */
        bandwidthShareType: string;
        /**
         * The bandwidth size of the EIP.
         */
        bandwidthSize: number;
        /**
         * Specifies the enterprise project ID which the desired EIP belongs to.
         */
        enterpriseProjectId: string;
        /**
         * The ID of the EIP.
         */
        id: string;
        /**
         * Specifies ip version of the desired EIP. The options are:
         * + `4`: IPv4.
         * + `6`: IPv6.
         */
        ipVersion: number;
        /**
         * The name of the EIP.
         */
        name: string;
        /**
         * The port id bound to the EIP.
         */
        portId: string;
        /**
         * The private ip address of the EIP.
         */
        privateIp: string;
        /**
         * The public ip address of the EIP.
         */
        publicIp: string;
        /**
         * The public ipv6 address of the EIP.
         */
        publicIpv6: string;
        /**
         * The status of the EIP.
         */
        status: string;
        /**
         * Specifies the included key/value pairs which associated with the desired EIP.
         */
        tags: {[key: string]: string};
        /**
         * The type of the EIP.
         */
        type: string;
    }

}

export namespace Elb {
    export interface GetListenersListener {
        /**
         * The maximum number of connections allowed for the listener.
         */
        connectionLimit: number;
        /**
         * The ID of the default pool with which the ELB listener is associated.
         */
        defaultPoolId: string;
        /**
         * The ID of the server certificate used by the listener.
         */
        defaultTlsContainerRef: string;
        /**
         * The description of the ELB listener.
         */
        description: string;
        /**
         * Whether the ELB listener uses HTTP/2.
         */
        http2Enable: boolean;
        /**
         * The ELB loadbalancer ID.
         */
        id: string;
        /**
         * Listener list.
         * The object structure is documented below.
         */
        loadbalancers: outputs.Elb.GetListenersListenerLoadbalancer[];
        /**
         * The listener name.
         */
        name: string;
        /**
         * The listener protocol.  
         * The valid values are **TCP**, **UDP**, **HTTP** and **TERMINATED_HTTPS**.
         */
        protocol: string;
        /**
         * The front-end listening port of the listener.  
         * The valid value is range from `1` to `65535`.
         */
        protocolPort: number;
        /**
         * List of the SNI certificate (server certificates with a domain name) IDs used by the listener.
         */
        sniContainerRefs: string[];
    }

    export interface GetListenersListenerLoadbalancer {
        /**
         * The ELB loadbalancer ID.
         */
        id: string;
    }

    export interface GetPoolsPool {
        /**
         * Specifies the description of the ELB pool.
         */
        description: string;
        /**
         * Specifies the health monitor ID of the ELB pool.
         */
        healthmonitorId: string;
        /**
         * The listener, loadbalancer or member ID.
         */
        id: string;
        /**
         * Specifies the method of the ELB pool. Must be one of ROUND_ROBIN, LEAST_CONNECTIONS,
         * or SOURCE_IP.
         */
        lbMethod: string;
        /**
         * The listener list. The object structure is documented below.
         */
        listeners: outputs.Elb.GetPoolsPoolListener[];
        /**
         * The loadbalancer list. The object structure is documented below.
         */
        loadbalancers: outputs.Elb.GetPoolsPoolLoadbalancer[];
        /**
         * The member list. The object structure is documented below.
         */
        members: outputs.Elb.GetPoolsPoolMember[];
        /**
         * Specifies the name of the ELB pool.
         */
        name: string;
        /**
         * Indicates whether connections in the same session will be processed by the same pool member or not.
         * The object structure is documented below.
         */
        persistences: outputs.Elb.GetPoolsPoolPersistence[];
        /**
         * Specifies the protocol of the ELB pool. This can either be TCP, UDP or HTTP.
         */
        protocol: string;
    }

    export interface GetPoolsPoolListener {
        /**
         * The listener, loadbalancer or member ID.
         */
        id: string;
    }

    export interface GetPoolsPoolLoadbalancer {
        /**
         * The listener, loadbalancer or member ID.
         */
        id: string;
    }

    export interface GetPoolsPoolMember {
        /**
         * The listener, loadbalancer or member ID.
         */
        id: string;
    }

    export interface GetPoolsPoolPersistence {
        /**
         * The name of the cookie if persistence mode is set appropriately.
         */
        cookieName: string;
        /**
         * The type of persistence mode.
         */
        type: string;
    }

    export interface PoolPersistence {
        /**
         * The name of the cookie if persistence mode is set appropriately. Required
         * if `type = APP_COOKIE`.
         */
        cookieName?: string;
        /**
         * Specifies the sticky session timeout duration in minutes. This parameter is
         * invalid when type is set to APP_COOKIE. The value range varies depending on the protocol of the backend server group:
         * + When the protocol of the backend server group is TCP or UDP, the value ranges from 1 to 60.
         * + When the protocol of the backend server group is HTTP or HTTPS, the value ranges from 1 to 1440.
         */
        timeout: number;
        /**
         * The type of persistence mode. The current specification supports SOURCE_IP,
         * HTTP_COOKIE, and APP_COOKIE.
         */
        type: string;
    }
}

export namespace Evs {
    export interface GetVolumesVolume {
        /**
         * The disk attachment information. Structure is documented below.
         */
        attachments: outputs.Evs.GetVolumesVolumeAttachment[];
        /**
         * Specifies the availability zone for the disks.
         */
        availabilityZone: string;
        /**
         * Whether the disk is bootable.
         */
        bootable: boolean;
        /**
         * The time when the disk was created.
         */
        createAt: string;
        /**
         * The disk description.
         */
        description: string;
        /**
         * Specifies the enterprise project ID for filtering.
         */
        enterpriseProjectId: string;
        /**
         * The ID of the attached resource in UUID format.
         */
        id: string;
        /**
         * The disk name.
         */
        name: string;
        /**
         * The service type, such as EVS, DSS or DESS.
         */
        serviceType: string;
        /**
         * Specifies whether the disk is shareable.
         */
        shareable: boolean;
        /**
         * The disk size, in GB.
         */
        size: number;
        /**
         * Specifies the disk status. The valid values are as following:
         * + **FREEZED**
         * + **BIND_ERROR**
         * + **BINDING**
         * + **PENDING_DELETE**
         * + **PENDING_CREATE**
         * + **NOTIFYING**
         * + **NOTIFY_DELETE**
         * + **PENDING_UPDATE**
         * + **DOWN**
         * + **ACTIVE**
         * + **ELB**
         * + **ERROR**
         * + **VPN**
         */
        status: string;
        /**
         * Specifies the included key/value pairs which associated with the desired disk.
         */
        tags: {[key: string]: string};
        /**
         * The time when the disk was updated.
         */
        updateAt: string;
        /**
         * The unique identifier used when attaching the disk.
         */
        wwn: string;
    }

    export interface GetVolumesVolumeAttachment {
        /**
         * The time when the disk was attached.
         */
        attachedAt: string;
        /**
         * The ID of the attachment information.
         */
        attachedMode: string;
        /**
         * The device name to which the disk is attached.
         */
        deviceName: string;
        /**
         * The ID of the attached resource in UUID format.
         */
        id: string;
        /**
         * Specifies the server ID to which the disks are attached.
         */
        serverId: string;
    }

    export interface VolumeAttachment {
        device: string;
        /**
         * A resource ID in UUID format.
         */
        id: string;
        instanceId: string;
    }

}

export namespace FunctionGraph {
    export interface FunctionCustomImage {
        /**
         * Specifies the URL of SWR image, the URL must start with `swr.`.
         * Changing this will create a new resource.
         */
        url: string;
    }

    export interface FunctionFuncMount {
        /**
         * Specifies the function access path.
         */
        localMountPath: string;
        /**
         * Specifies the ID of the mounted resource (corresponding cloud service).
         */
        mountResource: string;
        /**
         * Specifies the remote mount path. Example: 192.168.0.12:/data.
         */
        mountSharePath: string;
        /**
         * Specifies the mount type. Options: sfs, sfsTurbo, and ecs.
         */
        mountType: string;
        status: string;
    }

    export interface GetDependenciesPackage {
        /**
         * Unique ID of the dependent package.
         */
        etag: string;
        /**
         * File name of the Dependent package.
         */
        fileName: string;
        /**
         * Dependent package ID.
         */
        id: string;
        /**
         * URL of the dependent package in the OBS console.
         */
        link: string;
        /**
         * Specifies the dependent package runtime to match.
         */
        name: string;
        /**
         * Dependent package owner.
         */
        owner: string;
        /**
         * Specifies the dependent package runtime to match. Valid values: **Java8**,
         * **Node.js6.10**, **Node.js8.10**, **Node.js10.16**, **Node.js12.13**, **Python2.7**, **Python3.6**, **Go1.8**,
         * **Go1.x**, **C#(.NET Core 2.0)**, **C#(.NET Core 2.1)**, **C#(.NET Core 3.1)** and **PHP7.3**.
         */
        runtime: string;
        /**
         * Dependent package size.
         */
        size: number;
    }

    export interface TriggerApig {
        /**
         * Specifies the API name. Changing this will create a new trigger resource.
         */
        apiName: string;
        /**
         * Specifies the API environment name.
         * Changing this will create a new trigger resource.
         */
        envName: string;
        /**
         * Specifies the ID of the APIG group to which the API belongs.
         * Changing this will create a new trigger resource.
         */
        groupId: string;
        /**
         * Specifies the ID of the APIG dedicated instance to which the API belongs.
         * Required if the `type` is `DEDICATEDGATEWAY`. Changing this will create a new trigger resource.
         */
        instanceId?: string;
        /**
         * Specifies the request protocol of the API. The valid value are
         * **HTTP** and **HTTPS**. Default to **HTTPS**. Changing this will create a new trigger resource.
         */
        requestProtocol?: string;
        /**
         * Specifies the security authentication mode. The valid values
         * are **NONE**, **APP** and **IAM**, default to **IAM**. Changing this will create a new trigger resource.
         */
        securityAuthentication?: string;
        /**
         * Specifies the timeout for request sending. The valid value is range form
         * `1` to `60,000`, default to `5,000`. Changing this will create a new trigger resource.
         */
        timeout?: number;
    }

    export interface TriggerDis {
        /**
         * Specifies the maximum volume of data that can be obtained for a single
         * request, in Byte. Only the records with a size smaller than this value can be obtained.
         * The valid value is range from `1,024` to `4,194,304`.
         * Changing this will create a new trigger resource.
         */
        maxFetchBytes: number;
        /**
         * Specifies the interval at which data is pulled from the specified stream.
         * The valid value is range from `2` to `60,000`.
         * Changing this will create a new trigger resource.
         */
        pullPeriod: number;
        /**
         * Specifies the determines whether to pull data only after the data pulled
         * in the last period has been processed.
         * Changing this will create a new trigger resource.
         */
        serialEnable: boolean;
        /**
         * Specifies the type of starting position for DIS queue.
         * The valid values are as follows:
         * + **TRIM_HORIZON**: Starts reading from the earliest data stored in the partitions.
         * + **LATEST**: Starts reading from the latest data stored in the partitions.
         * Changing this will create a new trigger resource.
         */
        startingPosition: string;
        /**
         * Specifies the name of the DIS stream resource.
         * Changing this will create a new trigger resource.
         */
        streamName: string;
    }

    export interface TriggerKafka {
        /**
         * Specifies the The number of messages consumed from the topic each time.
         * The valid value is range from `1` to `1,000`. Defaults to `100`.
         * Changing this will create a new trigger resource.
         */
        batchSize?: number;
        /**
         * Specifies the ID of the APIG dedicated instance to which the API belongs.
         * Required if the `type` is `DEDICATEDGATEWAY`. Changing this will create a new trigger resource.
         */
        instanceId: string;
        /**
         * Specifies one or more topic IDs of DMS kafka instance.
         * Changing this will create a new trigger resource.
         */
        topicIds: string[];
    }

    export interface TriggerLts {
        /**
         * Specifies the log group ID.
         * Changing this will create a new trigger resource.
         */
        logGroupId: string;
        /**
         * Specifies the log stream ID.
         * Changing this will create a new trigger resource.
         */
        logTopicId: string;
    }

    export interface TriggerObs {
        /**
         * Specifies the OBS bucket name.
         * Changing this will create a new trigger resource.
         */
        bucketName: string;
        /**
         * Specifies the event notification name.
         * Changing this will create a new trigger resource.
         */
        eventNotificationName: string;
        /**
         * Specifies the events that can trigger functions.
         * Changing this will create a new trigger resource.
         * The valid values are as follows:
         * + **ObjectCreated**, **Put**, **Post**, **Copy** and **CompleteMultipartUpload**.
         * + **ObjectRemoved**, **Delete** and **DeleteMarkerCreated**.
         */
        events: string[];
        /**
         * Specifies the prefix to limit notifications to objects beginning with this keyword.
         * Changing this will create a new trigger resource.
         */
        prefix?: string;
        /**
         * Specifies the suffix to limit notifications to objects ending with this keyword.
         * Changing this will create a new trigger resource.
         */
        suffix?: string;
    }

    export interface TriggerSmn {
        /**
         * Specifies the Uniform Resource Name (URN) for SMN topic.
         * Changing this will create a new trigger resource.
         */
        topicUrn: string;
    }

    export interface TriggerTimer {
        /**
         * Specifies the event used by the timer to trigger the function.
         * Changing this will create a new trigger resource.
         */
        additionalInformation?: string;
        /**
         * Specifies the trigger name, which can contains of 1 to 64 characters.
         * The name must start with a letter, only letters, digits, hyphens (-) and underscores (_) are allowed.
         * Changing this will create a new trigger resource.
         */
        name: string;
        /**
         * Specifies the time schedule.
         * For the rate type, schedule is composed of time and time unit.
         * The time unit supports minutes (m), hours (h) and days (d).
         * For the corn expression, please refer to the HuaweiCloud
         * [document](https://support.huaweicloud.com/en-us/usermanual-functiongraph/functiongraph_01_0908.html).
         * Changing this will create a new trigger resource.
         */
        schedule: string;
        /**
         * Specifies the type of the time schedule.
         * The valid values are **Rate** and **Cron**.
         * Changing this will create a new trigger resource.
         */
        scheduleType: string;
    }

}

export namespace GaussDB {
    export interface GetMysqlFlavorsFlavor {
        /**
         * Indicates the flavor status in each availability zone.
         */
        azStatus: {[key: string]: string};
        /**
         * Indicates the memory size in GB.
         */
        memory: string;
        /**
         * Indicates the database mode.
         */
        mode: string;
        /**
         * The name of the gaussdb mysql flavor.
         */
        name: string;
        /**
         * Indicates the arch type of the flavor.
         */
        type: string;
        /**
         * Indicates the CPU size.
         */
        vcpus: string;
        /**
         * Specifies the database version. Only "8.0" is supported now.
         */
        version: string;
    }

    export interface GetMysqlInstanceBackupStrategy {
        /**
         * Indicates the number of days to retain the generated
         */
        keepDays: number;
        /**
         * Indicates the backup time window.
         */
        startTime: string;
    }

    export interface GetMysqlInstanceDatastore {
        /**
         * Indicates the database engine.
         */
        engine: string;
        /**
         * Indicates the database version.
         */
        version: string;
    }

    export interface GetMysqlInstanceNode {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZone: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates the private IP address of a node.
         */
        privateReadIp: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Indicates the node type: master or slave.
         */
        type: string;
    }

    export interface GetMysqlInstancesInstance {
        /**
         * Indicates the availability zone mode: "single" or "multi".
         */
        availabilityZoneMode: string;
        /**
         * Indicates the advanced backup policy. Structure is documented below.
         */
        backupStrategies: outputs.GaussDB.GetMysqlInstancesInstanceBackupStrategy[];
        /**
         * Indicates the configuration ID.
         */
        configurationId: string;
        /**
         * Indicates the database information. Structure is documented below.
         */
        datastores: outputs.GaussDB.GetMysqlInstancesInstanceDatastore[];
        /**
         * Indicates the default username.
         */
        dbUserName: string;
        /**
         * Indicates the enterprise project id.
         */
        enterpriseProjectId: string;
        /**
         * Indicates the instance specifications.
         */
        flavor: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Indicates the availability zone where the master node resides.
         */
        masterAvailabilityZone: string;
        /**
         * Indicates the instance mode.
         */
        mode: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates the instance nodes information. Structure is documented below.
         */
        nodes: outputs.GaussDB.GetMysqlInstancesInstanceNode[];
        /**
         * Indicates the database port.
         */
        port: number;
        /**
         * Indicates the private IP address of the DB instance.
         */
        privateWriteIp: string;
        /**
         * Indicates the count of read replicas.
         */
        readReplicas: number;
        /**
         * The region in which to obtain the instances. If omitted, the provider-level region will
         * be used.
         */
        region: string;
        /**
         * Indicates the security group ID.
         */
        securityGroupId: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Specifies the network ID of a subnet.
         */
        subnetId: string;
        /**
         * Indicates the time zone.
         */
        timeZone: string;
        /**
         * Specifies the VPC ID.
         */
        vpcId: string;
    }

    export interface GetMysqlInstancesInstanceBackupStrategy {
        /**
         * Indicates the number of days to retain the generated
         */
        keepDays: number;
        /**
         * Indicates the backup time window.
         */
        startTime: string;
    }

    export interface GetMysqlInstancesInstanceDatastore {
        /**
         * Indicates the database engine.
         */
        engine: string;
        /**
         * Indicates the database version.
         */
        version: string;
    }

    export interface GetMysqlInstancesInstanceNode {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZone: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates the private IP address of a node.
         */
        privateReadIp: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Indicates the node type: master or slave.
         */
        type: string;
    }

    export interface MysqlInstanceBackupStrategy {
        /**
         * Specifies the number of days to retain the generated backup files. The value ranges from
         * 0 to 35. If this parameter is set to 0, the automated backup policy is not set. If this parameter is not transferred,
         * the automated backup policy is enabled by default. Backup files are stored for seven days by default.
         */
        keepDays?: number;
        /**
         * Specifies the backup time window. Automated backups will be triggered during the
         * backup time window. It must be a valid value in the "hh:mm-HH:MM" format. The current time is in the UTC format. The
         * HH value must be 1 greater than the hh value. The values of mm and MM must be the same and must be set to 00. Example
         * value: 08:00-09:00, 03:00-04:00.
         */
        startTime: string;
    }

    export interface MysqlInstanceDatastore {
        /**
         * Specifies the database engine. Only "gauss-mysql" is supported now.
         */
        engine: string;
        /**
         * Specifies the database version. Only "8.0" is supported now.
         */
        version: string;
    }

    export interface MysqlInstanceNode {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZone: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the instance name, which can be the same as an existing instance name. The value
         * must be 4 to 64 characters in length and start with a letter. It is case-sensitive and can contain only letters,
         * digits, hyphens (-), and underscores (_).
         */
        name: string;
        /**
         * Indicates the private IP address of a node.
         */
        privateReadIp: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Indicates the node type: master or slave.
         */
        type: string;
    }
}

export namespace GaussDBforNoSQL {
    export interface CassandraInstanceBackupStrategy {
        /**
         * Specifies the number of days to retain the generated backup files. The value ranges from
         * 0 to 35. If this parameter is set to 0, the automated backup policy is not set. If this parameter is not transferred,
         * the automated backup policy is enabled by default. Backup files are stored for seven days by default.
         */
        keepDays: number;
        /**
         * Specifies the backup time window. Automated backups will be triggered during the
         * backup time window. It must be a valid value in the "hh:mm-HH:MM" format. The current time is in the UTC format. The
         * HH value must be 1 greater than the hh value. The values of mm and MM must be the same and must be set to 00. Example
         * value: 08:00-09:00, 03:00-04:00.
         */
        startTime: string;
    }

    export interface CassandraInstanceDatastore {
        /**
         * Specifies the database engine. Only "GeminiDB-Cassandra" is supported now.
         */
        engine: string;
        /**
         * Specifies the storage engine. Only "rocksDB" is supported now.
         */
        storageEngine: string;
        /**
         * Specifies the database version.
         */
        version: string;
    }

    export interface CassandraInstanceNode {
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the instance name, which can be the same as an existing instance name. The value
         * must be 4 to 64 characters in length and start with a letter. It is case-sensitive and can contain only letters,
         * digits, hyphens (-), and underscores (_).
         */
        name: string;
        /**
         * Indicates the private IP address of a node.
         */
        privateIp: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Indicates whether the node support reduce or not.
         */
        supportReduce: boolean;
    }

    export interface GetCassandraFlavorsFlavor {
        /**
         * Indicates the flavor status in each availability zone.
         */
        azStatus: {[key: string]: string};
        /**
         * Specifies the memory size of the flavors.
         */
        memory: string;
        /**
         * Indicates the spec code of the flavor.
         */
        name: string;
        /**
         * Specifies the count of vcpus of the flavors.
         */
        vcpus: string;
        /**
         * Specifies the engine version of the flavors.
         */
        version: string;
    }

    export interface GetCassandraInstanceBackupStrategy {
        /**
         * Indicates the number of days to retain the generated
         */
        keepDays: number;
        /**
         * Indicates the backup time window.
         */
        startTime: string;
    }

    export interface GetCassandraInstanceDatastore {
        /**
         * Indicates the database engine.
         */
        engine: string;
        /**
         * Indicates the database storage engine.
         */
        storageEngine: string;
        /**
         * Indicates the database version.
         */
        version: string;
    }

    export interface GetCassandraInstanceNode {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZone: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates the private IP address of a node.
         */
        privateIp: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Indicates whether the node support reduce.
         */
        supportReduce: boolean;
    }

    export interface GetCassandraInstancesInstance {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZone: string;
        /**
         * Indicates the advanced backup policy. Structure is documented below.
         */
        backupStrategies: outputs.GaussDBforNoSQL.GetCassandraInstancesInstanceBackupStrategy[];
        /**
         * Indicates the database information. Structure is documented below.
         */
        datastores: outputs.GaussDBforNoSQL.GetCassandraInstancesInstanceDatastore[];
        /**
         * Indicates the default username.
         */
        dbUserName: string;
        /**
         * Indicates the enterprise project id.
         */
        enterpriseProjectId: string;
        /**
         * Indicates the instance specifications.
         */
        flavor: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Indicates the instance mode.
         */
        mode: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates the count of the nodes.
         */
        nodeNum: number;
        /**
         * Indicates the instance nodes information. Structure is documented below.
         */
        nodes: outputs.GaussDBforNoSQL.GetCassandraInstancesInstanceNode[];
        /**
         * Indicates the database port.
         */
        port: number;
        /**
         * Indicates the list of private IP address of the nodes.
         */
        privateIps: string[];
        /**
         * The region in which to obtain the instance. If omitted, the provider-level region will
         * be used.
         */
        region: string;
        /**
         * Indicates the security group ID.
         */
        securityGroupId: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Specifies the network ID of a subnet.
         */
        subnetId: string;
        /**
         * Indicates the key/value tags of the instance.
         */
        tags: {[key: string]: string};
        /**
         * Indicates the size of the volume.
         */
        volumeSize: number;
        /**
         * Specifies the VPC ID.
         */
        vpcId: string;
    }

    export interface GetCassandraInstancesInstanceBackupStrategy {
        /**
         * Indicates the number of days to retain the generated
         */
        keepDays: number;
        /**
         * Indicates the backup time window.
         */
        startTime: string;
    }

    export interface GetCassandraInstancesInstanceDatastore {
        /**
         * Indicates the database engine.
         */
        engine: string;
        /**
         * Indicates the database storage engine.
         */
        storageEngine: string;
        /**
         * Indicates the database version.
         */
        version: string;
    }

    export interface GetCassandraInstancesInstanceNode {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZone: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates the private IP address of a node.
         */
        privateIp: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Indicates whether the node support reduce.
         */
        supportReduce: boolean;
    }

    export interface GetNosqlFlavorsFlavor {
        /**
         * All available zones (on sale) for current flavor.
         */
        availabilityZones: string[];
        /**
         * Specifies the type of the database engine. The valid values are as follows:
         * + **cassandra**: The default value and means to query GaussDB (for Cassandra) instance specifications.
         * + **redis**: Means to query GaussDB (for Redis) instance specifications.
         * + **mongodb**: Means to query GaussDB (for Mongo) instance specifications.
         * + **influxdb**: Means to query GaussDB (for Influx) instance specifications.
         */
        engine: string;
        /**
         * Specifies the version of the database engine.
         */
        engineVersion: string;
        /**
         * Specifies the memory size in gigabytes (GB).
         */
        memory: string;
        /**
         * The spec code of the flavor.
         */
        name: string;
        /**
         * Specifies the number of vCPUs.
         */
        vcpus: string;
    }

    export interface GetRedisInstanceBackupStrategy {
        /**
         * Indicates the number of days to retain the generated
         */
        keepDays: number;
        /**
         * Indicates the backup time window.
         */
        startTime: string;
    }

    export interface GetRedisInstanceDatastore {
        /**
         * Indicates the database engine.
         */
        engine: string;
        /**
         * Indicates the database storage engine.
         */
        storageEngine: string;
        /**
         * Indicates the database version.
         */
        version: string;
    }

    export interface GetRedisInstanceNode {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZone: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates the private IP address of a node.
         */
        privateIp: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Indicates whether the node support reduce.
         */
        supportReduce: boolean;
    }

    export interface InfluxInstanceBackupStrategy {
        /**
         * Specifies the number of days to retain the generated backup files. The value ranges from
         * **0** to **35**. If this parameter is set to **0**, the automated backup policy is not set. If this parameter is not
         * transferred, the automated backup policy is enabled by default. Backup files are stored for seven days by default.
         */
        keepDays: number;
        /**
         * Specifies the backup time window. Automated backups will be triggered during the
         * backup time window. It must be a valid value in the "hh:mm-HH:MM" format. The current time is in the UTC format. The
         * HH value must be 1 greater than the hh value. The values of mm and MM must be the same and must be set to 00. Example
         * value: 08:00-09:00, 03:00-04:00.
         */
        startTime: string;
    }

    export interface InfluxInstanceDatastore {
        /**
         * Specifies the database engine. Only **influxdb** is supported now.
         */
        engine: string;
        /**
         * Specifies the storage engine. Only **rocksDB** is supported now.
         */
        storageEngine: string;
        /**
         * Specifies the database version.
         */
        version: string;
    }

    export interface InfluxInstanceNode {
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the instance name, which can be the same as an existing instance name. The
         * value must be **4** to **64** characters in length and start with a letter. It is case-sensitive and can contain only
         * letters, digits, hyphens (-), and underscores (_).
         */
        name: string;
        /**
         * Indicates the private IP address of a node.
         */
        privateIp: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Indicates whether the node support reduce or not.
         */
        supportReduce: boolean;
    }

    export interface MongoInstanceBackupStrategy {
        /**
         * Specifies the number of days to retain the generated backup files. The value ranges from
         * **0** to **35**. If this parameter is set to **0**, the automated backup policy is not set. If this parameter is not
         * transferred, the automated backup policy is enabled by default. Backup files are stored for seven days by default.
         */
        keepDays: number;
        /**
         * Specifies the backup time window. Automated backups will be triggered during the
         * backup time window. It must be a valid value in the "hh:mm-HH:MM" format. The current time is in the UTC format. The
         * HH value must be 1 greater than the hh value. The values of mm and MM must be the same and must be set to 00. Example
         * value: 08:00-09:00, 03:00-04:00.
         */
        startTime: string;
    }

    export interface MongoInstanceDatastore {
        /**
         * Specifies the database engine. Only **mongodb** is supported now.
         */
        engine: string;
        /**
         * Specifies the storage engine. Only **rocksDB** is supported now.
         */
        storageEngine: string;
        /**
         * Specifies the database version.
         */
        version: string;
    }

    export interface MongoInstanceNode {
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the instance name, which can be the same as an existing instance name. The
         * value must be **4** to **64** characters in length and start with a letter. It is case-sensitive and can contain only
         * letters, digits, hyphens (-), and underscores (_).
         */
        name: string;
        /**
         * Indicates the private IP address of a node.
         */
        privateIp: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Indicates whether the node support reduce or not.
         */
        supportReduce: boolean;
    }

    export interface RedisInstanceBackupStrategy {
        /**
         * Specifies the number of days to retain the generated backup files. The value ranges from
         * 0 to 35. If this parameter is set to 0, the automated backup policy is not set. If this parameter is not transferred,
         * the automated backup policy is enabled by default. Backup files are stored for seven days by default.
         */
        keepDays: number;
        /**
         * Specifies the backup time window. Automated backups will be triggered during the
         * backup time window. It must be a valid value in the "hh:mm-HH:MM" format. The current time is in the UTC format. The
         * HH value must be 1 greater than the hh value. The values of mm and MM must be the same and must be set to 00. Example
         * value: 08:00-09:00, 03:00-04:00.
         */
        startTime: string;
    }

    export interface RedisInstanceDatastore {
        /**
         * Specifies the database engine. Only "redis" is supported now.
         */
        engine: string;
        /**
         * Specifies the storage engine. Only "rocksDB" is supported now.
         */
        storageEngine: string;
        /**
         * Specifies the database version. Only "5.0" is supported now.
         */
        version: string;
    }

    export interface RedisInstanceNode {
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the instance name, which can be the same as an existing instance name. The value
         * must be 4 to 64 characters in length and start with a letter. It is case-sensitive and can contain only letters,
         * digits, hyphens (-), and underscores (_). Chinese characters must be in UTF-8 or Unicode format.
         */
        name: string;
        /**
         * Indicates the private IP address of a node.
         */
        privateIp: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Indicates whether the node support reduce or not.
         */
        supportReduce: boolean;
    }
}

export namespace GaussDBforOpenGauss {
    export interface GetOpengaussInstanceBackupStrategy {
        /**
         * Indicates the number of days to retain the generated
         */
        keepDays: number;
        /**
         * Indicates the backup time window.
         */
        startTime: string;
    }

    export interface GetOpengaussInstanceDatastore {
        /**
         * Indicates the database engine.
         */
        engine: string;
        /**
         * Indicates the database version.
         */
        version: string;
    }

    export interface GetOpengaussInstanceHa {
        /**
         * Indicates the replication mode.
         */
        replicationMode: string;
    }

    export interface GetOpengaussInstanceNode {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZone: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates whether the node support reduce.
         */
        role: string;
        /**
         * Indicates the node status.
         */
        status: string;
    }

    export interface GetOpengaussInstanceVolume {
        /**
         * Indicates the volume size.
         */
        size: number;
        /**
         * Indicates the volume type.
         */
        type: string;
    }

    export interface GetOpengaussInstancesInstance {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZone: string;
        /**
         * Indicates the advanced backup policy. Structure is documented below.
         */
        backupStrategies: outputs.GaussDBforOpenGauss.GetOpengaussInstancesInstanceBackupStrategy[];
        /**
         * Indicates the count of coordinator node.
         */
        coordinatorNum: number;
        /**
         * Indicates the database information. Structure is documented below.
         */
        datastores: outputs.GaussDBforOpenGauss.GetOpengaussInstancesInstanceDatastore[];
        /**
         * Indicates the default username.
         */
        dbUserName: string;
        /**
         * Indicates the enterprise project id.
         */
        enterpriseProjectId: string;
        /**
         * Indicates the instance specifications.
         */
        flavor: string;
        /**
         * Indicates the instance ha information. Structure is documented below.
         */
        has: outputs.GaussDBforOpenGauss.GetOpengaussInstancesInstanceHa[];
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Indicates the maintenance window.
         */
        maintenanceWindow: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates the instance nodes information. Structure is documented below.
         */
        nodes: outputs.GaussDBforOpenGauss.GetOpengaussInstancesInstanceNode[];
        /**
         * Indicates the database port.
         */
        port: number;
        /**
         * Indicates the list of private IP address of the nodes.
         */
        privateIps: string[];
        /**
         * The region in which to obtain the instance. If omitted, the provider-level region will
         * be used.
         */
        region: string;
        /**
         * Indicates the security group ID.
         */
        securityGroupId: string;
        /**
         * Indicates the sharding num.
         */
        shardingNum: number;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Specifies the network ID of a subnet.
         */
        subnetId: string;
        /**
         * Indicates the switch strategy.
         */
        switchStrategy: string;
        /**
         * Indicates the default username.
         */
        timeZone: string;
        /**
         * Indicates the volume type.
         */
        type: string;
        /**
         * Indicates the volume information. Structure is documented below.
         */
        volumes: outputs.GaussDBforOpenGauss.GetOpengaussInstancesInstanceVolume[];
        /**
         * Specifies the VPC ID.
         */
        vpcId: string;
    }

    export interface GetOpengaussInstancesInstanceBackupStrategy {
        /**
         * Indicates the number of days to retain the generated
         */
        keepDays: number;
        /**
         * Indicates the backup time window.
         */
        startTime: string;
    }

    export interface GetOpengaussInstancesInstanceDatastore {
        /**
         * Indicates the database engine.
         */
        engine: string;
        /**
         * Indicates the database version.
         */
        version: string;
    }

    export interface GetOpengaussInstancesInstanceHa {
        /**
         * Indicates the replication mode.
         */
        replicationMode: string;
    }

    export interface GetOpengaussInstancesInstanceNode {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZone: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates whether the node support reduce.
         */
        role: string;
        /**
         * Indicates the node status.
         */
        status: string;
    }

    export interface GetOpengaussInstancesInstanceVolume {
        /**
         * Indicates the volume size.
         */
        size: number;
        /**
         * Indicates the volume type.
         */
        type: string;
    }

    export interface OpengaussInstanceBackupStrategy {
        /**
         * Specifies the number of days to retain the generated backup files. The value ranges from
         * `0` to `732`. If this parameter is set to `0`, the automated backup policy is not set.
         * If this parameter is not transferred, the automated backup policy is enabled by default.
         */
        keepDays?: number;
        /**
         * Specifies the backup time window. Automated backups will be triggered during the
         * backup time window. It must be a valid value in the **hh:mm-HH:MM** format. The current time is in the UTC format. The
         * **HH** value must be `1` greater than the **hh** value. The values of mm and MM must be the same and must be set to
         * **00**. Example value: **08:00-09:00**, **23:00-00:00**.
         */
        startTime: string;
    }

    export interface OpengaussInstanceDatastore {
        /**
         * Specifies the database engine. Only **GaussDB(for openGauss)** is supported
         * now. Changing this parameter will create a new resource.
         */
        engine: string;
        /**
         * Specifies the database version. Defaults to the latest version. Please
         * reference to the API docs for valid options. Changing this parameter will create a new resource.
         */
        version: string;
    }

    export interface OpengaussInstanceHa {
        /**
         * Specifies the database consistency mode.
         * The valid values are **strong** and **eventual**, not case sensitive.
         * Changing this parameter will create a new resource.
         */
        consistency?: string;
        /**
         * Specifies the database mode.
         * The valid values are **enterprise** and **centralization_standard**.
         * Changing this parameter will create a new resource.
         */
        mode: string;
        /**
         * Specifies the database replication mode.
         * Only **sync** is supported now. Changing this parameter will create a new resource.
         */
        replicationMode: string;
    }

    export interface OpengaussInstanceNode {
        /**
         * Specifies the availability zone information, can be three same or
         * different az like **cn-north-4a,cn-north-4a,cn-north-4a**. Changing this parameter will create a new resource.
         */
        availabilityZone: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the instance name, which can be the same as an existing instance name.
         * The value must be `4` to `64` characters in length and start with a letter. It is case-sensitive and can contain only
         * letters, digits, hyphens (-), and underscores (_).
         */
        name: string;
        /**
         * Indicates the node role.
         * + **master**.
         * + **slave**.
         */
        role: string;
        /**
         * Indicates the node status.
         */
        status: string;
    }

    export interface OpengaussInstanceVolume {
        /**
         * Specifies the volume size (in gigabytes). The valid value is range form `40` to `4,000`.
         */
        size: number;
        /**
         * Specifies the volume type. Only **ULTRAHIGH** is supported now.
         * Changing this parameter will create a new resource.
         */
        type: string;
    }
}

export namespace Iam {
    export interface AclIpCidr {
        /**
         * Specifies the IPv4 CIDR block, for example, **192.168.0.0/24**.
         */
        cidr: string;
        /**
         * Specifies a description about an IP address range. This parameter can contain a
         * maximum of 255 characters and the following charactors are not allowed:**@#%^&*<>\\**.
         */
        description?: string;
    }

    export interface AclIpRange {
        /**
         * Specifies a description about an IP address range. This parameter can contain a
         * maximum of 255 characters and the following charactors are not allowed:**@#%^&*<>\\**.
         */
        description?: string;
        /**
         * Specifies the Ip address range, for example, **0.0.0.0-255.255.255.0**.
         */
        range: string;
    }

    export interface AgencyProjectRole {
        /**
         * Specifies the name of project.
         */
        project: string;
        /**
         * Specifies an array of role names.
         */
        roles: string[];
    }

    export interface GetGroupUser {
        /**
         * Specifies the description of the identity group.
         */
        description: string;
        /**
         * Indicates the whether the IAM user is enabled.
         */
        enabled: boolean;
        /**
         * Specifies the ID of the identity group.
         */
        id: string;
        /**
         * Specifies the name of the identity group.
         */
        name: string;
        /**
         * Indicates the time when the password will expire.
         * Null indicates that the password has unlimited validity.
         */
        passwordExpiresAt: string;
        /**
         * Indicates the password status. True means that the password needs to be changed,
         * and false means that the password is normal.
         */
        passwordStatus: boolean;
        /**
         * Indicates the password strength. The value can be high, mid, or low.
         */
        passwordStrength: string;
    }

    export interface GetProjectsProject {
        /**
         * Whether project is enabled.
         */
        enabled: boolean;
        /**
         * The project ID.
         */
        id: string;
        /**
         * Specifies the project name to query.
         */
        name: string;
    }

    export interface GetUsersUser {
        /**
         * Indicates the description of the IAM user.
         */
        description: string;
        /**
         * Specifies the status of the IAM user, the default value is **true**.
         */
        enabled: boolean;
        /**
         * Indicates the user groups to which an IAM user belongs.
         */
        groups: string[];
        /**
         * Indicates the ID of the User.
         */
        id: string;
        /**
         * Specifies the IAM user name.
         */
        name: string;
        /**
         * Indicates the time when the password will expire.
         * Null indicates that the password has unlimited validity.
         */
        passwordExpiresAt: string;
        /**
         * Indicates the password status. True means that the password needs to be changed,
         * and false means that the password is normal.
         */
        passwordStatus: boolean;
    }

    export interface ProviderAccessConfig {
        /**
         * Specifies the access type of the identity provider.
         * Available options are:
         * + `program`: programmatic access only.
         * + `programConsole`: programmatic access and management console access.
         */
        accessType: string;
        /**
         * Specifies the authorization endpoint of the OpenID Connect identity
         * provider. This field is required only if the access type is set to `programConsole`.
         */
        authorizationEndpoint: string;
        /**
         * Specifies the ID of a client registered with the OpenID Connect identity provider.
         */
        clientId: string;
        /**
         * Specifies the URL of the identity provider.
         * This field corresponds to the iss field in the ID token.
         */
        providerUrl: string;
        /**
         * Response mode.
         * Valid values is *form_post* and *fragment*, default value is *form_post*.
         * This field is required only if the access type is set to `programConsole`.
         */
        responseMode?: string;
        /**
         * Response type. Valid values is *id_token*, default value is *id_token*.
         * This field is required only if the access type is set to `programConsole`.
         */
        responseType?: string;
        /**
         * Specifies the scopes of authorization requests. It is an array of one or more scopes.
         * Valid values are *openid*, *email*, *profile* and other values defined by you.
         * This field is required only if the access type is set to `programConsole`.
         */
        scopes: string[];
        /**
         * Public key used to sign the ID token of the OpenID Connect identity provider.
         * This field is required only if the protocol is set to *oidc*.
         */
        signingKey: string;
    }

    export interface ProviderConversionRule {
        /**
         * The federated user information on the cloud platform.
         */
        locals: outputs.Iam.ProviderConversionRuleLocal[];
        /**
         * The description of the identity provider.
         */
        remotes: outputs.Iam.ProviderConversionRuleRemote[];
    }

    export interface ProviderConversionRuleLocal {
        /**
         * The user group to which the federated user belongs on the cloud platform.
         */
        group: string;
        /**
         * The name of a federated user on the cloud platform.
         */
        username: string;
    }

    export interface ProviderConversionRuleRemote {
        /**
         * The attribute in the IDP assertion.
         */
        attribute: string;
        /**
         * The condition of conversion rule.
         */
        condition: string;
        /**
         * The rule is matched only if the specified strings appear in the attribute type.
         */
        values: string[];
    }
}

export namespace Iec {
    export interface GetBandwidthsBandwidth {
        /**
         * The charging mode of the bandwidth.
         */
        chargeMode: string;
        /**
         * The ID of the bandwidth.
         */
        id: string;
        /**
         * The line name of the bandwidth.
         */
        line: string;
        /**
         * The name of the bandwidth.
         */
        name: string;
        /**
         * Whether the bandwidth is shared or exclusive.
         */
        shareType: string;
        /**
         * The size of the bandwidth.
         */
        size: number;
        /**
         * The status of the bandwidth.
         */
        status: string;
    }

    export interface GetEipsEip {
        bandwidthId: string;
        bandwidthName: string;
        bandwidthShareType: string;
        bandwidthSize: number;
        /**
         * The ID of elastic IP.
         */
        id: string;
        /**
         * The version of elastic IP address.
         */
        ipVersion: number;
        /**
         * Specifies the ID of the port.
         */
        portId: string;
        /**
         * The address of private IP.
         */
        privateIp: string;
        /**
         * The address of elastic IP.
         */
        publicIp: string;
        /**
         * The status elastic IP.
         */
        status: string;
    }

    export interface GetFlavorsFlavor {
        /**
         * The id of the iec flavor.
         */
        id: string;
        /**
         * The memory of the iec flavor.
         */
        memory: number;
        /**
         * Specifies the flavor name, which can be queried with a regular expression.
         */
        name: string;
        /**
         * The vcpus of the iec flavor.
         */
        vcpus: number;
    }

    export interface GetImagesImage {
        /**
         * The id of the iec images.
         */
        id: string;
        /**
         * Specifies the image Name, which can be queried with a regular expression.
         */
        name: string;
        /**
         * Specifies the os type of the iec image.
         * "Linux", "Windows" and "Other" are supported.
         */
        osType: string;
        /**
         * The status of the iec images.
         */
        status: string;
    }

    export interface GetNetwork_aclNetwork {
        subnetId: string;
        vpcId: string;
    }

    export interface GetSecurityGroupSecurityGroupRule {
        /**
         * The description for the IEC security group rules.
         */
        description: string;
        /**
         * The direction of the IEC security group rules.
         */
        direction: string;
        /**
         * The layer 3 protocol type.
         */
        ethertype: string;
        /**
         * The ID of the IEC security group rules.
         */
        id: string;
        /**
         * The higher part of the allowed port range.
         */
        portRangeMax: number;
        /**
         * The lower part of the allowed port range.
         */
        portRangeMin: number;
        /**
         * The layer 4 protocol type.
         */
        protocol: string;
        /**
         * The remote group id of the IEC security group rules.
         */
        remoteGroupId: string;
        /**
         * The remote CIDR of the IEC security group rules.
         */
        remoteIpPrefix: string;
        /**
         * The id of the IEC security group rules.
         */
        securityGroupId: string;
    }

    export interface GetServerCoverageSite {
        /**
         * The operator of the IEC site.
         */
        operator: string;
        /**
         * The ID of IEC site.
         */
        siteId: string;
        /**
         * The located information of the IEC site. It contains area, province and city.
         */
        siteInfo: string;
    }

    export interface GetServerNic {
        /**
         * The IPv4 address of the server on that network.
         */
        address: string;
        /**
         * The MAC address of the NIC on that network.
         */
        mac: string;
        /**
         * The port ID corresponding to the IP address on that network.
         */
        port: string;
    }

    export interface GetServerVolumeAttached {
        /**
         * The volume boot index on that attachment.
         */
        bootIndex: string;
        /**
         * The device name in the IEC server.
         */
        device: string;
        /**
         * The volume size on that attachment.
         */
        size: number;
        /**
         * The volume type on that attachment.
         */
        type: string;
        /**
         * The volume ID on that attachment.
         */
        volumeId: string;
    }

    export interface GetSitesSite {
        /**
         * Specifies the area of the IEC sites located.
         */
        area: string;
        /**
         * Specifies the city of the IEC sites located.
         */
        city: string;
        /**
         * The ID of the EIP line.
         */
        id: string;
        /**
         * An array of one or more EIP lines. The object structure is documented below.
         */
        lines: outputs.Iec.GetSitesSiteLine[];
        /**
         * The name of the EIP line.
         */
        name: string;
        /**
         * Specifies the province of the IEC sites located.
         */
        province: string;
        /**
         * The status of the IEC service site.
         */
        status: string;
    }

    export interface GetSitesSiteLine {
        /**
         * The ID of the EIP line.
         */
        id: string;
        /**
         * The supported IP version.
         */
        ipVersion: string;
        /**
         * The name of the EIP line.
         */
        name: string;
        /**
         * The operator information of the EIP line.
         */
        operator: string;
    }

    export interface GetVpcSubnetsSubnet {
        /**
         * Indicates the cidr block of the subnet.
         */
        cidr: string;
        /**
         * Indicates the DNS server address list of the subnet.
         */
        dnsLists: string[];
        /**
         * Indicates the gateway of the subnet.
         */
        gatewayIp: string;
        /**
         * Indicates the ID of the subnet.
         */
        id: string;
        /**
         * Indicates the name of the subnet.
         */
        name: string;
        /**
         * Specifies the ID of the IEC site.
         */
        siteId: string;
        /**
         * Indicates the located information of the iec site. It contains area, province and city.
         */
        siteInfo: string;
        /**
         * Indicates the status of the subnet.
         */
        status: string;
    }

    export interface NetworkAclNetwork {
        /**
         * Specifies the id of the iec subnet.
         */
        subnetId: string;
        /**
         * Specifies the id of the iec vpc.
         */
        vpcId: string;
    }

    export interface SecurityGroupSecurityGroupRule {
        /**
         * Specifies the description of the iec security group. description must be
         * 0 to 64 characters in length, and does not contain angle brackets (<) and (>). Changing this parameter will creates a
         * new iec security group resource.
         */
        description: string;
        /**
         * The direction of the iec security group rules.
         */
        direction: string;
        /**
         * The layer 3 protocol type.
         */
        ethertype: string;
        /**
         * The id of the iec security group rules.
         */
        id: string;
        /**
         * The higher part of the allowed port range.
         */
        portRangeMax: number;
        /**
         * The lower part of the allowed port range.
         */
        portRangeMin: number;
        /**
         * The layer 4 protocol type.
         */
        protocol: string;
        /**
         * The remote group id of the iec security group rules.
         */
        remoteGroupId: string;
        /**
         * The remote CIDR of the iec security group rules.
         */
        remoteIpPrefix: string;
        /**
         * The id of the iec security group rules.
         */
        securityGroupId: string;
    }

    export interface ServerCoverageSite {
        /**
         * Specifies the operator of the IEC site.
         */
        operator: string;
        /**
         * Specifies the ID of IEC site.
         */
        siteId: string;
    }

    export interface ServerDataDisk {
        /**
         * Specifies the size of data disk for the IEC server binding. The value range is
         * 10 to 500 in GB. Changing this parameter creates a new IEC server resource.
         */
        size: number;
        /**
         * Specifies the type of data disk for the IEC server binding. Valid value is
         * *SAS*(high I/O disk type). Changing this parameter creates a new IEC server resource.
         */
        type: string;
    }

    export interface ServerNic {
        /**
         * The IPv4 address of the server on that network.
         */
        address: string;
        /**
         * The MAC address of the NIC on that network.
         */
        mac: string;
        /**
         * The port ID corresponding to the IP address on that network.
         */
        port: string;
    }

    export interface ServerVolumeAttached {
        /**
         * The volume boot index on that attachment.
         */
        bootIndex: string;
        /**
         * The device name in the IEC server.
         */
        device: string;
        /**
         * Specifies the size of data disk for the IEC server binding. The value range is
         * 10 to 500 in GB. Changing this parameter creates a new IEC server resource.
         */
        size: number;
        /**
         * Specifies the type of data disk for the IEC server binding. Valid value is
         * *SAS*(high I/O disk type). Changing this parameter creates a new IEC server resource.
         */
        type: string;
        /**
         * The volume ID on that attachment.
         */
        volumeId: string;
    }
}

export namespace IoTDA {
    export interface DataforwardingRuleTarget {
        /**
         * Specifies the detail of AMQP forwards. It is required when type
         * is `AMQP_FORWARDING`. The amqpForwarding structure is documented below.
         */
        amqpForwarding: outputs.IoTDA.DataforwardingRuleTargetAmqpForwarding;
        /**
         * Specifies the detail of the DIS forwards. It is required when type
         * is `DIS_FORWARDING`. The disForwarding structure is documented below.
         */
        disForwarding: outputs.IoTDA.DataforwardingRuleTargetDisForwarding;
        /**
         * Specifies the detail of the HTTP forwards. It is required when type
         * is `HTTP_FORWARDING`. The httpForwarding structure is documented below.
         */
        httpForwarding: outputs.IoTDA.DataforwardingRuleTargetHttpForwarding;
        /**
         * The resource ID in UUID format.
         */
        id: string;
        /**
         * Specifies the detail of the KAFKA forwards. It is required when type
         * is `DMS_KAFKA_FORWARDING`. The properties structure is documented below.
         */
        kafkaForwarding: outputs.IoTDA.DataforwardingRuleTargetKafkaForwarding;
        /**
         * Specifies the detail of the OBS forwards. It is required when type
         * is `OBS_FORWARDING`. The obsForwarding structure is documented below.
         */
        obsForwarding: outputs.IoTDA.DataforwardingRuleTargetObsForwarding;
        /**
         * Specifies the type of forwarding target. The options are as follows:
         * + **HTTP_FORWARDING**: The platform can push specified device data to a Third-party application (HTTP push).
         * You can set different addresses that different types of device data are pushed to.
         * + **DIS_FORWARDING**: DIS provides efficient collection, transmission, and distribution of real-time data. It also
         * provides an abundant selection of APIs to help you quickly create real-time data applications.
         * + **OBS_FORWARDING**: OBS is a stable, secure, cloud storage service that is scalable, efficient and easy-to-use.
         * It allows you to store any amount of unstructured data in any format, and provides REST APIs so you can access your
         * data from anywhere.
         * + **AMQP_FORWARDING**: AMQP provides a scalable, distributed message queue that supports high throughput with low
         * latency. AMQP is ready from the get-go and is O&M free.
         * + **DMS_KAFKA_FORWARDING**: Distributed Message Service (DMS) for Kafka features high throughput, concurrency, and
         * scalability. It is suitable for real-time data transmission, stream data processing, system decoupling,
         * and traffic balancing.
         */
        type: string;
    }

    export interface DataforwardingRuleTargetAmqpForwarding {
        /**
         * Specifies the AMQP Queue name.
         */
        queueName: string;
    }

    export interface DataforwardingRuleTargetDisForwarding {
        /**
         * Specifies the project ID to which the KAFKA belongs.
         * If omitted, the default project in the region will be used.
         */
        projectId: string;
        /**
         * Specifies the region to which the KAFKA belongs.
         */
        region: string;
        /**
         * Specifies the DIS stream ID.
         */
        streamId: string;
    }

    export interface DataforwardingRuleTargetHttpForwarding {
        /**
         * Specifies the Push URL. The request method must is post.
         */
        url: string;
    }

    export interface DataforwardingRuleTargetKafkaForwarding {
        /**
         * Specifies the list of the connected service addresses.
         * The addresses structure is documented below.
         */
        addresses: outputs.IoTDA.DataforwardingRuleTargetKafkaForwardingAddress[];
        /**
         * Specifies the password.
         */
        password?: string;
        /**
         * Specifies the project ID to which the KAFKA belongs.
         * If omitted, the default project in the region will be used.
         */
        projectId: string;
        /**
         * Specifies the region to which the KAFKA belongs.
         */
        region: string;
        /**
         * Specifies the topic.
         */
        topic: string;
        /**
         * Specifies the SASL user name.
         */
        userName?: string;
    }

    export interface DataforwardingRuleTargetKafkaForwardingAddress {
        /**
         * Specifies the domain of the connected service address.
         * Exactly one of `ip` or `domain` must be provided.
         */
        domain?: string;
        /**
         * Specifies the IP of the connected service address.
         * Exactly one of `ip` or `domain` must be provided.
         */
        ip?: string;
        /**
         * Specifies the port of the connected service address.
         */
        port: number;
    }

    export interface DataforwardingRuleTargetObsForwarding {
        /**
         * Specifies the OBS Bucket.
         */
        bucket: string;
        /**
         * Specifies the custom directory for storing channel files. The ID contains a
         * maximum of 256 characters. Multi-level directories can be separated by (/), and cannot start or end with a slash (/),
         * and cannot contain more than two adjacent slashes (/). Only letters, digits, hyphens (-), underscores (_), slash (/)
         * and braces ({}) are allowed. Braces can be used only for the time template parameters. For example, if the custom
         * directory is in the format of {YYYY}/{MM}/{DD}/{HH}, data is generated in the directory based on the current
         * time(for example, 2022/06/14/10) when data is forwarded.
         */
        customDirectory: string;
        /**
         * Specifies the project ID to which the KAFKA belongs.
         * If omitted, the default project in the region will be used.
         */
        projectId: string;
        /**
         * Specifies the region to which the KAFKA belongs.
         */
        region: string;
    }

    export interface DeviceLinkageRuleAction {
        /**
         * Specifies the detail of device alarm. It is required when type
         * is `DEVICE_ALARM`. The deviceAlarm structure is documented below.
         */
        deviceAlarm: outputs.IoTDA.DeviceLinkageRuleActionDeviceAlarm;
        /**
         * Specifies the detail of device command. It is required when type
         * is `DEVICE_CMD`. The deviceCommand structure is documented below.
         */
        deviceCommand: outputs.IoTDA.DeviceLinkageRuleActionDeviceCommand;
        /**
         * Specifies the detail of SMN notifications. It is required when type
         * is `SMN_FORWARDING`. The smnForwarding structure is documented below.
         */
        smnForwarding: outputs.IoTDA.DeviceLinkageRuleActionSmnForwarding;
        /**
         * Specifies the type of the alarm. The options are as follows:
         * + **fault**: Report alarms.
         * + **recovery**: Clear alarms.
         */
        type: string;
    }

    export interface DeviceLinkageRuleActionDeviceAlarm {
        /**
         * Specifies the description of the alarm.
         */
        description?: string;
        /**
         * Specifies the name of the alarm.
         */
        name: string;
        /**
         * Specifies the severity level of the alarm.
         * The valid values are **warning**, **minor**, **major** and **critical**.
         */
        severity: string;
        /**
         * Specifies the type of the alarm. The options are as follows:
         * + **fault**: Report alarms.
         * + **recovery**: Clear alarms.
         */
        type: string;
    }

    export interface DeviceLinkageRuleActionDeviceCommand {
        /**
         * Specifies the command parameters, in json format.
         * + Example of device command using LWM2M protocol: `{"value":"1"}`, there are key-value pairs, each key is the
         * parameter name of the command in the product model.
         * + Example of device command using MQTT protocol: `{"header": {"mode": "ACK","from": "/users/testUser","method":
         * "SET_TEMPERATURE_READ_PERIOD","to":"/devices/{device_id }/services/{service_id}"},"body": {"value" : "1"}}`.
         * - **mode**: Required, whether the device needs to reply to the confirmation message after receiving the command.
         * The default is ACK mode. `ACK` indicates that the confirmation message needs to be replied,
         * `NOACK` indicates that the confirmation message does not need to be replied.
         * - **from**: Optional, the address of the command sender.
         * When the App initiates a request, the format is /users/{userId},
         * when the application server initiates a request, the format is /{serviceName},
         * and when the IoT platform initiates a request, the format is /cloud/{serviceName}.
         * - **to**: optional, the address of the command receiver, the format is /devices/{device_id}/services/{service_id}.
         * - **method**: optional, the command name defined in the product model.
         * - **body**: optional, the message body of the command, which contains key-value pairs, each key is the parameter
         * name of the command in the product model. The specific format requires application and device conventions.
         */
        commandBody: string;
        /**
         * Specifies the command name.
         */
        commandName: string;
        /**
         * Specifies the device id which excutes the command.
         */
        deviceId: string;
        /**
         * Specifies the service id to which the command belongs.
         */
        serviceId: string;
    }

    export interface DeviceLinkageRuleActionSmnForwarding {
        /**
         * Specifies the message content.
         */
        messageContent: string;
        /**
         * Specifies the message title.
         */
        messageTitle: string;
        /**
         * Specifies the project ID to which the SMN belongs.
         * If omitted, the default project in the region will be used.
         */
        projectId: string;
        /**
         * Specifies the region to which the SMN belongs.
         */
        region: string;
        /**
         * Specifies the topic name of the SMN.
         */
        topicName: string;
        /**
         * Specifies the topic URN of the SMN.
         */
        topicUrn: string;
    }

    export interface DeviceLinkageRuleEffectivePeriod {
        /**
         * Specifies a list of days of week, separated by commas. 1 represents Sunday,
         * 2 represents Monday, and so on. Defaults to `1,2,3,4,5,6,7` (every day).
         */
        daysOfWeek: string;
        /**
         * Specifies the end time, in the format: `HH:mm`.
         * For example: `10:00`. If the end time is the same as the start time, the effective period is the whole day.
         */
        endTime: string;
        /**
         * Specifies the start time, in the format: `HH:mm`.
         * For example: `03:00`.
         */
        startTime: string;
    }

    export interface DeviceLinkageRuleTrigger {
        /**
         * Specifies the condition triggered at specified time every day. It is
         * required when type is `DAILY_TIMER`. The dailyTimerCondition structure is
         * documented below.
         */
        dailyTimerCondition: outputs.IoTDA.DeviceLinkageRuleTriggerDailyTimerCondition;
        /**
         * Specifies the condition triggered upon the property of device. It is
         * required when type is `DEVICE_DATA`. The deviceDataCondition structure is
         * documented below.
         */
        deviceDataCondition: outputs.IoTDA.DeviceLinkageRuleTriggerDeviceDataCondition;
        /**
         * Specifies the condition triggered by policy. It is required when type
         * is `SIMPLE_TIMER`. The simpleTimerCondition structure is documented below.
         */
        simpleTimerCondition: outputs.IoTDA.DeviceLinkageRuleTriggerSimpleTimerCondition;
        /**
         * Specifies the type of the alarm. The options are as follows:
         * + **fault**: Report alarms.
         * + **recovery**: Clear alarms.
         */
        type: string;
    }

    export interface DeviceLinkageRuleTriggerDailyTimerCondition {
        /**
         * Specifies a list of days of week, separated by commas. 1 represents Sunday,
         * 2 represents Monday, and so on. Defaults to `1,2,3,4,5,6,7` (every day).
         */
        daysOfWeek: string;
        /**
         * Specifies the start time, in the format: `HH:mm`.
         * For example: `03:00`.
         */
        startTime: string;
    }

    export interface DeviceLinkageRuleTriggerDeviceDataCondition {
        /**
         * Specifies data validity period, Unit is `seconds`. Defaults to `300`.
         * For example, if Data Validity Period is set to 30 minutes, a device generates data at 19:00, and the platform receives
         * the data at 20:00, the action is nottriggered regardless of whether the conditions are met.
         */
        dataValidatiyPeriod?: number;
        /**
         * Specifies the device id which excutes the command.
         */
        deviceId?: string;
        /**
         * Specifies the data comparison operator. The valid values are: **>**, **<**,
         * **>=**, **<=**, **=** and **between**.
         */
        operator: string;
        /**
         * Specifies the path of the device property, in the format: **service_id/DataProperty**.
         */
        path: string;
        /**
         * Specifies the product id, all devices belonging to this product will trigger
         * the rule. Exactly one of `deviceId` or `productId` must be provided.
         */
        productId?: string;
        /**
         * Specifies the trigger strategy. The options are as follows:
         * + **pulse**: When the data reported by the device meets the conditions, the rule can be triggered.
         * + **reverse**: Repetition suppression. For example, if an alarm is configured to be triggered when the battery level
         * is lower than 20%, the alarm will be triggered once the battery initially drops below 20% but will not be triggered
         * again each time the battery drops to a lower level.
         */
        triggerStrategy: string;
        /**
         * Specifies the Rvalue of a data comparison expression. When the `operator` is `between`,
         * the Rvalue represents the minimum and maximum values, separated by commas, such as "20,30",
         * which means greater than or equal to 20 and less than 30.
         */
        value: string;
    }

    export interface DeviceLinkageRuleTriggerSimpleTimerCondition {
        /**
         * Specifies total number of repetition.
         */
        repeatCount: number;
        /**
         * Specifies the interval of repetition, Unit is `minutes`.
         */
        repeatInterval: number;
        /**
         * Specifies the start time, in the format: `HH:mm`.
         * For example: `03:00`.
         */
        startTime: string;
    }

    export interface ProductService {
        /**
         * Specifies the list of commands for the service.
         * The commands structure is documented below.
         */
        commands: outputs.IoTDA.ProductServiceCommand[];
        /**
         * Specifies the description of the parameter. The description contains a maximum of
         * 128 characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following specail
         * characters are allowed: `?'#().,&%@!`.
         */
        description: string;
        /**
         * Specifies the service ID. The ID contains a maximum of 64 characters. Only letters,
         * Chinese characters, digits, hyphens (-), underscores (_) and the following specail characters are allowed: `?'#().,&%@!`.
         */
        id: string;
        /**
         * Specifies the list of properties for the service.
         * The properties structure is documented below.
         */
        properties: outputs.IoTDA.ProductServiceProperty[];
        /**
         * Specifies the type of the parameter.
         * The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
         */
        type: string;
    }

    export interface ProductServiceCommand {
        /**
         * Specifies the name of the parameter. The name contains a maximum of 64 characters.
         * Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following specail characters are
         * allowed: `?'#().,&%@!`.
         */
        name: string;
        /**
         * Specifies the list of parameters for the command.
         * The paras structure is documented below.
         */
        paras: outputs.IoTDA.ProductServiceCommandPara[];
        /**
         * Specifies the list of responses for the command.
         * The responses structure is documented below.
         */
        responses: outputs.IoTDA.ProductServiceCommandResponse[];
    }

    export interface ProductServiceCommandPara {
        /**
         * Specifies the description of the parameter. The description contains a maximum of
         * 128 characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following specail
         * characters are allowed: `?'#().,&%@!`.
         */
        description: string;
        enumLists: string[];
        /**
         * Specifies the max value of the parameter when the `type` is **int** or **decimal**.
         * Value range: -2147483647 ~ 2147483647. Defaults to **"65535"**.
         */
        max?: string;
        /**
         * Specifies the max length of the parameter when the `type` is **string**, **DateTime**,
         * **jsonObject** or **string list**. Value range: 0 ~ 2147483647. Defaults to **0**.
         */
        maxLength: number;
        /**
         * Specifies the min value of the parameter when the `type` is **int** or **decimal**.
         * Value range: -2147483647 ~ 2147483647. Defaults to **"0"**.
         */
        min?: string;
        /**
         * Specifies the name of the parameter. The name contains a maximum of 64 characters.
         * Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following specail characters are
         * allowed: `?'#().,&%@!`.
         */
        name: string;
        /**
         * Specifies the step of the parameter when the `type` is **int** or **decimal**.
         * Value range: 0 ~ 2147483647. Defaults to **0**.
         */
        step: number;
        /**
         * Specifies the type of the parameter.
         * The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
         */
        type: string;
        /**
         * Specifies the unit of the parameter when the `type` is **int** or **decimal**.
         * The unit contains a maximum of 16 characters.
         */
        unit: string;
    }

    export interface ProductServiceCommandResponse {
        /**
         * Specifies the description of the parameter. The description contains a maximum of
         * 128 characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following specail
         * characters are allowed: `?'#().,&%@!`.
         */
        description: string;
        enumLists: string[];
        /**
         * Specifies the max value of the parameter when the `type` is **int** or **decimal**.
         * Value range: -2147483647 ~ 2147483647. Defaults to **"65535"**.
         */
        max?: string;
        /**
         * Specifies the max length of the parameter when the `type` is **string**, **DateTime**,
         * **jsonObject** or **string list**. Value range: 0 ~ 2147483647. Defaults to **0**.
         */
        maxLength: number;
        /**
         * Specifies the min value of the parameter when the `type` is **int** or **decimal**.
         * Value range: -2147483647 ~ 2147483647. Defaults to **"0"**.
         */
        min?: string;
        /**
         * Specifies the name of the parameter. The name contains a maximum of 64 characters.
         * Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following specail characters are
         * allowed: `?'#().,&%@!`.
         */
        name: string;
        /**
         * Specifies the step of the parameter when the `type` is **int** or **decimal**.
         * Value range: 0 ~ 2147483647. Defaults to **0**.
         */
        step: number;
        /**
         * Specifies the type of the parameter.
         * The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
         */
        type: string;
        /**
         * Specifies the unit of the parameter when the `type` is **int** or **decimal**.
         * The unit contains a maximum of 16 characters.
         */
        unit: string;
    }

    export interface ProductServiceProperty {
        /**
         * Specifies the description of the parameter. The description contains a maximum of
         * 128 characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following specail
         * characters are allowed: `?'#().,&%@!`.
         */
        description: string;
        enumLists: string[];
        /**
         * Specifies the max value of the parameter when the `type` is **int** or **decimal**.
         * Value range: -2147483647 ~ 2147483647. Defaults to **"65535"**.
         */
        max?: string;
        /**
         * Specifies the max length of the parameter when the `type` is **string**, **DateTime**,
         * **jsonObject** or **string list**. Value range: 0 ~ 2147483647. Defaults to **0**.
         */
        maxLength: number;
        method: string;
        /**
         * Specifies the min value of the parameter when the `type` is **int** or **decimal**.
         * Value range: -2147483647 ~ 2147483647. Defaults to **"0"**.
         */
        min?: string;
        /**
         * Specifies the name of the parameter. The name contains a maximum of 64 characters.
         * Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following specail characters are
         * allowed: `?'#().,&%@!`.
         */
        name: string;
        /**
         * Specifies the step of the parameter when the `type` is **int** or **decimal**.
         * Value range: 0 ~ 2147483647. Defaults to **0**.
         */
        step: number;
        /**
         * Specifies the type of the parameter.
         * The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
         */
        type: string;
        /**
         * Specifies the unit of the parameter when the `type` is **int** or **decimal**.
         * The unit contains a maximum of 16 characters.
         */
        unit: string;
    }

}

export namespace Live {
    export interface RecordingFlv {
        /**
         * Specifies the path and file name prefix of a recording file. The default value is
         * `Record/{publish_domain}/{app}/{record_type}/{record_format}/{stream}_{file_start_time}/{file_start_time}`.
         */
        fileNaming: string;
        /**
         * Specifies the interval threshold for combining recording chunks. If the
         * stream pause length exceeds the value of this parameter, a new recording is generated.
         * Value range: 0 ~ 300, unit: `second`.
         * If the value is set to `0`, a new file will be generated once the stream is interrupted. Defaults to `0`.
         */
        maxStreamPauseLength: number;
        /**
         * Specifies the recording length. Value range: 15 ~ 180, unit: `minute`.
         * A stream exceeding the recording length will generate a new recording.
         */
        recordingLength: number;
    }

    export interface RecordingHls {
        /**
         * Specifies the path and file name prefix of a recording file. The default value is
         * `Record/{publish_domain}/{app}/{record_type}/{record_format}/{stream}_{file_start_time}/{file_start_time}`.
         */
        fileNaming: string;
        /**
         * Specifies the interval threshold for combining recording chunks. If the
         * stream pause length exceeds the value of this parameter, a new recording is generated.
         * Value range: 0 ~ 300, unit: `second`.
         * If the value is set to `0`, a new file will be generated once the stream is interrupted. Defaults to `0`.
         */
        maxStreamPauseLength: number;
        /**
         * Specifies the recording length. Value range: 15 ~ 180, unit: `minute`.
         * A stream exceeding the recording length will generate a new recording.
         */
        recordingLength: number;
        /**
         * Specifies TS file name prefix.
         * The default value is `{file_start_time_unix}_{file_end_time_unix}_{ts_sequence_number}`.
         */
        tsFileNaming: string;
    }

    export interface RecordingMp4 {
        /**
         * Specifies the path and file name prefix of a recording file. The default value is
         * `Record/{publish_domain}/{app}/{record_type}/{record_format}/{stream}_{file_start_time}/{file_start_time}`.
         */
        fileNaming: string;
        /**
         * Specifies the interval threshold for combining recording chunks. If the
         * stream pause length exceeds the value of this parameter, a new recording is generated.
         * Value range: 0 ~ 300, unit: `second`.
         * If the value is set to `0`, a new file will be generated once the stream is interrupted. Defaults to `0`.
         */
        maxStreamPauseLength: number;
        /**
         * Specifies the recording length. Value range: 15 ~ 180, unit: `minute`.
         * A stream exceeding the recording length will generate a new recording.
         */
        recordingLength: number;
    }

    export interface RecordingObs {
        /**
         * Specifies OBS bucket.
         */
        bucket: string;
        /**
         * Specifies OBS object path. If omitted, recordings will be saved to the root directory.
         */
        object: string;
        /**
         * Specifies the region of OBS.
         */
        region: string;
    }

    export interface TranscodingTemplate {
        /**
         * Specifies the bitrate of a transcoded video, in kbit/s. Value range: 40 ~ 30000.
         */
        bitrate: number;
        /**
         * Specifies the frame rate of the transcoded video, in fps. Value range: 0 ~ 30.
         * Value 0 indicates that the frame rate remains unchanged.
         */
        frameRate: number;
        /**
         * Specifies video height (unit: pixel).
         * + **When the video encoding is H264**, value range: 32 ~ 2160 and must be a multiple of 2.
         * + **When the video encoding is H265**, value range: 240 ~ 2160 and must be a multiple of 4.
         */
        height: number;
        /**
         * Specifies the template name. The name can contain a maximum of 64 characters, and only
         * contains letters, digits and hyphens (-).
         */
        name: string;
        /**
         * Specifies video width (unit: pixel).
         * + **When the video encoding is H264**, value range: 32 ~ 3840 and must be a multiple of 2.
         * + **When the video encoding is H265**, value range: 320 ~ 3840 and must be a multiple of 4.
         */
        width: number;
    }

}

export namespace Meeting {
    export interface ConferenceConfiguration {
        /**
         * Specifies whether to allow guests to start conferences (only valid for random
         * ID conferences).
         */
        allowGuestStart: boolean;
        /**
         * Specifies the range to allow incoming calls.
         * + **0**: All users.
         * + **2**: Users within the enterprise.
         * + **3**: The invited user.
         */
        callinRestriction: number;
        /**
         * Specifies the guest password (pure number which is 4 to 16 digits long).
         */
        guestPassword: string;
        /**
         * Specifies whether the soft terminal is automatically muted when the guest joins the
         * conference.
         */
        isAutoMute: boolean;
        /**
         * Specifies whether the guest is password-free (only valid for random
         * conferences).
         */
        isGuestFreePassword: boolean;
        /**
         * Specifies whether the guest joins the conference, whether the hard
         * terminal is automatically muted.
         */
        isHardTerminalAutoMute: boolean;
        /**
         * Specifies whether to send conference calendar notifications.
         */
        isSendCalendar: boolean;
        /**
         * Specifies whether to send conference email notification.
         */
        isSendNotify: boolean;
        /**
         * Specifies whether to send conference SMS notification.
         */
        isSendSms: boolean;
        /**
         * Specifies the Automatically extend duration, the valid value is range from `0` to
         * `60`.
         */
        prolongTime: number;
        /**
         * Specifies whether to open the waiting room (only valid for RTC enterprises).
         */
        waitingRoomEnabled: boolean;
    }

    export interface ConferenceCycleParams {
        /**
         * Specifies the period type. The valid values are as follows:
         * + **Day**
         * + **Week**
         * + **Month**
         */
        cycle: string;
        /**
         * Specifies the end date of the recurring conference.
         * The format is `YYYY-MM-DD`.
         */
        endDate: string;
        /**
         * Specifies the cycle interval.
         * For different `cycle` types, the value range of interval are as follows:
         * + **Day**: Means that it will be held every few days, and the valid value is range from `1` to `15`.
         * + **Week**: Means that it is held every few weeks, and the valid value is range from `1` to `5`.
         * + **Month**: Means every few months, the value range is `1` to `3`.
         */
        interval: number;
        /**
         * Specifies the conference point in the cycle. Only valid by **Week** and **Month**.
         * For different `cycle` types, the value range of elements are as follows:
         * + **Week**: The valid value is range from `0` to `6`. The **0** means Sunday, **6** means Saturday.
         * + **Month**: The valid range for the elements is `1` to `31`. If the value does not exist in the current month, the
         * value means the end of the month.
         */
        points: number[];
        /**
         * Specifies the number of days for advance conference notice.
         * The valid value is range from `0` to `30`, defaults to `1`.
         */
        preRemind: number;
        /**
         * Specifies the start date of the recurring conference.
         * The format is `YYYY-MM-DD`.
         */
        startDate: string;
    }

    export interface ConferenceJoinPassword {
        guest: string;
        host: string;
    }

    export interface ConferenceParticipant {
        /**
         * Specifies the account ID of the participant.
         */
        accountId: string;
        /**
         * Specifies the email address.
         */
        email: string;
        /**
         * Specifies whether to automatically invite this participant when the conference
         * starts. The valid values are as follows:
         * + **0**: Do not automatically invite.
         * + **1**: Automatic invitation.
         */
        isAutoInvite: number;
        /**
         * Specifies whether the user needs to be automatically muted when joining the conference
         * (only effective when invited in the conference). The valid values are as follows:
         * + **0**: No mute.
         * + **1**: Mute.
         */
        isMute: number;
        /**
         * Specifies the attendee name or nickname.
         */
        name: string;
        /**
         * Specifies the SIP or TEL number, maximum of 127 characters.
         */
        phone: string;
        /**
         * Specifies the role in the conference. The valid values are as follows:
         * + **0**: Normal attendee.
         * + **1**: The conference chair.
         */
        role: number;
        /**
         * Specifies the mobile number for SMS notification, maximum of 32 characters.
         */
        sms: string;
        /**
         * Specifies the call-in type. The valid values are as follows:
         * + **normal**: The soft terminal.
         * + **terminal**: The conference room or hard terminal.
         * + **outside**: The outside participant.
         * + **mobile**: The user's landline phone.
         * + **ideahub**: The ideahub.
         */
        type: string;
        /**
         * Specifies the user ID of the participant.
         */
        userId: string;
    }

    export interface ConferenceSubconference {
        /**
         * The sub-conference end time.
         */
        endTime: string;
        /**
         * The sub-conference ID.
         */
        id: string;
        /**
         * Specifies whether the conference automatically starts recording, it only takes
         * effect when the recording type is:
         * + **1**: Automatically start recording.
         * + **0**: Do not start recording automatically.
         */
        isAutoRecord: number;
        /**
         * Specifies the conference media type list.
         * It consists of one or more enumerations, and the valid values are as follows:
         * + **Voice**: Voice.
         * + **Video**: SD video.
         * + **HDVideo**: High-definition video (mutually exclusive with Video, if Video and HDVideo are selected at the same
         * time, the system will select Video by default).
         * + **Data**: Multimedia (If omitted, the system configuration will determines whether to automatically add **Data**).
         */
        mediaTypes: string[];
        /**
         * Specifies the recording authentication method.
         * **0**: Viewable/downloadable via link.
         * **1**: Enterprise users can watch/download.
         * **2**: Attendees can watch/download.
         */
        recordAuthType: number;
        /**
         * Specifies the conference start time (UTC time).
         * The time format is `YYYY-MM-DD hh:mm`, e.g. `2006-01-02 15:04`.
         * There is no need to set if you book a cyclical conference.
         */
        startTime: string;
        /**
         * The other configuration information of periodic subconferences.
         * The object structure is documented below.
         */
        subconfigurations: outputs.Meeting.ConferenceSubconferenceSubconfiguration[];
    }

    export interface ConferenceSubconferenceSubconfiguration {
        /**
         * Specifies whether to allow guests to start conferences (only valid for random
         * ID conferences).
         */
        allowGuestStart: boolean;
        /**
         * The range that the webinar audience is allowed to call in.
         * The valid values are as follows:
         * + **0**: All users.
         * + **2**: Users within the enterprise.
         */
        audienceCallinRestriction: number;
        /**
         * Specifies the range to allow incoming calls.
         * + **0**: All users.
         * + **2**: Users within the enterprise.
         * + **3**: The invited user.
         */
        callinRestriction: number;
        showAudiencePolicies: outputs.Meeting.ConferenceSubconferenceSubconfigurationShowAudiencePolicy[];
        /**
         * Specifies whether to open the waiting room (only valid for RTC enterprises).
         */
        waitingRoomEnabled: boolean;
    }

    export interface ConferenceSubconferenceSubconfigurationShowAudiencePolicy {
        /**
         * Specifies the basic number of people, the valid values is range from `0` to `10,000`.
         */
        baseAudienceCount: number;
        /**
         * Audience display strategy: The server is used to calculate the number of audiences and send it to the client
         * to control the audience display.
         * + **0**: Do not display.
         * + **1**: Multiply display the number of participants, based on the real-time number of participants or the cumulative
         * number of participants, the multiplication setting can be performed.
         */
        mode: number;
        /**
         * Specifies the multiplier. The valid values is range from `0` to `10`, it can be set to 1 decimal place.
         */
        multiple: number;
    }

}

export namespace ModelArts {
    export interface DatasetDataSource {
        /**
         * Specifies the cluster ID of DWS/MRS when `dataType` is `1` or `4`.
         * Changing this parameter will create a new resource.
         */
        clusterId?: string;
        /**
         * Specifies the type of data source. The options are as follows:
         * + **0**: OBS.
         * + **1**: GaussDB(DWS).
         * + **2**: DLI.
         * + **4**: MRS.
         */
        dataType?: number;
        /**
         * Specifies the database name of DWS/DLI when `dataType` is `1` or `2`.
         * Changing this parameter will create a new resource.
         */
        databaseName?: string;
        /**
         * Specifies the password of database when `dataType` is `1`.
         * Changing this parameter will create a new resource.
         */
        password?: string;
        /**
         * Specifies the OBS path when `dataType` is `0`
         * or the hdsf path when `dataType` is `4`. All the file in this directory and subdirectories will be which be imported
         * to the dataset. Changing this parameter will create a new resource.
         */
        path?: string;
        /**
         * Specifies the queue name of DLI when `dataType` is `2`.
         * Changing this parameter will create a new resource.
         */
        queueName?: string;
        /**
         * Specifies the table name of DWS/DLI when `dataType` is `1` or `2`.
         * Changing this parameter will create a new resource.
         */
        tableName?: string;
        /**
         * Specifies the user name of databse when `dataType` is `1`.
         * Changing this parameter will create a new resource.
         */
        userName?: string;
        /**
         * Specifies whether the data contains table header when the type
         * of dataset is `400`(Table type). Default value is `true`. Changing this parameter will create a new resource.
         */
        withColumnHeader?: boolean;
    }

    export interface DatasetLabel {
        /**
         * Specifies the name of label.
         */
        name: string;
        /**
         * Specifies color of label.
         */
        propertyColor: string;
        /**
         * Specifies shape of label. Valid values include: `bndbox`, `polygon`,
         * `circle`, `line`, `dashed`, `point`, `polyline`.
         */
        propertyShape: string;
        /**
         * Specifies shortcut of label.
         */
        propertyShortcut: string;
    }

    export interface DatasetLabelFormat {
        /**
         * Specifies the separator between label and label.
         * Changing this parameter will create a new resource.
         */
        labelSeparator?: string;
        /**
         * Specifies the separator between text and label.
         * Changing this parameter will create a new resource.
         */
        textLabelSeparator?: string;
        /**
         * Specifies Label type for text classification.
         * The optional values are as follows:
         */
        type?: string;
    }

    export interface DatasetSchema {
        /**
         * Specifies the name of label.
         */
        name: string;
        /**
         * Specifies Label type for text classification.
         * The optional values are as follows:
         */
        type: string;
    }

    export interface GetDataset_versionsVersion {
        /**
         * The creation time, in UTC format.
         */
        createdAt: string;
        /**
         * The description of the dataset version.
         */
        description: string;
        /**
         * The total number of samples.
         */
        files: number;
        /**
         * The ID of the dataset version.
         */
        id: string;
        /**
         * Whether this version is current version.
         */
        isCurrent: boolean;
        /**
         * Specifies the name of the dataset version.
         */
        name: string;
        /**
         * Specifies the range of splitting ratio which randomly divides a labeled sample
         * into a training set and a validation set. Separate the minimum and maximum split ratios with commas,
         * for example: "0.0,1.0".
         */
        splitRatio: string;
        /**
         * Dataset version status. Valid values are as follows:
         * + **0**: Creating.
         * + **1**: Normal.
         * + **2**: Deleting.
         * + **3**: Deleted.
         * + **4**: Exception.
         */
        status: number;
        /**
         * The path to save the manifest file of the version.
         */
        storagePath: string;
        /**
         * The last update time, in UTC format.
         */
        updatedAt: string;
    }

    export interface GetDatasetsDataset {
        /**
         * The dataset creation time.
         */
        createdAt: string;
        /**
         * The dataset format. Valid values include: `Default`, `CarbonData`: Carbon format(Supported only for
         * table type dataset.).
         */
        dataFormat: string;
        /**
         * The data sources which is used to imported the source data (such as pictures/files/audio, etc.) in
         * this directory and subdirectories to the dataset. Structure is documented below.
         */
        dataSources: outputs.ModelArts.GetDatasetsDatasetDataSource[];
        /**
         * The description of the dataset.
         */
        description: string;
        /**
         * The ID of the dataset.
         */
        id: string;
        /**
         * The labels information. Structure is documented below.
         */
        labels?: outputs.ModelArts.GetDatasetsDatasetLabel[];
        /**
         * Specifies the name of datasets.
         */
        name: string;
        /**
         * The OBS path for storing output files such as labeled files.
         */
        outputPath: string;
        /**
         * The schema information of source data when `type` is `400`(Table Type). Structure is documented below.
         */
        schemas: outputs.ModelArts.GetDatasetsDatasetSchema[];
        /**
         * Dataset status. Valid values are as follows:
         * + **0**: Creating.
         * + **1**: Completed.
         * + **2**: Deleting.
         * + **3**: Deleted.
         * + **4**: Exception.
         * + **5**: Syncing.
         * + **6**: Releasing.
         * + **7**: Version switching.
         * + **8**: Importing.
         */
        status: number;
        /**
         * Specifies the type of datasets. The options are:
         * + **0**: Image classification, supported formats: `.jpg`, `.png`, `.jpeg`, `.bmp`.
         * + **1**: Object detection, supported formats: `.jpg`, `.png`, `.jpeg`, `.bmp`.
         * + **3**: Image segmentation, supported formats: `.jpg`, `.png`, `.jpeg`, `.bmp`.
         * + **100**: Text classification, supported formats: `.txt`, `.csv`.
         * + **200**: Sound classification, Supported formats: `.wav`.
         * + **400**: Table type, supported formats: Carbon type.
         * + **600**: Video, supported formats: `.mp4`
         * + **900**: Free format.
         */
        type: number;
    }

    export interface GetDatasetsDatasetDataSource {
        /**
         * The type of data source. Valid values are as follows:
         * + *0*: OBS.
         * + *1*: GaussDB(DWS).
         * + *2*: DLI.
         * + *4*: MRS.
         */
        dataType: number;
        /**
         * The OBS path when `dataType` is `0`(OBS) or the HDFS path when `dataType` is `4`(MRS). All the file in this
         * directory and subdirectories will be which be imported to the dataset.
         */
        path: string;
        /**
         * Whether the data contains table header when the type of dataset is `400`(Table type).
         */
        withColumnHeader: boolean;
    }

    export interface GetDatasetsDatasetLabel {
        /**
         * Specifies the name of datasets.
         */
        name: string;
        /**
         * The color of label.
         */
        propertyColor: string;
        /**
         * The shape of label. Valid values include: `bndbox`, `polygon`, `circle`, `line`, `dashed`,
         * `point`, `polyline`.
         */
        propertyShape: string;
        /**
         * The shortcut of label.
         */
        propertyShortcut: string;
    }

    export interface GetDatasetsDatasetSchema {
        /**
         * Specifies the name of datasets.
         */
        name: string;
        /**
         * Specifies the type of datasets. The options are:
         * + **0**: Image classification, supported formats: `.jpg`, `.png`, `.jpeg`, `.bmp`.
         * + **1**: Object detection, supported formats: `.jpg`, `.png`, `.jpeg`, `.bmp`.
         * + **3**: Image segmentation, supported formats: `.jpg`, `.png`, `.jpeg`, `.bmp`.
         * + **100**: Text classification, supported formats: `.txt`, `.csv`.
         * + **200**: Sound classification, Supported formats: `.wav`.
         * + **400**: Table type, supported formats: Carbon type.
         * + **600**: Video, supported formats: `.mp4`
         * + **900**: Free format.
         */
        type: string;
    }

    export interface GetNotebookImagesImage {
        /**
         * Specifies the CPU architecture of image. The value can be **x86_64** and **aarch64**.
         */
        cpuArch: string;
        /**
         * The description of the image.
         */
        description: string;
        /**
         * The ID of the image.
         */
        id: string;
        /**
         * Specifies the name of image.
         */
        name: string;
        /**
         * The path the image in HuaweiCloud SWR service (SoftWare Repository for Container).
         */
        swrPath: string;
        /**
         * Specifies the type of image. The options are:
         * + `BUILD_IN`: The system built-in image.
         * + `DEDICATED`: User-saved images.
         */
        type: string;
    }

    export interface NotebookMountStorage {
        /**
         * The mount ID.
         */
        id: string;
        /**
         * The local mount path.
         */
        mountPath: string;
        /**
         * The path of storage which be mounted.
         */
        path: string;
        /**
         * The status of mount.
         */
        status: string;
        /**
         * Specifies the volume type. The options are as follows:
         * - *EFS*: use Scalable File Service, default 50GB is **free**.
         * - *EVS*: use Elastic Volume Service, default size is 5 GB.
         */
        type: string;
    }

    export interface NotebookVolume {
        /**
         * The local mount path.
         */
        mountPath: string;
        /**
         * Specifies the volume ownership. The options are as follows:
         * - *MANAGED*: shared storage disk of the ModelArts service.
         * - *DEDICATED*: dedicated storage disk, only supported when the category is `EFS`.
         */
        ownership?: string;
        /**
         * Specifies the volume size. Its value range is from 5 GB to 4096 GB.
         */
        size: number;
        /**
         * Specifies the volume type. The options are as follows:
         * - *EFS*: use Scalable File Service, default 50GB is **free**.
         * - *EVS*: use Elastic Volume Service, default size is 5 GB.
         */
        type: string;
        /**
         * Specifies the uri of dedicated storage disk, which is mandatory when the `type`
         * is `EFS` and the `ownership` is `DEDICATED`. Example: `192.168.0.1:/user-9sfdsdgdfgh5ea4d56871e75d6966aa274/mount/`.
         * Changing this parameter will create a new resource.
         */
        uri?: string;
    }
}

export namespace Mpc {
    export interface TranscodingTemplateAudio {
        /**
         * Specifies the average output bitrate. The value is 0 or an integer ranging from 40 to
         * 30,000. The default value is 0. The unit is kbit/s. If this parameter is set to 0, the average output bitrate is an
         * adaptive value.
         */
        bitrate?: number;
        /**
         * Specifies the number of audio channels. Possible values are:
         * + **1**: AUDIO_CHANNELS_1
         * + **2**: AUDIO_CHANNELS_2
         * + **6**: AUDIO_CHANNELS_5_1
         */
        channels: number;
        /**
         * Specifies the video codec. Possible values are:
         * + **1**: H.264
         * + **2**: H.265
         */
        codec: number;
        /**
         * Specifies the output policy. Possible values are **discard** and **transcode**.
         * The default value is transcode.
         */
        outputPolicy?: string;
        /**
         * Specifies the audio sampling rate. Possible values are:
         * + **1**: AUDIO_SAMPLE_AUTO
         * + **2**: AUDIO_SAMPLE_22050 (22,050 Hz)
         * + **3**: AUDIO_SAMPLE_32000 (32,000 Hz)
         * + **4**: AUDIO_SAMPLE_44100 (44,100 Hz)
         * + **5**: AUDIO_SAMPLE_48000 (48,000 Hz)
         * + **6**: AUDIO_SAMPLE_96000 (96,000 Hz)
         */
        sampleRate: number;
    }

    export interface TranscodingTemplateGroupAudio {
        /**
         * Specifies the average output bitrate. The value is 0 or an integer ranging from 40 to
         * 30,000. The default value is 0. The unit is kbit/s. If this parameter is set to 0, the average output bitrate is an
         * adaptive value.
         */
        bitrate?: number;
        /**
         * Specifies the number of audio channels. Possible values are:
         * + **1**: AUDIO_CHANNELS_1
         * + **2**: AUDIO_CHANNELS_2
         * + **6**: AUDIO_CHANNELS_5_1
         */
        channels: number;
        /**
         * Specifies the video codec. Possible values are:
         * + **1**: H.264
         * + **2**: H.265
         */
        codec: number;
        /**
         * Specifies the output policy. Possible values are **discard** and **transcode**.
         * The default value is transcode.
         */
        outputPolicy?: string;
        /**
         * Specifies the audio sampling rate. Possible values are:
         * + **1**: AUDIO_SAMPLE_AUTO
         * + **2**: AUDIO_SAMPLE_22050 (22,050 Hz)
         * + **3**: AUDIO_SAMPLE_32000 (32,000 Hz)
         * + **4**: AUDIO_SAMPLE_44100 (44,100 Hz)
         * + **5**: AUDIO_SAMPLE_48000 (48,000 Hz)
         * + **6**: AUDIO_SAMPLE_96000 (96,000 Hz)
         */
        sampleRate: number;
    }

    export interface TranscodingTemplateGroupVideo {
        /**
         * Specifies the average output bitrate. The value is 0 or an integer ranging from 40 to
         * 30,000. The default value is 0. The unit is kbit/s. If this parameter is set to 0, the average output bitrate is an
         * adaptive value.
         */
        bitrate?: number;
        /**
         * Specifies the video height. The value is 0 or a multiple of 2 from 32 to 2,880 for H.264,
         * and 0 or a multiple of 4 from 96 to 2,880 for H.265. The unit is pixel. If this parameter is set to 0, the video height
         * is an adaptive value. The default value is 0.
         */
        height?: number;
        /**
         * Specifies the video width. The value can be 0 or a multiple of 2 from 32 to 4,096 for H.264
         * and 0 or a multiple of 4 from 160 to 4,096 for H.265. The unit is pixel. If this parameter is set to 0, the video width
         * is an adaptive value. The default value is 0.
         */
        width?: number;
    }

    export interface TranscodingTemplateGroupVideoCommon {
        /**
         * Specifies whether to enable black bar removal. Possible values are:
         * + **0**: Disable black bar removal.
         * + **1**: Enable black bar removal and low-complexity algorithms for long videos (>5 minutes).
         * + **2**: Enable black bar removal and high-complexity algorithms for short videos (≤5 minutes).
         */
        blackBarRemoval?: number;
        /**
         * Specifies the video codec. Possible values are:
         * + **1**: H.264
         * + **2**: H.265
         */
        codec?: number;
        /**
         * Specifies the frame rate. Its value is 0 or an integer ranging from 5 to 30.
         * The default value is 0. The unit is FPS.
         */
        fps?: number;
        /**
         * Specifies the encoding level. Possible values are:
         * + **1**: VIDEO_LEVEL_1_0
         * + **2**: VIDEO_LEVEL_1_1
         * + **3**: VIDEO_LEVEL_1_2
         * + **4**: VIDEO_LEVEL_1_3
         * + **5**: VIDEO_LEVEL_2_0
         * + **6**: VIDEO_LEVEL_2_1
         * + **7**: VIDEO_LEVEL_2_2
         * + **8**: VIDEO_LEVEL_3_0
         * + **9**: VIDEO_LEVEL_3_1
         * + **10**: VIDEO_LEVEL_3_2
         * + **11**: VIDEO_LEVEL_4_0
         * + **12**: VIDEO_LEVEL_4_1
         * + **13**: VIDEO_LEVEL_4_2
         * + **14**: VIDEO_LEVEL_5_0
         * + **15**: VIDEO_LEVEL_5_1
         */
        level?: number;
        /**
         * Specifies the maximum number of B-frames.
         * The vaule range is  0 to 7, and the default value is 4. The unit is frame.
         */
        maxConsecutiveBframes?: number;
        /**
         * Specifies the mximum I-frame interval. The value ranges from 2 to 10.
         * The default value is 5. The unit is second.
         */
        maxIframesInterval?: number;
        /**
         * Specifies the maximum reference frames. When the `codec` is H.264,
         * the vaule rang is 1 to 8. When the `codec` is H.265, the value is fixed at 4. The default value is 4. The unit is frame.
         */
        maxReferenceFrames?: number;
        /**
         * Specifies the output policy. Possible values are **discard** and **transcode**.
         * The default value is transcode.
         */
        outputPolicy?: string;
        /**
         * Specifies the encoding profile. The recommended value is 3. Possible values are:
         * + **1**: VIDEO_PROFILE_H264_BASE
         * + **2**: VIDEO_PROFILE_H264_MAIN
         * + **3**: VIDEO_PROFILE_H264_HIGH
         * + **4**: VIDEO_PROFILE_H265_MAIN
         */
        profile?: number;
        /**
         * Specifies the encoding quality. A larger value indicates higher encoding quality and
         * longer transcoding time. Possible values are:
         * + **1**: VIDEO_PRESET_HSPEED2
         * + **2**: VIDEO_PRESET_HSPEED
         * + **3**: VIDEO_PRESET_NORMAL
         */
        quality?: number;
    }

    export interface TranscodingTemplateVideo {
        /**
         * Specifies the average output bitrate. The value is 0 or an integer ranging from 40 to
         * 30,000. The default value is 0. The unit is kbit/s. If this parameter is set to 0, the average output bitrate is an
         * adaptive value.
         */
        bitrate?: number;
        /**
         * Specifies whether to enable black bar removal. Possible values are:
         * + **0**: Disable black bar removal.
         * + **1**: Enable black bar removal and low-complexity algorithms for long videos (>5 minutes).
         * + **2**: Enable black bar removal and high-complexity algorithms for short videos (≤5 minutes).
         */
        blackBarRemoval?: number;
        /**
         * Specifies the video codec. Possible values are:
         * + **1**: H.264
         * + **2**: H.265
         */
        codec?: number;
        /**
         * Specifies the frame rate. Its value is 0 or an integer ranging from 5 to 30.
         * The default value is 0. The unit is FPS.
         */
        fps?: number;
        /**
         * Specifies the video height. The value is 0 or a multiple of 2 from 32 to 2,880 for H.264,
         * and 0 or a multiple of 4 from 96 to 2,880 for H.265. The unit is pixel. If this parameter is set to 0, the video height
         * is an adaptive value. The default value is 0.
         */
        height?: number;
        /**
         * Specifies the encoding level. Possible values are:
         * + **1**: VIDEO_LEVEL_1_0
         * + **2**: VIDEO_LEVEL_1_1
         * + **3**: VIDEO_LEVEL_1_2
         * + **4**: VIDEO_LEVEL_1_3
         * + **5**: VIDEO_LEVEL_2_0
         * + **6**: VIDEO_LEVEL_2_1
         * + **7**: VIDEO_LEVEL_2_2
         * + **8**: VIDEO_LEVEL_3_0
         * + **9**: VIDEO_LEVEL_3_1
         * + **10**: VIDEO_LEVEL_3_2
         * + **11**: VIDEO_LEVEL_4_0
         * + **12**: VIDEO_LEVEL_4_1
         * + **13**: VIDEO_LEVEL_4_2
         * + **14**: VIDEO_LEVEL_5_0
         * + **15**: VIDEO_LEVEL_5_1
         */
        level?: number;
        /**
         * Specifies the maximum number of B-frames.
         * The vaule range is  0 to 7, and the default value is 4. The unit is frame.
         */
        maxConsecutiveBframes?: number;
        /**
         * Specifies the mximum I-frame interval. The value ranges from 2 to 10.
         * The default value is 5. The unit is second.
         */
        maxIframesInterval?: number;
        /**
         * Specifies the maximum reference frames. When the `codec` is H.264,
         * the vaule rang is 1 to 8. When the `codec` is H.265, the value is fixed at 4. The default value is 4. The unit is frame.
         */
        maxReferenceFrames?: number;
        /**
         * Specifies the output policy. Possible values are **discard** and **transcode**.
         * The default value is transcode.
         */
        outputPolicy?: string;
        /**
         * Specifies the encoding profile. The recommended value is 3. Possible values are:
         * + **1**: VIDEO_PROFILE_H264_BASE
         * + **2**: VIDEO_PROFILE_H264_MAIN
         * + **3**: VIDEO_PROFILE_H264_HIGH
         * + **4**: VIDEO_PROFILE_H265_MAIN
         */
        profile?: number;
        /**
         * Specifies the encoding quality. A larger value indicates higher encoding quality and
         * longer transcoding time. Possible values are:
         * + **1**: VIDEO_PRESET_HSPEED2
         * + **2**: VIDEO_PRESET_HSPEED
         * + **3**: VIDEO_PRESET_NORMAL
         */
        quality?: number;
        /**
         * Specifies the video width. The value can be 0 or a multiple of 2 from 32 to 4,096 for H.264
         * and 0 or a multiple of 4 from 160 to 4,096 for H.265. The unit is pixel. If this parameter is set to 0, the video width
         * is an adaptive value. The default value is 0.
         */
        width?: number;
    }

}

export namespace Mrs {
    export interface ClusterAnalysisCoreNodes {
        /**
         * Specifies the roles deployed in a node group.This argument is mandatory
         * when the cluster type is CUSTOM. Each character string represents a role expression.
         */
        assignedRoles?: string[];
        /**
         * Specifies the data disk number of the nodes. The number configuration
         * of each node are as follows:
         * + master_nodes: 1.
         * + analysis_core_nodes: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + streaming_core_nodes: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + analysis_task_nodes: minimum is zero and the maximum is subject to the configuration of the corresponding flavor.
         * + streaming_task_nodes: minimum is zero and the maximum is subject to the configuration of the corresponding flavor.
         */
        dataVolumeCount: number;
        /**
         * Specifies the data disk size of the nodes,in GB. The value range is 10
         * to 32768. Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce
         * cluster resource.
         */
        dataVolumeSize?: number;
        /**
         * Specifies the data disk flavor of the nodes.
         * Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce cluster resource.
         * The following disk types are supported:
         * + `SATA`: common I/O disk
         * + `SAS`: high I/O disk
         * + `SSD`: ultra-high I/O disk
         */
        dataVolumeType?: string;
        /**
         * Specifies the instance specifications for each nodes in node group.
         * Changing this will create a new MapReduce cluster resource.
         */
        flavor: string;
        /**
         * The host list of this nodes group in the cluster.
         */
        hostIps: string[];
        /**
         * Specifies the number of nodes for the node group.
         */
        nodeNumber: number;
        /**
         * Specifies the system disk size of the nodes. Changing this will create
         * a new MapReduce cluster resource.
         */
        rootVolumeSize: number;
        /**
         * Specifies the system disk flavor of the nodes. Changing this will
         * create a new MapReduce cluster resource.
         */
        rootVolumeType: string;
    }

    export interface ClusterAnalysisTaskNodes {
        /**
         * Specifies the roles deployed in a node group.This argument is mandatory
         * when the cluster type is CUSTOM. Each character string represents a role expression.
         */
        assignedRoles?: string[];
        /**
         * Specifies the data disk number of the nodes. The number configuration
         * of each node are as follows:
         * + master_nodes: 1.
         * + analysis_core_nodes: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + streaming_core_nodes: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + analysis_task_nodes: minimum is zero and the maximum is subject to the configuration of the corresponding flavor.
         * + streaming_task_nodes: minimum is zero and the maximum is subject to the configuration of the corresponding flavor.
         */
        dataVolumeCount: number;
        /**
         * Specifies the data disk size of the nodes,in GB. The value range is 10
         * to 32768. Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce
         * cluster resource.
         */
        dataVolumeSize?: number;
        /**
         * Specifies the data disk flavor of the nodes.
         * Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce cluster resource.
         * The following disk types are supported:
         * + `SATA`: common I/O disk
         * + `SAS`: high I/O disk
         * + `SSD`: ultra-high I/O disk
         */
        dataVolumeType?: string;
        /**
         * Specifies the instance specifications for each nodes in node group.
         * Changing this will create a new MapReduce cluster resource.
         */
        flavor: string;
        /**
         * The host list of this nodes group in the cluster.
         */
        hostIps: string[];
        /**
         * Specifies the number of nodes for the node group.
         */
        nodeNumber: number;
        /**
         * Specifies the system disk size of the nodes. Changing this will create
         * a new MapReduce cluster resource.
         */
        rootVolumeSize: number;
        /**
         * Specifies the system disk flavor of the nodes. Changing this will
         * create a new MapReduce cluster resource.
         */
        rootVolumeType: string;
    }

    export interface ClusterCustomNode {
        /**
         * Specifies the roles deployed in a node group.This argument is mandatory
         * when the cluster type is CUSTOM. Each character string represents a role expression.
         */
        assignedRoles?: string[];
        /**
         * Specifies the data disk number of the nodes. The number configuration
         * of each node are as follows:
         * + master_nodes: 1.
         * + analysis_core_nodes: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + streaming_core_nodes: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + analysis_task_nodes: minimum is zero and the maximum is subject to the configuration of the corresponding flavor.
         * + streaming_task_nodes: minimum is zero and the maximum is subject to the configuration of the corresponding flavor.
         */
        dataVolumeCount: number;
        /**
         * Specifies the data disk size of the nodes,in GB. The value range is 10
         * to 32768. Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce
         * cluster resource.
         */
        dataVolumeSize?: number;
        /**
         * Specifies the data disk flavor of the nodes.
         * Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce cluster resource.
         * The following disk types are supported:
         * + `SATA`: common I/O disk
         * + `SAS`: high I/O disk
         * + `SSD`: ultra-high I/O disk
         */
        dataVolumeType?: string;
        /**
         * Specifies the instance specifications for each nodes in node group.
         * Changing this will create a new MapReduce cluster resource.
         */
        flavor: string;
        /**
         * Specifies the name of nodes for the node group.
         */
        groupName: string;
        /**
         * The host list of this nodes group in the cluster.
         */
        hostIps: string[];
        /**
         * Specifies the number of nodes for the node group.
         */
        nodeNumber: number;
        /**
         * Specifies the system disk size of the nodes. Changing this will create
         * a new MapReduce cluster resource.
         */
        rootVolumeSize: number;
        /**
         * Specifies the system disk flavor of the nodes. Changing this will
         * create a new MapReduce cluster resource.
         */
        rootVolumeType: string;
    }

    export interface ClusterMasterNodes {
        /**
         * Specifies the roles deployed in a node group.This argument is mandatory
         * when the cluster type is CUSTOM. Each character string represents a role expression.
         */
        assignedRoles?: string[];
        /**
         * Specifies the data disk number of the nodes. The number configuration
         * of each node are as follows:
         * + master_nodes: 1.
         * + analysis_core_nodes: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + streaming_core_nodes: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + analysis_task_nodes: minimum is zero and the maximum is subject to the configuration of the corresponding flavor.
         * + streaming_task_nodes: minimum is zero and the maximum is subject to the configuration of the corresponding flavor.
         */
        dataVolumeCount: number;
        /**
         * Specifies the data disk size of the nodes,in GB. The value range is 10
         * to 32768. Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce
         * cluster resource.
         */
        dataVolumeSize?: number;
        /**
         * Specifies the data disk flavor of the nodes.
         * Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce cluster resource.
         * The following disk types are supported:
         * + `SATA`: common I/O disk
         * + `SAS`: high I/O disk
         * + `SSD`: ultra-high I/O disk
         */
        dataVolumeType?: string;
        /**
         * Specifies the instance specifications for each nodes in node group.
         * Changing this will create a new MapReduce cluster resource.
         */
        flavor: string;
        /**
         * The host list of this nodes group in the cluster.
         */
        hostIps: string[];
        /**
         * Specifies the number of nodes for the node group.
         */
        nodeNumber: number;
        /**
         * Specifies the system disk size of the nodes. Changing this will create
         * a new MapReduce cluster resource.
         */
        rootVolumeSize: number;
        /**
         * Specifies the system disk flavor of the nodes. Changing this will
         * create a new MapReduce cluster resource.
         */
        rootVolumeType: string;
    }

    export interface ClusterStreamingCoreNodes {
        /**
         * Specifies the roles deployed in a node group.This argument is mandatory
         * when the cluster type is CUSTOM. Each character string represents a role expression.
         */
        assignedRoles?: string[];
        /**
         * Specifies the data disk number of the nodes. The number configuration
         * of each node are as follows:
         * + master_nodes: 1.
         * + analysis_core_nodes: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + streaming_core_nodes: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + analysis_task_nodes: minimum is zero and the maximum is subject to the configuration of the corresponding flavor.
         * + streaming_task_nodes: minimum is zero and the maximum is subject to the configuration of the corresponding flavor.
         */
        dataVolumeCount: number;
        /**
         * Specifies the data disk size of the nodes,in GB. The value range is 10
         * to 32768. Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce
         * cluster resource.
         */
        dataVolumeSize?: number;
        /**
         * Specifies the data disk flavor of the nodes.
         * Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce cluster resource.
         * The following disk types are supported:
         * + `SATA`: common I/O disk
         * + `SAS`: high I/O disk
         * + `SSD`: ultra-high I/O disk
         */
        dataVolumeType?: string;
        /**
         * Specifies the instance specifications for each nodes in node group.
         * Changing this will create a new MapReduce cluster resource.
         */
        flavor: string;
        /**
         * The host list of this nodes group in the cluster.
         */
        hostIps: string[];
        /**
         * Specifies the number of nodes for the node group.
         */
        nodeNumber: number;
        /**
         * Specifies the system disk size of the nodes. Changing this will create
         * a new MapReduce cluster resource.
         */
        rootVolumeSize: number;
        /**
         * Specifies the system disk flavor of the nodes. Changing this will
         * create a new MapReduce cluster resource.
         */
        rootVolumeType: string;
    }

    export interface ClusterStreamingTaskNodes {
        /**
         * Specifies the roles deployed in a node group.This argument is mandatory
         * when the cluster type is CUSTOM. Each character string represents a role expression.
         */
        assignedRoles?: string[];
        /**
         * Specifies the data disk number of the nodes. The number configuration
         * of each node are as follows:
         * + master_nodes: 1.
         * + analysis_core_nodes: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + streaming_core_nodes: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + analysis_task_nodes: minimum is zero and the maximum is subject to the configuration of the corresponding flavor.
         * + streaming_task_nodes: minimum is zero and the maximum is subject to the configuration of the corresponding flavor.
         */
        dataVolumeCount: number;
        /**
         * Specifies the data disk size of the nodes,in GB. The value range is 10
         * to 32768. Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce
         * cluster resource.
         */
        dataVolumeSize?: number;
        /**
         * Specifies the data disk flavor of the nodes.
         * Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce cluster resource.
         * The following disk types are supported:
         * + `SATA`: common I/O disk
         * + `SAS`: high I/O disk
         * + `SSD`: ultra-high I/O disk
         */
        dataVolumeType?: string;
        /**
         * Specifies the instance specifications for each nodes in node group.
         * Changing this will create a new MapReduce cluster resource.
         */
        flavor: string;
        /**
         * The host list of this nodes group in the cluster.
         */
        hostIps: string[];
        /**
         * Specifies the number of nodes for the node group.
         */
        nodeNumber: number;
        /**
         * Specifies the system disk size of the nodes. Changing this will create
         * a new MapReduce cluster resource.
         */
        rootVolumeSize: number;
        /**
         * Specifies the system disk flavor of the nodes. Changing this will
         * create a new MapReduce cluster resource.
         */
        rootVolumeType: string;
    }

}

export namespace Obs {
    export interface BucketCorsRule {
        /**
         * Specifies the allowed header of cross-origin requests. Only CORS requests
         * matching the allowed header are valid.
         */
        allowedHeaders?: string[];
        /**
         * Specifies the acceptable operation type of buckets and objects. The methods
         * include `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
         */
        allowedMethods: string[];
        /**
         * Requests from this origin can access the bucket. Multiple matching rules are
         * allowed. One rule occupies one line, and allows one wildcard character (*) at most.
         */
        allowedOrigins: string[];
        /**
         * Specifies the exposed header in CORS responses, providing additional information
         * for clients.
         */
        exposeHeaders?: string[];
        /**
         * Specifies the duration that your browser can cache CORS responses, expressed in
         * seconds. The default value is 100.
         */
        maxAgeSeconds?: number;
    }

    export interface BucketLifecycleRule {
        /**
         * Specifies lifecycle rule status.
         */
        enabled: boolean;
        /**
         * Specifies a period when objects that have been last updated are automatically
         * deleted. (documented below).
         */
        expirations?: outputs.Obs.BucketLifecycleRuleExpiration[];
        /**
         * Unique identifier for lifecycle rules. The Rule Name contains a maximum of 255 characters.
         */
        name: string;
        /**
         * Specifies a period when noncurrent object versions are
         * automatically deleted. (documented below).
         */
        noncurrentVersionExpirations?: outputs.Obs.BucketLifecycleRuleNoncurrentVersionExpiration[];
        /**
         * Specifies a period when noncurrent object versions are
         * automatically transitioned to `WARM` or `COLD` storage class (documented below).
         */
        noncurrentVersionTransitions?: outputs.Obs.BucketLifecycleRuleNoncurrentVersionTransition[];
        /**
         * Object key prefix identifying one or more objects to which the rule applies. If omitted,
         * all objects in the bucket will be managed by the lifecycle rule. The prefix cannot start or end with a slash (/),
         * cannot have consecutive slashes (/), and cannot contain the following special characters: \:*?"<>|.
         */
        prefix?: string;
        /**
         * Specifies a period when objects that have been last updated are automatically
         * transitioned to `WARM` or `COLD` storage class (documented below).
         */
        transitions?: outputs.Obs.BucketLifecycleRuleTransition[];
    }

    export interface BucketLifecycleRuleExpiration {
        /**
         * Specifies the number of days when objects that have been last updated are automatically
         * deleted. The expiration time must be greater than the transition times.
         */
        days: number;
    }

    export interface BucketLifecycleRuleNoncurrentVersionExpiration {
        /**
         * Specifies the number of days when noncurrent object versions are automatically deleted.
         */
        days: number;
    }

    export interface BucketLifecycleRuleNoncurrentVersionTransition {
        /**
         * Specifies the number of days when noncurrent object versions are automatically transitioned
         * to the specified storage class.
         */
        days: number;
        /**
         * The class of storage used to store the object. Only `WARM` and `COLD` are
         * supported.
         */
        storageClass: string;
    }

    export interface BucketLifecycleRuleTransition {
        /**
         * Specifies the number of days when objects that have been last updated are automatically
         * transitioned to the specified storage class.
         */
        days: number;
        /**
         * The class of storage used to store the object. Only `WARM` and `COLD` are
         * supported.
         */
        storageClass: string;
    }

    export interface BucketLogging {
        /**
         * The name of the bucket that will receive the log objects. The acl policy of the
         * target bucket should be `log-delivery-write`.
         */
        targetBucket: string;
        /**
         * To specify a key prefix for log objects.
         */
        targetPrefix?: string;
    }

    export interface BucketWebsite {
        /**
         * Specifies the error page returned when an error occurs during static website
         * access. Only HTML, JPG, PNG, BMP, and WEBP files under the root directory are supported.
         */
        errorDocument?: string;
        /**
         * Unless using `redirectAllRequestsTo`. Specifies the default homepage of the
         * static website, only HTML web pages are supported. OBS only allows files such as `index.html` in the root directory of
         * a bucket to function as the default homepage. That is to say, do not set the default homepage with a multi-level
         * directory structure (for example, /page/index.html).
         */
        indexDocument?: string;
        /**
         * A hostname to redirect all website requests for this bucket to.
         * Hostname can optionally be prefixed with a protocol (`http://` or `https://`) to use when redirecting requests. The
         * default is the protocol that is used in the original request.
         */
        redirectAllRequestsTo?: string;
        /**
         * A JSON or XML format containing routing rules describing redirect behavior and
         * when redirects are applied. Each rule contains a `Condition` and a `Redirect` as shown in the following table:
         */
        routingRules?: string;
    }

    export interface GetBucketsBucket {
        /**
         * The name of the OBS bucket.
         */
        bucket: string;
        /**
         * The date when the OBS bucket was created.
         */
        createdAt: string;
        /**
         * The enterprise project id of the OBS bucket.
         */
        enterpriseProjectId: string;
        /**
         * The region in which to obtain the OBS bucket.
         * If omitted, the provider-level region will be used.
         */
        region: string;
        /**
         * The storage class of the OBS bucket.
         */
        storageClass: string;
    }

}

export namespace Oms {
    export interface MigrationTaskBandwidthPolicy {
        /**
         * Specifies the end time of the traffic limit rule. The format is **hh:mm**,
         * e.g. **12:03**.
         */
        end: string;
        /**
         * Specifies the maximum traffic bandwidth allowed in the specified time
         * segment. The unit is byte/s. The value ranges from **1** MB/s to **200** MB/s.
         */
        maxBandwidth: number;
        /**
         * Specifies the start time of the traffic limit rule. The format is **hh:mm**,
         * e.g. **12:03**.
         */
        start: string;
    }

    export interface MigrationTaskDestinationObject {
        /**
         * Specifies the access key for accessing the destination bucket.
         * Changing this creates a new resource.
         */
        accessKey?: string;
        /**
         * Specifies the name of the destination bucket.
         * Changing this creates a new resource.
         */
        bucket: string;
        /**
         * Specifies the region where the destination bucket is located.
         * Changing this creates a new resource.
         */
        region: string;
        /**
         * Specifies the path prefix in the destination bucket. The prefix is added
         * before the object key to form a new key. Changing this creates a new resource.
         */
        savePrefix?: string;
        /**
         * Specifies the secret key for accessing the destination bucket.
         * Changing this creates a new resource.
         */
        secretKey?: string;
        /**
         * Specifies the temporary token for accessing the destination bucket.
         * Changing this creates a new resource.
         */
        securityToken?: string;
    }

    export interface MigrationTaskSmnConfig {
        /**
         * Specifies the SMN message language. The value can be **zh-cn** or
         * **en-us**. Default value: **en-us**. Changing this creates a new resource.
         */
        language?: string;
        /**
         * Specifies the SMN message topic URN bound to a migration task.
         * Changing this creates a new resource.
         */
        topicUrn: string;
        /**
         * Specifies the trigger conditions of sending messages using SMN.
         * The value can be:
         * + **FAILURE**: indicates that an SMN message will be sent after the migration task fails.
         * + **SUCCESS**: indicates that an SMN message will be sent after the migration task succeeds.
         */
        triggerConditions: string[];
    }

    export interface MigrationTaskSourceCdn {
        /**
         * Specifies the CDN authentication key.
         * Changing this creates a new resource.
         */
        authenticationKey?: string;
        /**
         * Specifies the authentication type. Valid values are **NONE**,
         * **QINIU_PRIVATE_AUTHENTICATION**, **ALIYUN_OSS_A**, **ALIYUN_OSS_B**, **ALIYUN_OSS_C**,
         * **KSYUN_PRIVATE_AUTHENTICATION**. Default value: **None**. Changing this creates a new resource.
         */
        authenticationType?: string;
        /**
         * Specifies the domain name from which to obtain objects to be migrated.
         * Changing this creates a new resource.
         */
        domain: string;
        /**
         * Specifies the protocol type. Valid values are **HTTP** and **HTTPS**.
         * Changing this creates a new resource.
         */
        protocol: string;
    }

    export interface MigrationTaskSourceObject {
        /**
         * Specifies the access key for accessing the destination bucket.
         * Changing this creates a new resource.
         */
        accessKey?: string;
        /**
         * Specifies the APP ID. This parameter is mandatory when `dataSource` is  
         * **Tencent**. Changing this creates a new resource.
         */
        appId?: string;
        /**
         * Specifies the name of the destination bucket.
         * Changing this creates a new resource.
         */
        bucket?: string;
        /**
         * Specifies the source cloud service provider. If `type` is
         * **url_list**,set this parameter to **URLSource**. The value can be **AWS**, **Azure**, **Aliyun**, **Tencent**,
         * **HuaweiCloud**, **QingCloud**, **KingsoftCloud**, **Baidu**, **Qiniu**, **URLSource** and **UCloud**.
         * The default value is **Aliyun**. Changing this creates a new resource.
         */
        dataSource?: string;
        /**
         * Specifies the name of the OBS bucket for storing the object list files.
         * `listFileBucket` is mandatory when `type` is set to **list** or **url_list**. Changing this creates a new resource.
         */
        listFileBucket?: string;
        /**
         * Specifies the object name of the list file or URL list file.
         * `listFileKey` is mandatory when `type` is set to **list** or **url_list**. Changing this creates a new resource.
         */
        listFileKey?: string;
        /**
         * Specifies the list of object keys.
         * + If `type` is set to **object**, this parameter specifies the names of the objects to be migrated. The strings
         * ending with a slash (/) indicate the folders to be migrated, and the strings not ending with a slash (/) indicate the
         * files to be migrated.
         * + If `type` is set to **prefix**, this parameter indicates the name prefixes of the objects to be migrated.
         * Set this parameter to [""] to migrate the entire bucket
         */
        objects?: string[];
        /**
         * Specifies the region where the destination bucket is located.
         * Changing this creates a new resource.
         */
        region?: string;
        /**
         * Specifies the secret key for accessing the destination bucket.
         * Changing this creates a new resource.
         */
        secretKey?: string;
        /**
         * Specifies the temporary token for accessing the destination bucket.
         * Changing this creates a new resource.
         */
        securityToken?: string;
    }

}

export namespace Rds {
    export interface Database_privilegeUser {
        /**
         * Specifies the username of the database account. Changing this creates a new resource.
         */
        name: string;
        /**
         * Specifies the read-only permission. The value can be:
         * + **true**: indicates the read-only permission.
         * + **false**: indicates the read and write permission.
         */
        readonly?: boolean;
    }

    export interface GetEngineVersionsVersion {
        /**
         * Version ID.
         */
        id: string;
        /**
         * Version name.
         */
        name: string;
    }

    export interface GetFlavorsFlavor {
        /**
         * The availability zones which the RDS flavor belongs to.
         */
        availabilityZones: string[];
        /**
         * The Available versions of the database.
         */
        dbVersions: string[];
        /**
         * Specifies the performance specification, the valid values are as follows:
         * + **normal**: General enhanced.
         * + **normal2**: General enhanced type II.
         * + **armFlavors**: KunPeng general enhancement.
         * + **dedicatedNormal**: (dedicatedNormalLocalssd): Dedicated for x86.
         * + **armLocalssd**: KunPeng general type.
         * + **normalLocalssd**: x86 general type.
         * + **general**: General type.
         * + **dedicated**:
         * For MySQL engine: Dedicated type.
         * For PostgreSQL and SQL Server engines: Dedicated type, only supported by cloud disk SSD.
         * + **rapid**:
         * For MySQL engine: Dedicated (discontinued).
         * For PostgreSQL and SQL Server engines: Dedicated, only supported by ultra-fast SSDs.
         * + **bigmem**: Large memory type.
         */
        groupType: string;
        /**
         * The ID of the rds flavor.
         */
        id: string;
        /**
         * The mode of instance. Value: *ha*(indicates primary/standby instance),
         * *single*(indicates single instance) and *replica*(indicates read replicas).
         */
        instanceMode: string;
        /**
         * Specifies the memory size(GB) in the RDS flavor.
         */
        memory: number;
        /**
         * @deprecated use instance_mode instead
         */
        mode: string;
        /**
         * The name of the rds flavor.
         */
        name: string;
        /**
         * Specifies the number of vCPUs in the RDS flavor.
         */
        vcpus: number;
    }

    export interface GetInstancesInstance {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZones: string[];
        /**
         * Indicates the advanced backup policy. Structure is documented below.
         */
        backupStrategies: outputs.Rds.GetInstancesInstanceBackupStrategy[];
        /**
         * Indicates the creation time.
         */
        created: string;
        /**
         * Indicates the database information. Structure is documented below.
         */
        dbs: outputs.Rds.GetInstancesInstanceDb[];
        /**
         * Specifies the enterprise project id.
         */
        enterpriseProjectId: string;
        /**
         * Indicates the intranet floating IP address of the instance.
         */
        fixedIp: string;
        /**
         * Indicates the instance specifications.
         */
        flavor: string;
        /**
         * Indicates the replication mode for the standby DB instance.
         */
        haReplicationMode: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates the instance nodes information. Structure is documented below.
         */
        nodes: outputs.Rds.GetInstancesInstanceNode[];
        /**
         * Indicates the configuration ID.
         */
        paramGroupId: string;
        /**
         * Indicates the private ips in list.
         */
        privateIps: string[];
        /**
         * Indicates the public ips in list.
         */
        publicIps: string[];
        /**
         * The region in which to obtain the instances. If omitted, the provider-level region will
         * be used.
         */
        region: string;
        /**
         * Indicates the security group ID.
         */
        securityGroupId: string;
        /**
         * Indicates whether to enable SSL.
         */
        sslEnable: boolean;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Specifies the network ID of a subnet.
         */
        subnetId: string;
        /**
         * Indicates the tags of the instance.
         */
        tags: {[key: string]: string};
        /**
         * Indicates the time zone.
         */
        timeZone: string;
        /**
         * Indicates the volume information. Structure is documented below.
         */
        volumes: outputs.Rds.GetInstancesInstanceVolume[];
        /**
         * Specifies the VPC ID.
         */
        vpcId: string;
    }

    export interface GetInstancesInstanceBackupStrategy {
        /**
         * Indicates the number of days to retain the generated.
         */
        keepDays: number;
        /**
         * Indicates the backup time window.
         */
        startTime: string;
    }

    export interface GetInstancesInstanceDb {
        /**
         * Indicates the database port.
         */
        port: number;
        /**
         * Specifies the type of the instance. Valid values are: Single, Ha, Replica, and Enterprise.
         */
        type: string;
        /**
         * Indicates the database user name.
         */
        userName: string;
        /**
         * Indicates the database version.
         */
        version: string;
    }

    export interface GetInstancesInstanceNode {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZone: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates the node type.
         */
        role: string;
        /**
         * Indicates the node status.
         */
        status: string;
    }

    export interface GetInstancesInstanceVolume {
        /**
         * Indicates the kms key id.
         */
        diskEncryptionId: string;
        /**
         * Indicates the volume size.
         */
        size: number;
        /**
         * Specifies the type of the instance. Valid values are: Single, Ha, Replica, and Enterprise.
         */
        type: string;
    }

    export interface InstanceBackupStrategy {
        /**
         * Specifies the retention days for specific backup files. The value range is from 0 to
         * 732. If this parameter is not specified or set to 0, the automated backup policy is disabled.
         */
        keepDays: number;
        /**
         * Specifies the backup time window. Automated backups will be triggered during the
         * backup time window. It must be a valid value in the **hh:mm-HH:MM**
         * format. The current time is in the UTC format. The HH value must be 1 greater than the hh value. The values of mm and
         * MM must be the same and must be set to any of the following: 00, 15, 30, or 45. Example value: 08:15-09:15 23:00-00:
         * 00.
         */
        startTime: string;
    }

    export interface InstanceDb {
        /**
         * Specifies the database password. The value cannot be empty and should
         * contain 8 to 32 characters, including uppercase and lowercase letters, digits, and the following special
         * characters: ~!@#%^*-_=+? You are advised to enter a strong password to improve security, preventing security risks
         * such as brute force cracking. Changing this parameter will create a new resource.
         */
        password: string;
        /**
         * Specifies the database port.
         * + The MySQL database port ranges from 1024 to 65535 (excluding 12017 and 33071, which are occupied by the RDS system
         * and cannot be used). The default value is 3306.
         * + The PostgreSQL database port ranges from 2100 to 9500. The default value is 5432.
         * + The Microsoft SQL Server database port can be 1433 or ranges from 2100 to 9500, excluding 5355 and 5985. The
         * default value is 1433.
         */
        port: number;
        /**
         * Specifies the volume type. Its value can be any of the following and is
         * case-sensitive:
         * + *ULTRAHIGH*: SSD storage.
         * + *LOCALSSD*: local SSD storage.
         * + *CLOUDSSD*: cloud SSD storage. This storage type is supported only with general-purpose and dedicated DB
         * instances.
         * + *ESSD*: extreme SSD storage.
         */
        type: string;
        userName: string;
        /**
         * Specifies the database version. Changing this parameter will create a new
         * resource. Available values detailed in
         * [DB Engines and Versions](https://support.huaweicloud.com/intl/en-us/productdesc-rds/en-us_topic_0043898356.html).
         */
        version: string;
    }

    export interface InstanceNode {
        /**
         * Specifies the list of AZ name. Changing this parameter will create a
         * new resource.
         */
        availabilityZone: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the DB instance name. The DB instance name of the same type must be unique for
         * the same tenant. The value must be 4 to 64 characters in length and start with a letter. It is case-sensitive and can
         * contain only letters, digits, hyphens (-), and underscores (_).
         */
        name: string;
        /**
         * Indicates the node type. The value can be master or slave, indicating the primary node or standby node
         * respectively.
         */
        role: string;
        /**
         * Indicates the node status.
         */
        status: string;
    }

    export interface InstanceVolume {
        /**
         * Specifies the key ID for disk encryption. Changing this parameter will create a new
         * resource.
         */
        diskEncryptionId: string;
        /**
         * Specifies the volume size. Its value range is from 40 GB to 4000 GB. The value must be a
         * multiple of 10 and greater than the original size.
         */
        size: number;
        /**
         * Specifies the volume type. Its value can be any of the following and is
         * case-sensitive:
         * + *ULTRAHIGH*: SSD storage.
         * + *LOCALSSD*: local SSD storage.
         * + *CLOUDSSD*: cloud SSD storage. This storage type is supported only with general-purpose and dedicated DB
         * instances.
         * + *ESSD*: extreme SSD storage.
         */
        type: string;
    }

    export interface ParametergroupConfigurationParameter {
        /**
         * The parameter group description. It contains a maximum of 256 characters and cannot
         * contain the following special characters:>!<"&'= the value is left blank by default.
         */
        description: string;
        /**
         * The parameter group name. It contains a maximum of 64 characters.
         */
        name: string;
        /**
         * Indicates whether the parameter is read-only.
         */
        readonly: boolean;
        /**
         * Indicates whether a restart is required.
         */
        restartRequired: boolean;
        /**
         * The DB engine. Currently, MySQL, PostgreSQL, and Microsoft SQL Server are supported. The
         * value is case-insensitive and can be mysql, postgresql, or sqlserver.
         */
        type: string;
        /**
         * Indicates the parameter value.
         */
        value: string;
        /**
         * Indicates the parameter value range.
         */
        valueRange: string;
    }

    export interface ParametergroupDatastore {
        /**
         * The DB engine. Currently, MySQL, PostgreSQL, and Microsoft SQL Server are supported. The
         * value is case-insensitive and can be mysql, postgresql, or sqlserver.
         */
        type: string;
        /**
         * Specifies the database version.
         */
        version: string;
    }

    export interface ReadReplicaInstanceDb {
        /**
         * Indicates the database port information.
         */
        port: number;
        /**
         * Specifies the volume type. Its value can be any of the following and is
         * case-sensitive:
         * + *ULTRAHIGH*: SSD storage.
         * + *LOCALSSD*: local SSD storage.
         * + *CLOUDSSD*: cloud SSD storage. This storage type is supported only with general-purpose and dedicated DB
         * instances.
         * + *ESSD*: extreme SSD storage.
         */
        type: string;
        /**
         * Indicates the default user name of database.
         */
        userName: string;
        /**
         * Indicates the database version.
         */
        version: string;
    }

    export interface ReadReplicaInstanceVolume {
        /**
         * Specifies the key ID for disk encryption. Changing this parameter
         * will create a new resource.
         */
        diskEncryptionId?: string;
        size: number;
        /**
         * Specifies the volume type. Its value can be any of the following and is
         * case-sensitive:
         * + *ULTRAHIGH*: SSD storage.
         * + *LOCALSSD*: local SSD storage.
         * + *CLOUDSSD*: cloud SSD storage. This storage type is supported only with general-purpose and dedicated DB
         * instances.
         * + *ESSD*: extreme SSD storage.
         */
        type: string;
    }
}

export namespace Scm {
    export interface CertificateAuthentification {
        /**
         * Domain name mapping to the verification value
         */
        domain: string;
        /**
         * Name of a domain ownership verification value.
         */
        recordName: string;
        /**
         * Type of the domain name verification value.
         */
        recordType: string;
        /**
         * Domain verification value.
         */
        recordValue: string;
    }

    export interface CertificateTarget {
        /**
         * The project where the service you want to push a certificate to. The same certificate
         * can be pushed repeatedly to the same WAF or ELB service in the same `project`, but the CDN service can only be pushed
         * once.
         */
        projects?: string[];
        /**
         * Service to which the certificate is pushed. The options include `CDN`,`WAF`
         * and `Enhance_ELB`.
         */
        service: string;
    }

    export interface GetCertificatesCertificate {
        /**
         * Certificate authority.  
         * The value can be: **GLOBALSIGN**, **SYMANTEC**, **GEOTRUST**, **CFCA**.
         */
        brand: string;
        /**
         * Whether to support deployment.
         */
        deploySupport: boolean;
        /**
         * Certificate description.
         */
        description: string;
        /**
         * Domain name associated with the certificate.
         */
        domain: string;
        /**
         * Number of domain names that can be associated with the certificate.
         */
        domainCount: number;
        /**
         * Domain name type.  
         * The options are as follows:
         * - SINGLE_DOMAIN: Single domain names
         * - WILDCARD: Wildcard domain names
         * - MULTI_DOMAIN: Multiple domain names
         */
        domainType: string;
        /**
         * The enterprise project id of the project.
         */
        enterpriseProjectId: string;
        /**
         * Certificate expiration time.
         */
        expireTime: string;
        /**
         * Certificate ID.
         */
        id: string;
        /**
         * Certificate name.
         */
        name: string;
        /**
         * Additional domain name associated with the certificate.
         */
        sans: string;
        /**
         * Signature algorithm.
         */
        signatureAlgorithm: string;
        /**
         * Certificate status.  
         * The options are as follows:
         * - ALL: All certificate status.
         * - PAID: The certificate has been paid and needs to be applied for from the CA.
         * - ISSUED: The certificate has been issued.
         * - CHECKING: The certificate application is being reviewed.
         * - CANCELCHECKING: The certificate application cancellation is being reviewed.
         * - UNPASSED: The certificate application fails.
         * - EXPIRED: The certificate has expired.
         * - REVOKING: The certificate revocation application is being reviewed.
         * - REVOKED: The certificate has been revoked.
         * - UPLOAD: The certificate is being managed.
         * - CHECKING_ORG: The organization verification is to be completed.
         * - ISSUING: The certificate is to be issued.
         * - SUPPLEMENTCHECKING: Additional domain names to be added for a multi-domain certificate are being reviewed.
         */
        status: string;
        /**
         * Certificate type.  
         * The value can be: **DV_SSL_CERT**, **DV_SSL_CERT_BASIC**, **EV_SSL_CERT**, **EV_SSL_CERT_PRO**, **OV_SSL_CERT**, **OV_SSL_CERT_PRO**.
         */
        type: string;
        /**
         * Certificate validity period, in months.
         */
        validityPeriod: number;
        /**
         * Number of wildcard domain names that can be associated with the certificate.
         */
        wildcardCount: number;
    }

}

export namespace ServiceStage {
    export interface ApplicationEnvironment {
        /**
         * Specifies the environment ID to which the variables belongs.
         */
        id: string;
        /**
         * Specifies the list of environment variables.
         * The object structure is documented below.
         */
        variables: outputs.ServiceStage.ApplicationEnvironmentVariable[];
    }

    export interface ApplicationEnvironmentVariable {
        /**
         * Specifies the variable name. The name can contain `1` to `64` characters, only letters,
         * digits, underscores (_), hyphens (-) and dots (.) are allowed. The name cannot start with a digit or dot.
         */
        name: string;
        /**
         * Specifies the variable value. The value can contian a maximum of `2,048` characters.
         */
        value: string;
    }

    export interface ComponentBuilder {
        /**
         * Specifies the cluster ID.
         */
        clusterId: string;
        /**
         * Specifies the build command. If omitted, the default command will be used.
         * + About the  default command or script: build.sh in the root directory will be preferentially executed.
         * If build.sh does not exist, the code will be compiled using the common method of the selected language,
         * for example, mvn clean package for Java.
         * + About the custom command: Commands will be customized using the selected language.
         * Alternatively, the default command or script will be used after build.sh is modified.
         */
        cmd: string;
        /**
         * Specifies the filter labels for CCE nodes.
         */
        nodeLabel?: {[key: string]: string};
        /**
         * Specifies the organization name.
         * The organization is usually **domain name**. You can find out in the organization management of SWR.
         */
        organization: string;
    }

    export interface ComponentInstanceArtifact {
        /**
         * Specifies the authentication mode.
         * The valid values are **iam** and **none**. Defaults to **iam**.
         */
        authType?: string;
        /**
         * Specifies the name of a configuration item or secret.
         */
        name: string;
        /**
         * Specifies the properties of the OBS object.
         * This parameter is available only `storage` is **obs**.
         * The object structure is documented below.
         */
        properties: outputs.ServiceStage.ComponentInstanceArtifactProperties;
        /**
         * Specifies the data storage configuration.
         * The object structure is documented below.
         */
        storage: string;
        /**
         * Specifies the probe type. The valid values are as follows:
         * + **command**: command execution check.
         * + **http**: HTTP request check.
         * + **tcp**: TCP port check.
         */
        type: string;
        /**
         * Specifies the software package or image address.
         * For a component deployed on a VM, this parameter is the software package address.
         * For a component deployed based on a container, this parameter is the image address or component name:v${index}.
         * The latter indicates that the component source code or the image automatically built using the software package
         * will be used.
         */
        url: string;
        /**
         * Specifies the version number.
         */
        version: string;
    }

    export interface ComponentInstanceArtifactProperties {
        /**
         * Specifies the OBS bucket name.
         */
        bucket: string;
        /**
         * Specifies the OBS bucket endpoint.
         */
        endpoint: string;
        /**
         * Specifies the key name of the OBS object.
         */
        key: string;
    }

    export interface ComponentInstanceConfiguration {
        /**
         * Specifies the environment variables.
         * The object structure is documented below.
         */
        envVariables: outputs.ServiceStage.ComponentInstanceConfigurationEnvVariable[];
        /**
         * Specifies the lifecycle.
         * The object structure is documented below.
         */
        lifecycle: outputs.ServiceStage.ComponentInstanceConfigurationLifecycle;
        /**
         * Specifies the policies of the log collection.
         * The object structure is documented below.
         */
        logCollectionPolicies: outputs.ServiceStage.ComponentInstanceConfigurationLogCollectionPolicy[];
        /**
         * Specifies the variable value.
         * The object structure is documented below.
         */
        probe: outputs.ServiceStage.ComponentInstanceConfigurationProbe;
        /**
         * Specifies the scheduling policy.
         * The key indicates the component name. In the Docker container scenario, key indicates the container name.
         * If the source parameters of a component specify the software package source, this parameter is optional, and the
         * software package source of the component is inherited by default. Otherwise, this parameter is required.
         * The object structure is documented below.
         */
        scheduler: outputs.ServiceStage.ComponentInstanceConfigurationScheduler;
        /**
         * Specifies the data storage configuration.
         * The object structure is documented below.
         */
        storages: outputs.ServiceStage.ComponentInstanceConfigurationStorage[];
        /**
         * Specifies the upgrade policy.
         * The object structure is documented below.
         */
        strategy: outputs.ServiceStage.ComponentInstanceConfigurationStrategy;
    }

    export interface ComponentInstanceConfigurationEnvVariable {
        /**
         * Specifies the name of a configuration item or secret.
         */
        name: string;
        /**
         * Specifies the variable value.
         */
        value: string;
    }

    export interface ComponentInstanceConfigurationLifecycle {
        /**
         * Specifies the startup commands.
         * The object structure is documented below.
         */
        entrypoint: outputs.ServiceStage.ComponentInstanceConfigurationLifecycleEntrypoint;
        /**
         * Specifies the post-start processing.
         * The object structure is documented below.
         */
        postStart: outputs.ServiceStage.ComponentInstanceConfigurationLifecyclePostStart;
        /**
         * Specifies the pre-stop processing.
         * The object structure is documented below.
         */
        preStop: outputs.ServiceStage.ComponentInstanceConfigurationLifecyclePreStop;
    }

    export interface ComponentInstanceConfigurationLifecycleEntrypoint {
        /**
         * Specifies the running parameters.
         */
        args: string[];
        /**
         * Specifies the command list.
         */
        commands: string[];
    }

    export interface ComponentInstanceConfigurationLifecyclePostStart {
        /**
         * Specifies the start post-processing or stop pre-processing parameters.
         * The object structure is documented below.
         */
        parameters: outputs.ServiceStage.ComponentInstanceConfigurationLifecyclePostStartParameters;
        /**
         * Specifies the probe type. The valid values are as follows:
         * + **command**: command execution check.
         * + **http**: HTTP request check.
         * + **tcp**: TCP port check.
         */
        type: string;
    }

    export interface ComponentInstanceConfigurationLifecyclePostStartParameters {
        /**
         * Specifies the command list.
         */
        commands: string[];
        /**
         * Specifies the custom IP address. The defualt address is pod IP address.
         */
        host: string;
        /**
         * Specifies the request path.
         */
        path: string;
        /**
         * Specifies the listening port of the application component process.
         */
        port: number;
    }

    export interface ComponentInstanceConfigurationLifecyclePreStop {
        /**
         * Specifies the start post-processing or stop pre-processing parameters.
         * The object structure is documented below.
         */
        parameters: outputs.ServiceStage.ComponentInstanceConfigurationLifecyclePreStopParameters;
        /**
         * Specifies the probe type. The valid values are as follows:
         * + **command**: command execution check.
         * + **http**: HTTP request check.
         * + **tcp**: TCP port check.
         */
        type: string;
    }

    export interface ComponentInstanceConfigurationLifecyclePreStopParameters {
        /**
         * Specifies the command list.
         */
        commands: string[];
        /**
         * Specifies the custom IP address. The defualt address is pod IP address.
         */
        host: string;
        /**
         * Specifies the request path.
         */
        path: string;
        /**
         * Specifies the listening port of the application component process.
         */
        port: number;
    }

    export interface ComponentInstanceConfigurationLogCollectionPolicy {
        /**
         * Specifies the configurations of the container mounting.
         * The object structure is documented below.
         */
        containerMountings: outputs.ServiceStage.ComponentInstanceConfigurationLogCollectionPolicyContainerMounting[];
        /**
         * Specifies the The host path that will be mounted to the specified container path.
         */
        hostPath?: string;
    }

    export interface ComponentInstanceConfigurationLogCollectionPolicyContainerMounting {
        /**
         * Specifies the aging period.
         * The valid values are **Hourly**, **Daily** and **Weekly**. The default value is **Hourly**.
         */
        agingPeriod?: string;
        /**
         * Specifies the extended host path.
         * This parameter can be configured only when `hostPath` is configured.
         * The valid values are as follows:
         * + **PodUID**
         * + **PodName**
         * + **PodUID/ContainerName**
         * + **PodName/ContainerName**
         */
        hostExtendPath?: string;
        /**
         * Specifies the request path.
         */
        path: string;
    }

    export interface ComponentInstanceConfigurationProbe {
        /**
         * Specifies the component liveness probe.
         * The object structure is documented below.
         */
        liveness: outputs.ServiceStage.ComponentInstanceConfigurationProbeLiveness;
        /**
         * Specifies the component service probe.
         * The object structure is documented below.
         */
        readiness: outputs.ServiceStage.ComponentInstanceConfigurationProbeReadiness;
    }

    export interface ComponentInstanceConfigurationProbeLiveness {
        /**
         * Specifies the commands. Required if `type` is **command**.
         * The object structure is documented below.
         */
        commandParam: outputs.ServiceStage.ComponentInstanceConfigurationProbeLivenessCommandParam;
        /**
         * Specifies the interval between the startup and detection.
         */
        delay: number;
        /**
         * Specifies the commands. Required if `type` is **http**.
         * The object structure is documented below.
         */
        httpParam: outputs.ServiceStage.ComponentInstanceConfigurationProbeLivenessHttpParam;
        /**
         * Specifies the commands. Required if `type` is **tcp**.
         * The object structure is documented below.
         */
        tcpParam: outputs.ServiceStage.ComponentInstanceConfigurationProbeLivenessTcpParam;
        /**
         * Specifies the detection timeout interval.
         */
        timeout: number;
        /**
         * Specifies the probe type. The valid values are as follows:
         * + **command**: command execution check.
         * + **http**: HTTP request check.
         * + **tcp**: TCP port check.
         */
        type: string;
    }

    export interface ComponentInstanceConfigurationProbeLivenessCommandParam {
        /**
         * Specifies the command list.
         */
        commands: string[];
    }

    export interface ComponentInstanceConfigurationProbeLivenessHttpParam {
        /**
         * Specifies the custom IP address. The defualt address is pod IP address.
         */
        host: string;
        /**
         * Specifies the request path.
         */
        path: string;
        /**
         * Specifies the listening port of the application component process.
         */
        port: number;
        /**
         * Specifies the protocol scheme. The valid values are **HTTP** and **HTTPS**.
         */
        scheme: string;
    }

    export interface ComponentInstanceConfigurationProbeLivenessTcpParam {
        /**
         * Specifies the listening port of the application component process.
         */
        port: number;
    }

    export interface ComponentInstanceConfigurationProbeReadiness {
        /**
         * Specifies the commands. Required if `type` is **command**.
         * The object structure is documented below.
         */
        commandParam: outputs.ServiceStage.ComponentInstanceConfigurationProbeReadinessCommandParam;
        /**
         * Specifies the interval between the startup and detection.
         */
        delay: number;
        /**
         * Specifies the commands. Required if `type` is **http**.
         * The object structure is documented below.
         */
        httpParam: outputs.ServiceStage.ComponentInstanceConfigurationProbeReadinessHttpParam;
        /**
         * Specifies the commands. Required if `type` is **tcp**.
         * The object structure is documented below.
         */
        tcpParam: outputs.ServiceStage.ComponentInstanceConfigurationProbeReadinessTcpParam;
        /**
         * Specifies the detection timeout interval.
         */
        timeout: number;
        /**
         * Specifies the probe type. The valid values are as follows:
         * + **command**: command execution check.
         * + **http**: HTTP request check.
         * + **tcp**: TCP port check.
         */
        type: string;
    }

    export interface ComponentInstanceConfigurationProbeReadinessCommandParam {
        /**
         * Specifies the command list.
         */
        commands: string[];
    }

    export interface ComponentInstanceConfigurationProbeReadinessHttpParam {
        /**
         * Specifies the custom IP address. The defualt address is pod IP address.
         */
        host: string;
        /**
         * Specifies the request path.
         */
        path: string;
        /**
         * Specifies the listening port of the application component process.
         */
        port: number;
        /**
         * Specifies the protocol scheme. The valid values are **HTTP** and **HTTPS**.
         */
        scheme: string;
    }

    export interface ComponentInstanceConfigurationProbeReadinessTcpParam {
        /**
         * Specifies the listening port of the application component process.
         */
        port: number;
    }

    export interface ComponentInstanceConfigurationScheduler {
        /**
         * Specifies the commands.
         * The object structure is documented below.
         */
        affinity: outputs.ServiceStage.ComponentInstanceConfigurationSchedulerAffinity;
        /**
         * Specifies the commands.
         * The object structure is documented below.
         */
        antiAffinity: outputs.ServiceStage.ComponentInstanceConfigurationSchedulerAntiAffinity;
    }

    export interface ComponentInstanceConfigurationSchedulerAffinity {
        /**
         * Specifies the AZ list.
         */
        availabilityZones: string[];
        /**
         * Specifies the list of component instance names.
         */
        instanceNames: string[];
        /**
         * Specifies the node private IP address list.
         */
        privateIps: string[];
    }

    export interface ComponentInstanceConfigurationSchedulerAntiAffinity {
        /**
         * Specifies the AZ list.
         */
        availabilityZones: string[];
        /**
         * Specifies the list of component instance names.
         */
        instanceNames: string[];
        /**
         * Specifies the node private IP address list.
         */
        privateIps: string[];
    }

    export interface ComponentInstanceConfigurationStorage {
        /**
         * Specifies the directory mounted to the container.
         * The object structure is documented below.
         */
        mounts: outputs.ServiceStage.ComponentInstanceConfigurationStorageMount[];
        /**
         * Specifies the storage parameters.
         * The object structure is documented below.
         */
        parameter: outputs.ServiceStage.ComponentInstanceConfigurationStorageParameter;
        /**
         * Specifies the probe type. The valid values are as follows:
         * + **command**: command execution check.
         * + **http**: HTTP request check.
         * + **tcp**: TCP port check.
         */
        type: string;
    }

    export interface ComponentInstanceConfigurationStorageMount {
        /**
         * Specifies the request path.
         */
        path: string;
        /**
         * Specifies the mounted disk permission is read-only or read-write.
         * + **true**: read-only.
         * + **false**: read-write.
         */
        readonly: boolean;
        /**
         * Specifies the subpath of the mounted disk.
         * This parameter is applicable to `http` type.
         */
        subpath: string;
    }

    export interface ComponentInstanceConfigurationStorageParameter {
        /**
         * Specifies the PVC name.
         */
        claimName: string;
        /**
         * Specifies the name of a configuration item or secret.
         */
        name: string;
        /**
         * Specifies the request path.
         */
        path: string;
    }

    export interface ComponentInstanceConfigurationStrategy {
        /**
         * Specifies the upgrade policy.
         * The valid values are **Recreate** or **RollingUpdate**. The default value is **RollingUpdate**.
         * The **Recreate** indicates in-place upgrade while the **RollingUpdate** indicates rolling upgrade.
         */
        upgrade?: string;
    }

    export interface ComponentInstanceExternalAccess {
        /**
         * Specifies the access address. For example: www.example.com.
         */
        address: string;
        /**
         * Specifies the listening port of the application component process.
         */
        port: number;
        /**
         * Specifies the protocol. The valid values are **HTTP** and **HTTPS**.
         */
        protocol: string;
    }

    export interface ComponentInstanceReferResource {
        /**
         * Specifies the application alias, which is provided only in DCS scenario.
         * The valid values are: **distributed_session**, **distributed_cache** and **distributed_session, distributed_cache**.
         * Defaults to **distributed_session, distributed_cache**.
         */
        alias: string;
        /**
         * Specifies the resource ID.
         * If the `type` is set to **ecs**, the value of this parameter must be **Default**.
         */
        id: string;
        /**
         * Specifies the start post-processing or stop pre-processing parameters.
         * The object structure is documented below.
         */
        parameters: {[key: string]: string};
        /**
         * Specifies the probe type. The valid values are as follows:
         * + **command**: command execution check.
         * + **http**: HTTP request check.
         * + **tcp**: TCP port check.
         */
        type: string;
    }

    export interface ComponentSource {
        /**
         * Specifies the authorization name.
         * This parameter and `storageType` are alternative.
         */
        authorization: string;
        /**
         * Specifies the namespace name.
         */
        repoNamespace?: string;
        /**
         * Specifies the name of the branch of the code repository.
         * The default value is `master`.
         */
        repoRef?: string;
        /**
         * Specifies the storage type, such as **obs**, **swr**.
         * This parameter is conflict with `repoRef` and `repoNamespace`.
         */
        storageType: string;
        /**
         * Specifies the type of repository source or storage.
         * The valid values are **GitHub**, **GitLab**, **Gitee**, **Bitbucket** and **package**.
         */
        type: string;
        /**
         * Specifies the URL of the repository or package storage.
         */
        url: string;
    }

    export interface EnvironmentBasicResource {
        /**
         * Specifies the resource ID. For most resources, this parameter needs to fill in their **id**,
         * but for CCI namespace, this parameter needs to fill in **name**.
         */
        id: string;
        /**
         * Specifies the resource type.
         * + The type of basic resource supports **cce**, **cci**, **ecs** and **as**.
         * + The type of optional resource supports **elb**, **eip**, **rds**, **dcs** and **cse**.
         */
        type: string;
    }

    export interface EnvironmentOptionalResource {
        /**
         * Specifies the resource ID. For most resources, this parameter needs to fill in their **id**,
         * but for CCI namespace, this parameter needs to fill in **name**.
         */
        id: string;
        /**
         * Specifies the resource type.
         * + The type of basic resource supports **cce**, **cci**, **ecs** and **as**.
         * + The type of optional resource supports **elb**, **eip**, **rds**, **dcs** and **cse**.
         */
        type: string;
    }

    export interface GetComponentRuntimesRuntime {
        /**
         * Specifies the default container port to use for filtering.
         */
        defaultPort: number;
        /**
         * The runtime description.
         */
        description: string;
        /**
         * Specifies the runtime name to use for filtering.
         * For the runtime names corresponding to each type of component, please refer to the [document](https://support.huaweicloud.com/intl/en-us/usermanual-servicestage/servicestage_user_0411.html).
         */
        name: string;
    }

}

export namespace Sfs {
    export interface FileSystemAccessRule {
        /**
         * Specifies the access level of the shared file system. Possible values are *ro* (
         * read-only)
         * and *rw* (read-write). The default value is *rw* (read/write). Changing this will create a new access rule.
         */
        accessLevel: string;
        /**
         * The UUID of the share access rule.
         */
        accessRuleId: string;
        /**
         * Specifies the value that defines the access rule. The value contains 1 to 255
         * characters. Changing this will create a new access rule. The value varies according to the scenario:
         * + Set the VPC ID in VPC authorization scenarios.
         * + Set this parameter in IP address authorization scenario:
         * - For an NFS shared file system, the value in the format of *VPC_ID#IP_address#priority#user_permission*.
         * For example, 0157b53f-4974-4e80-91c9-098532bcaf00#2.2.2.2/16#100#all_squash,root_squash.
         * - For a CIFS shared file system, the value in the format of *VPC_ID#IP_address#priority*.
         * For example, 0157b53f-4974-4e80-91c9-098532bcaf00#2.2.2.2/16#0.
         */
        accessTo: string;
        /**
         * Specifies the type of the share access rule. The default value is *cert*. Changing
         * this will create a new access rule.
         */
        accessType: string;
        /**
         * The status of the share access rule.
         */
        status: string;
    }

    export interface GetTurbosTurbo {
        /**
         * The availability zone where the SFS turbo file system is located.
         */
        availabilityZone: string;
        /**
         * The available capacity of the SFS turbo file system, in GB.
         */
        availableCapacity: string;
        /**
         * The ID of a KMS key to encrypt the SFS turbo file system.
         */
        cryptKeyId: string;
        /**
         * Whether the SFS turbo file system is enhanced.
         */
        enhanced: boolean;
        /**
         * The enterprise project ID of the SFS turbo file system.
         */
        enterpriseProjectId: string;
        /**
         * The mount point of the SFS turbo file system.
         */
        exportLocation: string;
        /**
         * The resource ID of the SFS turbo file system.
         */
        id: string;
        /**
         * Specifies the name of the SFS turbo file system.
         */
        name: string;
        /**
         * The ID of the security group to which the SFS turbo belongs.
         */
        securityGroupId: string;
        /**
         * Specifies the protocol of the SFS turbo file system. The valid value is **NFS**.
         */
        shareProto: string;
        /**
         * Specifies the type of the SFS turbo file system.
         * The valid values are **STANDARD** and **PERFORMANCE**.
         */
        shareType: string;
        /**
         * Specifies the capacity of the SFS turbo file system, in GB.
         * The value ranges from `500` to `32,768`, and must be large than `10,240` for an enhanced file system.
         */
        size: number;
        /**
         * The **network ID** of the subnet to which the SFS turbo belongs.
         */
        subnetId: string;
        /**
         * The version of the SFS turbo file system.
         */
        version: string;
        /**
         * The ID of the VPC to which the SFS turbo belongs.
         */
        vpcId: string;
    }

}

export namespace SharedApig {
    export interface ApiBackendParameter {
        /**
         * Specifies the description of the parameter. The description cannot exceed 255
         * characters.
         */
        description?: string;
        /**
         * Specifies the parameter location, which can be 'PATH', 'QUERY' or 'HEADER'.
         */
        location: string;
        /**
         * Specifies the parameter name. A parameter name consists of 1–32 characters, starting with
         * a letter. Only letters, digits, periods (.), hyphens (-), and underscores (_) are allowed.
         */
        name: string;
        /**
         * Specifies the parameter type, which can be 'REQUEST', 'CONSTANT', or 'SYSTEM'.
         */
        type?: string;
        /**
         * Specifies the parameter value, which is a string of not more than 255 characters. The
         * value varies depending on the parameter type:
         * + 'REQUEST': parameter name in `requestParameter`
         * + 'CONSTANT': real value of the parameter
         * + 'SYSTEM': gateway parameter name
         */
        value: string;
    }

    export interface ApiFunctionBackend {
        /**
         * Specifies the function URN.
         */
        functionUrn: string;
        /**
         * Specifies the invocation mode, which can be 'async' or 'sync'.
         */
        invocationType: string;
        /**
         * Timeout duration (in ms) for API Gateway to request for FunctionGraph. Defaults to 50000.
         */
        timeout?: number;
        /**
         * Specifies the function version.
         */
        version: string;
    }

    export interface ApiHttpBackend {
        /**
         * Specifies the backend request method, including 'GET','POST','PUT' and etc..
         */
        method: string;
        /**
         * Specifies the backend request protocol. The value can be 'HTTP' and 'HTTPS'.
         */
        protocol: string;
        /**
         * Timeout duration (in ms) for API Gateway to request for the backend service. Defaults to
         * 50000.
         */
        timeout?: number;
        /**
         * Specifies the backend request path. The value must comply with URI specifications.
         */
        uri: string;
        /**
         * Specifies the backend service address. An endpoint URL is in the format of
         * "domain name (or IP address):port number", with up to 255 characters. This parameter and `vpcChannel` are
         * alternative.
         */
        urlDomain?: string;
        /**
         * Specifies the VPC channel ID. This parameter and `urlDomain` are alternative.
         */
        vpcChannel?: string;
    }

    export interface ApiMockBackend {
        /**
         * Specifies the description of the Mock backend. The description cannot exceed 255
         * characters.
         */
        description?: string;
        /**
         * Specifies the return result.
         */
        resultContent?: string;
        /**
         * Specifies the version of the Mock backend.
         */
        version?: string;
    }

    export interface ApiRequestParameter {
        /**
         * Specifies the default value when the parameter is optional.
         */
        default?: string;
        /**
         * Specifies the description of the parameter. The description cannot exceed 255
         * characters.
         */
        description?: string;
        /**
         * Specifies the input parameter location, which can be 'PATH', 'QUERY' or 'HEADER'.
         */
        location: string;
        /**
         * Specifies the input parameter name. A parameter name consists of 1–32 characters, starting
         * with a letter. Only letters, digits, periods (.), hyphens (-), and underscores (_) are allowed.
         */
        name: string;
        /**
         * Specifies whether the parameter is mandatory or not.
         */
        required: boolean;
        /**
         * Specifies the input parameter type, which can be 'STRING' or 'NUMBER'.
         */
        type: string;
    }

}

export namespace Smn {
    export interface GetTopicsTopic {
        /**
         * Specifies the topic display name.
         */
        displayName: string;
        /**
         * Specifies the enterprise project ID of the SMN topic.
         */
        enterpriseProjectId: string;
        /**
         * The topic ID. The value is the topic URN.
         */
        id: string;
        /**
         * Specifies the name of the topic.
         */
        name: string;
        /**
         * Message pushing policy.
         * + **0**: indicates that the message sending fails and the message is cached in the queue.
         * + **1**: indicates that the failed message is discarded.
         */
        pushPolicy: number;
        /**
         * The tags of the SMN topic, key/value pair format.
         */
        tags: {[key: string]: string};
        /**
         * Specifies the topic URN.
         */
        topicUrn: string;
    }

}

export namespace Sms {
    export interface GetSourceServersServer {
        /**
         * The version of Agent installed on the source server.
         */
        agentVersion: string;
        /**
         * Whether the source server is properly connected to SMS.
         */
        connected: boolean;
        /**
         * The disk information of the source server. Structure is documented below.
         */
        disks: outputs.Sms.GetSourceServersServerDisk[];
        /**
         * Specifies the ID of the source server.
         */
        id: string;
        /**
         * Specifies the IP address of the source server.
         */
        ip: string;
        /**
         * The memory size in MB.
         */
        memory: number;
        /**
         * Specifies the name of the source server.
         */
        name: string;
        /**
         * The OS type of the source server. The value can be **WINDOWS** and **LINUX**.
         */
        osType: string;
        /**
         * The OS version of the source server, for example, UBUNTU_20_4_64BIT.
         */
        osVersion: string;
        /**
         * The UTC time when the source server is registered.
         */
        registeredTime: string;
        state: string;
        /**
         * The vcpus count of the source server.
         */
        vcpus: number;
    }

    export interface GetSourceServersServerDisk {
        /**
         * The disk type. The value can be **BOOT**, **OS** and **NORMAL**.
         */
        deviceType: string;
        /**
         * Specifies the name of the source server.
         */
        name: string;
        /**
         * The disk size in MB.
         */
        size: number;
    }

    export interface TaskTargetServerDisk {
        /**
         * Specifies the partition type. The value can be **NORMAL** and **OS**.
         * Changing this parameter will create a new resource.
         */
        deviceType: string;
        /**
         * Specifies the disk index, e.g. "0".
         * Changing this parameter will create a new resource.
         */
        diskId: string;
        /**
         * Specifies the volume name. In Windows, it indicates the drive letter,
         * and in Linux, it indicates the device ID, e.g. "/dev/sda1".
         * Changing this parameter will create a new resource.
         */
        name: string;
        /**
         * Specifies an array of physical volume informations.
         * The object is documented below. Changing this parameter will create a new resource.
         */
        physicalVolumes?: outputs.Sms.TaskTargetServerDiskPhysicalVolume[];
        /**
         * Specifies the volume size in MB. Changing this parameter will create a new resource.
         */
        size: number;
        /**
         * Specifies the used space in MB.
         * Changing this parameter will create a new resource.
         */
        usedSize: number;
    }

    export interface TaskTargetServerDiskPhysicalVolume {
        /**
         * Specifies the partition type. The value can be **NORMAL** and **OS**.
         * Changing this parameter will create a new resource.
         */
        deviceType: string;
        /**
         * Specifies the file system type, e.g. "ext4".
         * Changing this parameter will create a new resource.
         */
        fileSystem: string;
        /**
         * Specifies the serial number of the volume.
         * Changing this parameter will create a new resource.
         */
        index: number;
        /**
         * Specifies the mount point, e.g. "/".
         * Changing this parameter will create a new resource.
         */
        mountPoint: string;
        /**
         * Specifies the volume name. In Windows, it indicates the drive letter,
         * and in Linux, it indicates the device ID, e.g. "/dev/sda1".
         * Changing this parameter will create a new resource.
         */
        name: string;
        /**
         * Specifies the volume size in MB. Changing this parameter will create a new resource.
         */
        size: number;
        /**
         * Specifies the used space in MB.
         * Changing this parameter will create a new resource.
         */
        usedSize: number;
        /**
         * Specifies the GUID of the volume.
         * Changing this parameter will create a new resource.
         */
        uuid: string;
    }

}

export namespace Swr {
    export interface OrganizationPermissionsSelfPermission {
        /**
         * Specifies the permission of the existing HuaweiCloud user.
         * The values can be **Manage**, **Write** and **Read**.
         */
        permission: string;
        /**
         * Specifies the ID of the existing HuaweiCloud user.
         */
        userId: string;
        /**
         * Specifies the name of the existing HuaweiCloud user.
         */
        userName: string;
    }

    export interface OrganizationPermissionsUser {
        /**
         * Specifies the permission of the existing HuaweiCloud user.
         * The values can be **Manage**, **Write** and **Read**.
         */
        permission: string;
        /**
         * Specifies the ID of the existing HuaweiCloud user.
         */
        userId: string;
        /**
         * Specifies the name of the existing HuaweiCloud user.
         */
        userName: string;
    }

}

export namespace Tms {
    export interface TagsTag {
        /**
         * Specifies the tag key. The value can contain up to 36 characters.
         * Only letters, digits, hyphens (-), underscores (_), and Unicode characters from \u4e00 to \u9fff are allowed.
         * Changing this will create a new resource.
         */
        key: string;
        /**
         * Specifies the tag value. The value can contain up to 43 characters.
         * Only letters, digits, periods (.), hyphens (-), and underscores (_), and Unicode characters from \u4e00 to \u9fff
         * are allowed. Changing this will create a new resource.
         */
        value: string;
    }

}

export namespace Vod {
    export interface MediaAssetThumbnail {
        /**
         * Specifies the screenshot aspect ratio. The value can be:
         * + **0**: adaptive (maintain the original aspect ratio).
         * + **1**: 16:9.
         */
        aspectRatio?: number;
        /**
         * Specifies the number of screenshots as the cover. Defaults to: **1**.
         * Changing this creates a new resource.
         */
        coverPosition?: number;
        /**
         * Specifies an array of time points of screenshot. Required when `type` is **dots**.
         * Changing this creates a new resource.
         */
        dots?: number[];
        /**
         * Specifies the screenshot file format. Currently, only **1** (jpg) is supported.
         * Defaults to: **1**. Changing this creates a new resource.
         */
        format?: number;
        /**
         * Specifies the size of the longest side of the screenshot. Unit: pixel.
         * The width dimension is calculated by scaling the dimension proportional to the original video pixels.
         * Changing this creates a new resource.
         */
        maxLength?: number;
        /**
         * Specifies the screenshot time interval (unit: second). The value range is 1 to 12.
         * Required when `type` is **time**. Changing this creates a new resource.
         */
        time?: number;
        /**
         * Specifies the screenshot type. Valid values are: **time** and **dots**.
         * Changing this creates a new resource.
         */
        type: string;
    }

    export interface TranscodingTemplateGroupQualityInfo {
        /**
         * Specifies the audio configurations.
         * The object structure is documented below.
         */
        audio?: outputs.Vod.TranscodingTemplateGroupQualityInfoAudio;
        /**
         * Specifies the output format. The value can be: **HLS**, **MP4**, **DASH**,
         * **DASH_HLS**, **MP3** and **ADTS**.
         */
        outputFormat: string;
        /**
         * Specifies the video configurations.
         * The object structure is documented below.
         */
        video?: outputs.Vod.TranscodingTemplateGroupQualityInfoVideo;
    }

    export interface TranscodingTemplateGroupQualityInfoAudio {
        /**
         * Specifies the audio bitrate. The value can be **0** or range from
         * **8** to **1000**. Defaults to: **0**. If set to **0**, the output audio will be produced at the recommended bitrate.
         */
        bitrate?: number;
        /**
         * Specifies the audio channels. The value can be:
         * + **1**: Mono
         * + **2**: Stereo
         */
        channels: number;
        /**
         * Specifies the audio sample rate. The value can be:
         * + **1**: AUTO
         * + **2**: 22,050 Hz
         * + **3**: 32,000 Hz
         * + **4**: 44,100 Hz
         * + **5**: 48,000 Hz
         * + **6**: 96,000 Hz
         */
        sampleRate: number;
    }

    export interface TranscodingTemplateGroupQualityInfoVideo {
        /**
         * Specifies the audio bitrate. The value can be **0** or range from
         * **8** to **1000**. Defaults to: **0**. If set to **0**, the output audio will be produced at the recommended bitrate.
         */
        bitrate?: number;
        /**
         * Specifies the video frame rate. The value ranges from **1** to **75**.
         * Defaults to: **1**. If set to **1**, the frame rate of the transcoded video is the same as that of the
         * untransocded video.
         */
        frameRate?: number;
        /**
         * Specifies the video height. The value can be **0** or range from **128** to **2160**.
         * Defaults to: **0**. If set to **0**, the system will automatically adjust the `height` according to the `width`.
         */
        height?: number;
        /**
         * Specifies the video quality.
         * The value can be: **4K**, **2K**, **FHD**, **SD**, **LD** and **HD**.
         */
        quality: string;
        /**
         * Specifies the video width. The value can be **0** or range from **128** to **3840**.
         * Defaults to: **0**. If set to **0**, the system will automatically adjust the `width` according to the `height`.
         */
        width?: number;
    }

}

export namespace Vpc {
    export interface BandwidthPublicip {
        /**
         * The ID of the EIP or IPv6 port that uses the bandwidth.
         */
        id: string;
        /**
         * The IPv4 or IPv6 address.
         */
        ipAddress: string;
        /**
         * The IP version, either 4 or 6.
         */
        ipVersion: number;
        /**
         * The EIP type. Possible values are *5_bgp* (dynamic BGP) and *5_sbgp* (static BGP).
         */
        type: string;
    }

    export interface EipBandwidth {
        /**
         * Specifies whether the bandwidth is billed by traffic or by bandwidth
         * size. The value can be *traffic* or *bandwidth*. Changing this creates a new resource.
         */
        chargeMode: string;
        /**
         * The shared bandwidth id. This parameter is mandatory when
         * `shareType` is set to **WHOLE**. Changing this creates a new resource.
         */
        id: string;
        /**
         * The bandwidth name, which is a string of 1 to 64 characters that contain letters, digits,
         * underscores (_), and hyphens (-). This parameter is mandatory when `shareType` is set to **PER**.
         */
        name: string;
        /**
         * Whether the bandwidth is dedicated or shared. Changing this creates a new
         * resource. Possible values are as follows:
         * + **PER**: Dedicated bandwidth
         * + **WHOLE**: Shared bandwidth
         */
        shareType: string;
        /**
         * The bandwidth size. The value ranges from 1 to 300 Mbit/s. This parameter is mandatory
         * when `shareType` is set to **PER**.
         */
        size: number;
    }

    export interface EipPublicip {
        /**
         * Specifies the EIP to be assigned. The value must be a valid **IPv4**
         * address in the available IP address range. The system automatically assigns an EIP if you do not specify it.
         * Changing this creates a new resource.
         */
        ipAddress: string;
        /**
         * Specifies the IP version, either 4 (default) or 6.
         */
        ipVersion: number;
        /**
         * The port ID which the EIP associated with.
         */
        portId: string;
        /**
         * Specifies the EIP type. Possible values are *5_bgp* (dynamic BGP)
         * and *5_sbgp* (static BGP), the default value is *5_bgp*. Changing this creates a new resource.
         */
        type?: string;
    }

    export interface GetRouteTableRoute {
        description: string;
        destination: string;
        nexthop: string;
        type: string;
    }

    export interface GetSecgroupRule {
        /**
         * The effective policy.
         */
        action: string;
        /**
         * The supplementary information about the security group rule.
         */
        description: string;
        /**
         * The direction of the rule. The value can be *egress* or *ingress*.
         */
        direction: string;
        /**
         * The IP protocol version. The value can be *IPv4* or *IPv6*.
         */
        ethertype: string;
        /**
         * The security group rule ID.
         */
        id: string;
        portRangeMax: number;
        portRangeMin: number;
        /**
         * The port value range.
         */
        ports: string;
        /**
         * The priority number.
         */
        priority: number;
        /**
         * The protocol type.
         */
        protocol: string;
        /**
         * The ID of the remote address group.
         */
        remoteAddressGroupId: string;
        /**
         * The ID of the peer security group.
         */
        remoteGroupId: string;
        /**
         * The remote IP address. The value can be in the CIDR format or IP addresses.
         */
        remoteIpPrefix: string;
    }

    export interface GetSecgroupsSecurityGroup {
        /**
         * The creation time, in UTC format.
         */
        createdAt: string;
        /**
         * Specifies the description of the security group. The security groups can be
         * filtered by keywords in the description.
         */
        description: string;
        /**
         * Specifies the enterprise project ID of the security group.
         */
        enterpriseProjectId: string;
        /**
         * The security group ID.
         */
        id: string;
        /**
         * Specifies the name of the security group.
         */
        name: string;
        /**
         * The last update time, in UTC format.
         */
        updatedAt: string;
    }

    export interface GetSubnetsSubnet {
        /**
         * Specifies the availability zone (AZ) to which the desired subnet belongs to.
         */
        availabilityZone: string;
        /**
         * Specifies the network segment of desired subnet. The value must be in CIDR format.
         */
        cidr: string;
        description: string;
        dhcpEnable: boolean;
        dnsLists: string[];
        /**
         * Specifies the subnet gateway address of desired subnet.
         */
        gatewayIp: string;
        /**
         * - Specifies the id of the desired subnet.
         */
        id: string;
        ipv4SubnetId: string;
        ipv6Cidr: string;
        ipv6Enable: boolean;
        ipv6Gateway: string;
        ipv6SubnetId: string;
        /**
         * Specifies the name of the desired subnet.
         */
        name: string;
        /**
         * Specifies the IP address of DNS server 1 on the desired subnet.
         */
        primaryDns: string;
        /**
         * Specifies the IP address of DNS server 2 on the desired subnet.
         */
        secondaryDns: string;
        /**
         * Specifies the current status of the desired subnet.
         * the value can be ACTIVE, DOWN, UNKNOWN, or ERROR.
         */
        status: string;
        subnetId: string;
        /**
         * Specifies the included key/value pairs which associated with the desired subnet.
         */
        tags: {[key: string]: string};
        /**
         * Specifies the id of the VPC that the desired subnet belongs to.
         */
        vpcId: string;
    }

    export interface GetVpcRoute {
        destination: string;
        nexthop: string;
    }

    export interface GetVpcsVpc {
        /**
         * Specifies the cidr block of the desired VPC.
         */
        cidr: string;
        /**
         * Indicates the description of the VPC.
         */
        description: string;
        /**
         * Specifies the enterprise project ID which the desired VPC belongs to.
         */
        enterpriseProjectId: string;
        /**
         * Specifies the id of the desired VPC.
         */
        id: string;
        /**
         * Specifies the name of the desired VPC. The value is a string of no more than 64 characters
         * and can contain digits, letters, underscores (_) and hyphens (-).
         */
        name: string;
        /**
         * Specifies the current status of the desired VPC. The value can be CREATING, OK or ERROR.
         */
        status: string;
        /**
         * Specifies the included key/value pairs which associated with the desired VPC.
         */
        tags: {[key: string]: string};
    }

    export interface PortAllowedAddressPair {
        ipAddress: string;
        macAddress: string;
    }

    export interface PortExtraDhcpOption {
        ipVersion?: number;
        name: string;
        value: string;
    }

    export interface PortFixedIp {
        ipAddress?: string;
        subnetId: string;
    }

    export interface RouteTableRoute {
        /**
         * - Specifies the supplementary information about the route.
         * The value is a string of no more than 255 characters and cannot contain angle brackets (< or >).
         */
        description?: string;
        /**
         * - Specifies the destination address in the CIDR notation format,
         * for example, 192.168.200.0/24. The destination of each route must be unique and cannot overlap
         * with any subnet in the VPC.
         */
        destination: string;
        /**
         * - Specifies the next hop.
         * + If the route type is **ecs**, the value is an ECS instance ID in the VPC.
         * + If the route type is **eni**, the value is the extension NIC of an ECS in the VPC.
         * + If the route type is **vip**, the value is a virtual IP address.
         * + If the route type is **nat**, the value is a VPN gateway ID.
         * + If the route type is **peering**, the value is a VPC peering connection ID.
         * + If the route type is **vpn**, the value is a VPN gateway ID.
         * + If the route type is **dc**, the value is a Direct Connect gateway ID.
         * + If the route type is **cc**, the value is a Cloud Connection ID.
         */
        nexthop: string;
        /**
         * - Specifies the route type. Currently, the value can be:
         * **ecs**, **eni**, **vip**, **nat**, **peering**, **vpn**, **dc** and **cc**.
         */
        type: string;
    }

    export interface SecgroupRule {
        /**
         * The effective policy.
         */
        action: string;
        /**
         * Specifies the description for the security group.
         */
        description: string;
        /**
         * The direction of the rule. The value can be *egress* or *ingress*.
         */
        direction: string;
        /**
         * The IP protocol version. The value can be *IPv4* or *IPv6*.
         */
        ethertype: string;
        /**
         * The security group rule ID.
         */
        id: string;
        portRangeMax: number;
        portRangeMin: number;
        /**
         * The port value range.
         */
        ports: string;
        /**
         * The priority number.
         */
        priority: number;
        /**
         * The protocol type.
         */
        protocol: string;
        /**
         * The ID of the remote address group.
         */
        remoteAddressGroupId: string;
        /**
         * The ID of the peer security group.
         */
        remoteGroupId: string;
        /**
         * The remote IP address. The value can be in the CIDR format or IP addresses.
         */
        remoteIpPrefix: string;
    }

    export interface VpcRoute {
        destination: string;
        nexthop: string;
    }
}

export namespace Vpcep {
    export interface ApprovalConnection {
        /**
         * The user's domain ID.
         */
        domainId: string;
        /**
         * The unique ID of the VPC endpoint.
         */
        endpointId: string;
        /**
         * The packet ID of the VPC endpoint.
         */
        packetId: number;
        /**
         * The connection status of the VPC endpoint.
         */
        status: string;
    }

    export interface GetPublicServicesService {
        /**
         * The unique ID of the public VPC endpoint service.
         */
        id: string;
        /**
         * Indicates whether the associated VPC endpoint carries a charge.
         */
        isCharge: boolean;
        /**
         * The owner of the VPC endpoint service.
         */
        owner: string;
        /**
         * Specifies the name of the public VPC endpoint service. The value is not
         * case-sensitive and supports fuzzy match.
         */
        serviceName: string;
        /**
         * The type of the VPC endpoint service.
         */
        serviceType: string;
    }

    export interface ServiceConnection {
        /**
         * The user's domain ID.
         */
        domainId: string;
        /**
         * The unique ID of the VPC endpoint.
         */
        endpointId: string;
        /**
         * The packet ID of the VPC endpoint.
         */
        packetId: number;
        /**
         * The connection status of the VPC endpoint.
         */
        status: string;
    }

    export interface ServicePortMapping {
        /**
         * Specifies the protocol used in port mappings. The value can be **TCP** or **UDP**. The
         * default value is **TCP**.
         */
        protocol?: string;
        /**
         * Specifies the port for accessing the VPC endpoint service. This port is provided by
         * the backend service to provide services. The value ranges from 1 to 65535.
         */
        servicePort?: number;
        /**
         * Specifies the port for accessing the VPC endpoint. This port is provided by the VPC
         * endpoint, allowing you to access the VPC endpoint service. The value ranges from 1 to 65535.
         */
        terminalPort?: number;
    }

}

export namespace Waf {
    export interface DedicatedDomainServer {
        /**
         * IP address or domain name of the web server that the client accesses. For
         * example, 192.168.1.1 or www.example.com. Changing this creates a new service.
         */
        address: string;
        /**
         * Protocol type of the client. The options include `HTTP` and `HTTPS`.
         * Changing this creates a new service.
         */
        clientProtocol: string;
        /**
         * Port number used by the web server. The value ranges from 0 to 65535. Changing this
         * creates a new service.
         */
        port: number;
        /**
         * Protocol used by WAF to forward client requests to the server. The
         * options include `HTTP` and `HTTPS`. Changing this creates a new service.
         */
        serverProtocol: string;
        /**
         * Server network type, IPv4 or IPv6. Valid values are: `ipv4` and `ipv6`. Changing
         * this creates a new service.
         */
        type: string;
        /**
         * The id of the vpc used by the server. Changing this creates a service.
         */
        vpcId: string;
    }

    export interface DomainServer {
        /**
         * IP address or domain name of the web server that the client accesses. For example,
         * 192.168.1.1 or www.a.com.
         */
        address: string;
        /**
         * Protocol type of the client. The options include `HTTP` and `HTTPS`.
         */
        clientProtocol: string;
        /**
         * Port number used by the web server. The value ranges from 0 to 65535, for example, 8080.
         */
        port: number;
        /**
         * Protocol used by WAF to forward client requests to the server. The options
         * include `HTTP` and `HTTPS`.
         */
        serverProtocol: string;
    }

    export interface GetDedicatedInstancesInstance {
        /**
         * The access status of the instance. `0`: inaccessible, `1`: accessible.
         */
        accessStatus: number;
        /**
         * The available zone names for the WAF dedicated instances.
         */
        availableZone: string;
        /**
         * The ECS cpu architecture of WAF dedicated instance.
         */
        cpuArchitecture: string;
        cpuFlavor: string;
        /**
         * The instance group ID used by the WAF dedicated instance in ELB mode.
         */
        groupId: string;
        /**
         * The id of WAF dedicated instance.
         */
        id: string;
        /**
         * The name of WAF dedicated instance.
         */
        name: string;
        /**
         * The running status of the instance. Values are:
         */
        runStatus: number;
        /**
         * The security group of the instance. This is an array of security group ids.
         */
        securityGroups: string[];
        /**
         * The service of the instance.
         */
        serverId: string;
        /**
         * The service ip of the instance.
         */
        serviceIp: string;
        /**
         * The subnet id of WAF dedicated instance VPC.
         */
        subnetId: string;
        /**
         * The instance is to support upgrades. `0`: Cannot be upgraded, `1`: Can be upgraded.
         */
        upgradable: number;
        /**
         * The VPC id of WAF dedicated instance.
         */
        vpcId: string;
    }

    export interface GetInstanceGroupsGroup {
        /**
         * The body limit of the forwarding policy.
         */
        bodyLimit: number;
        /**
         * The time for connection timeout in the forwarding policy.
         */
        connectionTimeout: number;
        dedicatedInstances: outputs.Waf.GetInstanceGroupsGroupDedicatedInstance[];
        /**
         * Description of the instance group.
         */
        description: string;
        domainNames: outputs.Waf.GetInstanceGroupsGroupDomainName[];
        /**
         * The header limit of the forwarding policy.
         */
        headerLimit: number;
        /**
         * The IDs of the ELB instances that has been bound to the instance group.
         */
        loadBalancers: string[];
        /**
         * The name of WAF instance group used for matching.
         * The value is not case-sensitive and supports fuzzy matching.
         */
        name: string;
        /**
         * The time for reading timeout in the forwarding policy.
         */
        readTimeout: number;
        /**
         * The region in which to obtain the WAF instance groups.
         * If omitted, the provider-level region will be used.
         */
        region: string;
        /**
         * The id of the VPC that the WAF dedicated instances belongs to.
         */
        vpcId: string;
        /**
         * The time for writing timeout in the forwarding policy.
         */
        writeTimeout: number;
    }

    export interface GetInstanceGroupsGroupDedicatedInstance {
        id: string;
        /**
         * The name of WAF instance group used for matching.
         * The value is not case-sensitive and supports fuzzy matching.
         */
        name: string;
    }

    export interface GetInstanceGroupsGroupDomainName {
        id: string;
        /**
         * The name of WAF instance group used for matching.
         * The value is not case-sensitive and supports fuzzy matching.
         */
        name: string;
    }

    export interface GetPoliciesPolicy {
        /**
         * The detection mode in Precise Protection.
         * + `true`: full detection. Full detection finishes all threat detections before blocking requests that meet Precise
         * Protection specified conditions.
         * + `false`: instant detection. Instant detection immediately ends threat detection after blocking a request that
         * meets Precise Protection specified conditions.
         */
        fullDetection: boolean;
        /**
         * The WAF Policy ID.
         */
        id: string;
        /**
         * Specifies the protection level. Valid values are:
         * + `1`: low
         * + `2`: medium
         * + `3`: high
         */
        level: number;
        /**
         * Policy name used for matching. The value is case sensitive and supports fuzzy matching.
         */
        name: string;
        /**
         * The protection switches. The options object structure is documented below.
         */
        options: outputs.Waf.GetPoliciesPolicyOption[];
        /**
         * Specifies the protective action after a rule is matched. Valid values are:
         * + `block`: WAF blocks and logs detected attacks.
         * + `log`: WAF logs detected attacks only.
         */
        protectionMode: string;
    }

    export interface GetPoliciesPolicyOption {
        /**
         * Indicates whether Basic Web Protection is enabled.
         */
        basicWebProtection: boolean;
        /**
         * Indicates whether Blacklist and Whitelist is enabled.
         */
        blacklist: boolean;
        /**
         * Indicates whether CC Attack Protection is enabled.
         */
        ccAttackProtection: boolean;
        /**
         * Indicates whether the master crawler detection switch in Basic Web Protection is enabled.
         */
        crawler: boolean;
        /**
         * Indicates whether the Search Engine switch in Basic Web Protection is enabled.
         */
        crawlerEngine: boolean;
        /**
         * Indicates whether detection of other crawlers in Basic Web Protection is enabled.
         */
        crawlerOther: boolean;
        /**
         * Indicates whether the Scanner switch in Basic Web Protection is enabled.
         */
        crawlerScanner: boolean;
        /**
         * Indicates whether the Script Tool switch in Basic Web Protection is enabled.
         */
        crawlerScript: boolean;
        /**
         * Indicates whether Data Masking is enabled.
         */
        dataMasking: boolean;
        /**
         * Indicates whether False Alarm Masking is enabled.
         */
        falseAlarmMasking: boolean;
        /**
         * Indicates whether General Check in Basic Web Protection is enabled.
         */
        generalCheck: boolean;
        /**
         * Indicates whether Precise Protection is enabled.
         */
        preciseProtection: boolean;
        /**
         * Indicates whether Web Tamper Protection is enabled.
         */
        webTamperProtection: boolean;
        /**
         * Indicates whether webshell detection in Basic Web Protection is enabled.
         */
        webshell: boolean;
    }

    export interface GetReferenceTablesTable {
        /**
         * The conditions of the reference table.
         */
        conditions: string[];
        /**
         * The server time when reference table was created.
         */
        creationTime: string;
        /**
         * The description of the reference table.
         */
        description: string;
        /**
         * The id of the reference table.
         */
        id: string;
        /**
         * The name of the reference table. The value is case sensitive and matches exactly.
         */
        name: string;
        /**
         * The type of the reference table, The options are: `url`, `user-agent`, `ip`, `params`, `cookie`, `referer`
         * and `header`.
         */
        type: string;
    }

    export interface PolicyOption {
        /**
         * Indicates whether Basic Web Protection is enabled.
         */
        basicWebProtection: boolean;
        /**
         * Indicates whether Blacklist and Whitelist is enabled.
         */
        blacklist: boolean;
        /**
         * Indicates whether CC Attack Protection is enabled.
         */
        ccAttackProtection: boolean;
        /**
         * Indicates whether the master crawler detection switch in Basic Web Protection is enabled.
         */
        crawler: boolean;
        /**
         * Indicates whether the Search Engine switch in Basic Web Protection is enabled.
         */
        crawlerEngine: boolean;
        /**
         * Indicates whether detection of other crawlers in Basic Web Protection is enabled.
         */
        crawlerOther: boolean;
        /**
         * Indicates whether the Scanner switch in Basic Web Protection is enabled.
         */
        crawlerScanner: boolean;
        /**
         * Indicates whether the Script Tool switch in Basic Web Protection is enabled.
         */
        crawlerScript: boolean;
        /**
         * Indicates whether Data Masking is enabled.
         */
        dataMasking: boolean;
        /**
         * Indicates whether False Alarm Masking is enabled.
         */
        falseAlarmMasking: boolean;
        /**
         * Indicates whether General Check in Basic Web Protection is enabled.
         */
        generalCheck: boolean;
        /**
         * Indicates whether Precise Protection is enabled.
         */
        preciseProtection: boolean;
        /**
         * Indicates whether Web Tamper Protection is enabled.
         */
        webTamperProtection: boolean;
        /**
         * Indicates whether webshell detection in Basic Web Protection is enabled.
         */
        webshell: boolean;
    }
}

export namespace Workspace {
    export interface DesktopDataVolume {
        /**
         * The time that the volume was created.
         */
        createdAt: string;
        /**
         * The device location to which the volume is attached.
         */
        device: string;
        /**
         * The volume ID.
         */
        id: string;
        /**
         * Specifies the desktop name.
         * The name can contain `1` to `15` characters, only letters, digits and hyphens (-) are allowed.
         * The name must start with a letter or digit and cannot end with a hyphen.
         * Changing this will create a new resource.
         */
        name: string;
        /**
         * Specifies the size of system volume, in GB.
         * + For root volume, the valid value is range from `80` to `1,020`.
         * + For data volume, the valid value is range from `10` to `8,200`.
         */
        size: number;
        /**
         * Specifies the type of system volume.
         * The valid values are as follows:
         * + **SAS**: High I/O disk type.
         * + **SSD**: Ultra-high I/O disk type.
         */
        type: string;
    }

    export interface DesktopNic {
        /**
         * Specifies the network ID of subnet resource.
         * Changing this will create a new resource.
         */
        networkId: string;
    }

    export interface DesktopRootVolume {
        /**
         * The time that the volume was created.
         */
        createdAt: string;
        /**
         * The device location to which the volume is attached.
         */
        device: string;
        /**
         * The volume ID.
         */
        id: string;
        /**
         * Specifies the desktop name.
         * The name can contain `1` to `15` characters, only letters, digits and hyphens (-) are allowed.
         * The name must start with a letter or digit and cannot end with a hyphen.
         * Changing this will create a new resource.
         */
        name: string;
        /**
         * Specifies the size of system volume, in GB.
         * + For root volume, the valid value is range from `80` to `1,020`.
         * + For data volume, the valid value is range from `10` to `8,200`.
         */
        size: number;
        /**
         * Specifies the type of system volume.
         * The valid values are as follows:
         * + **SAS**: High I/O disk type.
         * + **SSD**: Ultra-high I/O disk type.
         */
        type: string;
    }

    export interface ServiceAdDomain {
        /**
         * Specifies the primary DNS IP address.
         */
        activeDnsIp?: string;
        /**
         * Specifies the IP address of primary domain controller.
         */
        activeDomainIp: string;
        /**
         * Specifies the name of primary domain controller.
         */
        activeDomainName: string;
        /**
         * Specifies the domain administrator account.
         * It must be an existing domain administrator account on the AD server.
         */
        adminAccount: string;
        /**
         * Specifies whether to delete the corresponding computer object on AD
         * while deleting the desktop.
         */
        deleteComputerObject: boolean;
        /**
         * Specifies the domain name.
         * The domain name must be an existing domain name on the AD server, and the length cannot exceed `55`.
         */
        name: string;
        /**
         * Specifies the account password of domain administrator.
         */
        password: string;
        /**
         * Specifies the standby DNS IP address.
         */
        standbyDnsIp?: string;
        /**
         * Specifies the IP address of the standby domain controller.
         */
        standbyDomainIp?: string;
        /**
         * Specifies the name of the standby domain controller.
         */
        standbyDomainName?: string;
    }

    export interface ServiceDesktopSecurityGroup {
        /**
         * Security group ID.
         */
        id: string;
        /**
         * Specifies the domain name.
         * The domain name must be an existing domain name on the AD server, and the length cannot exceed `55`.
         */
        name: string;
    }

    export interface ServiceInfrastructureSecurityGroup {
        /**
         * Security group ID.
         */
        id: string;
        /**
         * Specifies the domain name.
         * The domain name must be an existing domain name on the AD server, and the length cannot exceed `55`.
         */
        name: string;
    }

}

export namespace config {
    export interface AssumeRole {
        agencyName: string;
        domainName: string;
    }

}
