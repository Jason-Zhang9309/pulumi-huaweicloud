// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package live

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a recording template within HuaweiCloud Live.
//
// ## Example Usage
// ### Create a recording template for an ingest domain name
//
// ```go
// package main
//
// import (
//
//	"github.com/huaweicloud/pulumi-huaweicloud/sdk/go/huaweicloud/Live"
//	"github.com/pulumi/pulumi-huaweicloud/sdk/go/huaweicloud/Live"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			cfg := config.New(ctx, "")
//			ingestDomainName := cfg.RequireObject("ingestDomainName")
//			bucketRegion := cfg.RequireObject("bucketRegion")
//			bucketName := cfg.RequireObject("bucketName")
//			ingestDomain, err := Live.NewDomain(ctx, "ingestDomain", &Live.DomainArgs{
//				Type: pulumi.String("push"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = Live.NewRecording(ctx, "recording", &Live.RecordingArgs{
//				DomainName: ingestDomain.Name,
//				AppName:    pulumi.String("live"),
//				StreamName: pulumi.String("stream_name"),
//				Type:       pulumi.String("CONTINUOUS_RECORD"),
//				Obs: &live.RecordingObsArgs{
//					Region: pulumi.Any(bucketRegion),
//					Bucket: pulumi.Any(bucketName),
//				},
//				Hls: &live.RecordingHlsArgs{
//					RecordingLength: pulumi.Int(15),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Recording templates can be imported using the `id`, e.g.
//
// ```sh
//
//	$ pulumi import huaweicloud:Live/recording:Recording test 55534eaa-533a-419d-9b40-ec427ea7195a
//
// ```
type Recording struct {
	pulumi.CustomResourceState

	// Specifies the application name. To match all names, use an asterisk (*).
	AppName pulumi.StringOutput `pulumi:"appName"`
	// Specifies the ingest domain name.
	DomainName pulumi.StringOutput `pulumi:"domainName"`
	// Specifies the FLV configuration rule for storing recording as FLV.
	// The flv structure is documented below.
	Flv RecordingFlvPtrOutput `pulumi:"flv"`
	// Specifies the HLS configuration rule for storing recording as HLS.
	// The hls structure is documented below.
	Hls RecordingHlsPtrOutput `pulumi:"hls"`
	// Specifies the MP4 configuration rule for storing recording as MP4.
	// The mp4 structure is documented below.
	Mp4 RecordingMp4PtrOutput `pulumi:"mp4"`
	// Specifies the obs for storing recordings.
	// The obs structure is documented below.
	Obs RecordingObsOutput `pulumi:"obs"`
	// Specifies the region of OBS.
	Region pulumi.StringOutput `pulumi:"region"`
	// Specifies the stream name. To match all names, use an asterisk (*).
	StreamName pulumi.StringOutput `pulumi:"streamName"`
	// Specifies the types of recording notifications. The options are as follows:
	// + **CONTINUOUS_RECORD**: continuous recording. Recording is triggered once streams are pushed to the recording system.
	// + **COMMAND_RECORD**: command-based recording. Tenants need to run commands to start and stop recording after streams
	//   are pushed to the recording system.
	Type pulumi.StringOutput `pulumi:"type"`
}

// NewRecording registers a new resource with the given unique name, arguments, and options.
func NewRecording(ctx *pulumi.Context,
	name string, args *RecordingArgs, opts ...pulumi.ResourceOption) (*Recording, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AppName == nil {
		return nil, errors.New("invalid value for required argument 'AppName'")
	}
	if args.DomainName == nil {
		return nil, errors.New("invalid value for required argument 'DomainName'")
	}
	if args.Obs == nil {
		return nil, errors.New("invalid value for required argument 'Obs'")
	}
	if args.StreamName == nil {
		return nil, errors.New("invalid value for required argument 'StreamName'")
	}
	var resource Recording
	err := ctx.RegisterResource("huaweicloud:Live/recording:Recording", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRecording gets an existing Recording resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRecording(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RecordingState, opts ...pulumi.ResourceOption) (*Recording, error) {
	var resource Recording
	err := ctx.ReadResource("huaweicloud:Live/recording:Recording", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Recording resources.
type recordingState struct {
	// Specifies the application name. To match all names, use an asterisk (*).
	AppName *string `pulumi:"appName"`
	// Specifies the ingest domain name.
	DomainName *string `pulumi:"domainName"`
	// Specifies the FLV configuration rule for storing recording as FLV.
	// The flv structure is documented below.
	Flv *RecordingFlv `pulumi:"flv"`
	// Specifies the HLS configuration rule for storing recording as HLS.
	// The hls structure is documented below.
	Hls *RecordingHls `pulumi:"hls"`
	// Specifies the MP4 configuration rule for storing recording as MP4.
	// The mp4 structure is documented below.
	Mp4 *RecordingMp4 `pulumi:"mp4"`
	// Specifies the obs for storing recordings.
	// The obs structure is documented below.
	Obs *RecordingObs `pulumi:"obs"`
	// Specifies the region of OBS.
	Region *string `pulumi:"region"`
	// Specifies the stream name. To match all names, use an asterisk (*).
	StreamName *string `pulumi:"streamName"`
	// Specifies the types of recording notifications. The options are as follows:
	// + **CONTINUOUS_RECORD**: continuous recording. Recording is triggered once streams are pushed to the recording system.
	// + **COMMAND_RECORD**: command-based recording. Tenants need to run commands to start and stop recording after streams
	//   are pushed to the recording system.
	Type *string `pulumi:"type"`
}

type RecordingState struct {
	// Specifies the application name. To match all names, use an asterisk (*).
	AppName pulumi.StringPtrInput
	// Specifies the ingest domain name.
	DomainName pulumi.StringPtrInput
	// Specifies the FLV configuration rule for storing recording as FLV.
	// The flv structure is documented below.
	Flv RecordingFlvPtrInput
	// Specifies the HLS configuration rule for storing recording as HLS.
	// The hls structure is documented below.
	Hls RecordingHlsPtrInput
	// Specifies the MP4 configuration rule for storing recording as MP4.
	// The mp4 structure is documented below.
	Mp4 RecordingMp4PtrInput
	// Specifies the obs for storing recordings.
	// The obs structure is documented below.
	Obs RecordingObsPtrInput
	// Specifies the region of OBS.
	Region pulumi.StringPtrInput
	// Specifies the stream name. To match all names, use an asterisk (*).
	StreamName pulumi.StringPtrInput
	// Specifies the types of recording notifications. The options are as follows:
	// + **CONTINUOUS_RECORD**: continuous recording. Recording is triggered once streams are pushed to the recording system.
	// + **COMMAND_RECORD**: command-based recording. Tenants need to run commands to start and stop recording after streams
	//   are pushed to the recording system.
	Type pulumi.StringPtrInput
}

func (RecordingState) ElementType() reflect.Type {
	return reflect.TypeOf((*recordingState)(nil)).Elem()
}

type recordingArgs struct {
	// Specifies the application name. To match all names, use an asterisk (*).
	AppName string `pulumi:"appName"`
	// Specifies the ingest domain name.
	DomainName string `pulumi:"domainName"`
	// Specifies the FLV configuration rule for storing recording as FLV.
	// The flv structure is documented below.
	Flv *RecordingFlv `pulumi:"flv"`
	// Specifies the HLS configuration rule for storing recording as HLS.
	// The hls structure is documented below.
	Hls *RecordingHls `pulumi:"hls"`
	// Specifies the MP4 configuration rule for storing recording as MP4.
	// The mp4 structure is documented below.
	Mp4 *RecordingMp4 `pulumi:"mp4"`
	// Specifies the obs for storing recordings.
	// The obs structure is documented below.
	Obs RecordingObs `pulumi:"obs"`
	// Specifies the region of OBS.
	Region *string `pulumi:"region"`
	// Specifies the stream name. To match all names, use an asterisk (*).
	StreamName string `pulumi:"streamName"`
	// Specifies the types of recording notifications. The options are as follows:
	// + **CONTINUOUS_RECORD**: continuous recording. Recording is triggered once streams are pushed to the recording system.
	// + **COMMAND_RECORD**: command-based recording. Tenants need to run commands to start and stop recording after streams
	//   are pushed to the recording system.
	Type *string `pulumi:"type"`
}

// The set of arguments for constructing a Recording resource.
type RecordingArgs struct {
	// Specifies the application name. To match all names, use an asterisk (*).
	AppName pulumi.StringInput
	// Specifies the ingest domain name.
	DomainName pulumi.StringInput
	// Specifies the FLV configuration rule for storing recording as FLV.
	// The flv structure is documented below.
	Flv RecordingFlvPtrInput
	// Specifies the HLS configuration rule for storing recording as HLS.
	// The hls structure is documented below.
	Hls RecordingHlsPtrInput
	// Specifies the MP4 configuration rule for storing recording as MP4.
	// The mp4 structure is documented below.
	Mp4 RecordingMp4PtrInput
	// Specifies the obs for storing recordings.
	// The obs structure is documented below.
	Obs RecordingObsInput
	// Specifies the region of OBS.
	Region pulumi.StringPtrInput
	// Specifies the stream name. To match all names, use an asterisk (*).
	StreamName pulumi.StringInput
	// Specifies the types of recording notifications. The options are as follows:
	// + **CONTINUOUS_RECORD**: continuous recording. Recording is triggered once streams are pushed to the recording system.
	// + **COMMAND_RECORD**: command-based recording. Tenants need to run commands to start and stop recording after streams
	//   are pushed to the recording system.
	Type pulumi.StringPtrInput
}

func (RecordingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*recordingArgs)(nil)).Elem()
}

type RecordingInput interface {
	pulumi.Input

	ToRecordingOutput() RecordingOutput
	ToRecordingOutputWithContext(ctx context.Context) RecordingOutput
}

func (*Recording) ElementType() reflect.Type {
	return reflect.TypeOf((**Recording)(nil)).Elem()
}

func (i *Recording) ToRecordingOutput() RecordingOutput {
	return i.ToRecordingOutputWithContext(context.Background())
}

func (i *Recording) ToRecordingOutputWithContext(ctx context.Context) RecordingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecordingOutput)
}

// RecordingArrayInput is an input type that accepts RecordingArray and RecordingArrayOutput values.
// You can construct a concrete instance of `RecordingArrayInput` via:
//
//	RecordingArray{ RecordingArgs{...} }
type RecordingArrayInput interface {
	pulumi.Input

	ToRecordingArrayOutput() RecordingArrayOutput
	ToRecordingArrayOutputWithContext(context.Context) RecordingArrayOutput
}

type RecordingArray []RecordingInput

func (RecordingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Recording)(nil)).Elem()
}

func (i RecordingArray) ToRecordingArrayOutput() RecordingArrayOutput {
	return i.ToRecordingArrayOutputWithContext(context.Background())
}

func (i RecordingArray) ToRecordingArrayOutputWithContext(ctx context.Context) RecordingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecordingArrayOutput)
}

// RecordingMapInput is an input type that accepts RecordingMap and RecordingMapOutput values.
// You can construct a concrete instance of `RecordingMapInput` via:
//
//	RecordingMap{ "key": RecordingArgs{...} }
type RecordingMapInput interface {
	pulumi.Input

	ToRecordingMapOutput() RecordingMapOutput
	ToRecordingMapOutputWithContext(context.Context) RecordingMapOutput
}

type RecordingMap map[string]RecordingInput

func (RecordingMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Recording)(nil)).Elem()
}

func (i RecordingMap) ToRecordingMapOutput() RecordingMapOutput {
	return i.ToRecordingMapOutputWithContext(context.Background())
}

func (i RecordingMap) ToRecordingMapOutputWithContext(ctx context.Context) RecordingMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecordingMapOutput)
}

type RecordingOutput struct{ *pulumi.OutputState }

func (RecordingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Recording)(nil)).Elem()
}

func (o RecordingOutput) ToRecordingOutput() RecordingOutput {
	return o
}

func (o RecordingOutput) ToRecordingOutputWithContext(ctx context.Context) RecordingOutput {
	return o
}

// Specifies the application name. To match all names, use an asterisk (*).
func (o RecordingOutput) AppName() pulumi.StringOutput {
	return o.ApplyT(func(v *Recording) pulumi.StringOutput { return v.AppName }).(pulumi.StringOutput)
}

// Specifies the ingest domain name.
func (o RecordingOutput) DomainName() pulumi.StringOutput {
	return o.ApplyT(func(v *Recording) pulumi.StringOutput { return v.DomainName }).(pulumi.StringOutput)
}

// Specifies the FLV configuration rule for storing recording as FLV.
// The flv structure is documented below.
func (o RecordingOutput) Flv() RecordingFlvPtrOutput {
	return o.ApplyT(func(v *Recording) RecordingFlvPtrOutput { return v.Flv }).(RecordingFlvPtrOutput)
}

// Specifies the HLS configuration rule for storing recording as HLS.
// The hls structure is documented below.
func (o RecordingOutput) Hls() RecordingHlsPtrOutput {
	return o.ApplyT(func(v *Recording) RecordingHlsPtrOutput { return v.Hls }).(RecordingHlsPtrOutput)
}

// Specifies the MP4 configuration rule for storing recording as MP4.
// The mp4 structure is documented below.
func (o RecordingOutput) Mp4() RecordingMp4PtrOutput {
	return o.ApplyT(func(v *Recording) RecordingMp4PtrOutput { return v.Mp4 }).(RecordingMp4PtrOutput)
}

// Specifies the obs for storing recordings.
// The obs structure is documented below.
func (o RecordingOutput) Obs() RecordingObsOutput {
	return o.ApplyT(func(v *Recording) RecordingObsOutput { return v.Obs }).(RecordingObsOutput)
}

// Specifies the region of OBS.
func (o RecordingOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *Recording) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// Specifies the stream name. To match all names, use an asterisk (*).
func (o RecordingOutput) StreamName() pulumi.StringOutput {
	return o.ApplyT(func(v *Recording) pulumi.StringOutput { return v.StreamName }).(pulumi.StringOutput)
}

// Specifies the types of recording notifications. The options are as follows:
//   - **CONTINUOUS_RECORD**: continuous recording. Recording is triggered once streams are pushed to the recording system.
//   - **COMMAND_RECORD**: command-based recording. Tenants need to run commands to start and stop recording after streams
//     are pushed to the recording system.
func (o RecordingOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *Recording) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

type RecordingArrayOutput struct{ *pulumi.OutputState }

func (RecordingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Recording)(nil)).Elem()
}

func (o RecordingArrayOutput) ToRecordingArrayOutput() RecordingArrayOutput {
	return o
}

func (o RecordingArrayOutput) ToRecordingArrayOutputWithContext(ctx context.Context) RecordingArrayOutput {
	return o
}

func (o RecordingArrayOutput) Index(i pulumi.IntInput) RecordingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Recording {
		return vs[0].([]*Recording)[vs[1].(int)]
	}).(RecordingOutput)
}

type RecordingMapOutput struct{ *pulumi.OutputState }

func (RecordingMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Recording)(nil)).Elem()
}

func (o RecordingMapOutput) ToRecordingMapOutput() RecordingMapOutput {
	return o
}

func (o RecordingMapOutput) ToRecordingMapOutputWithContext(ctx context.Context) RecordingMapOutput {
	return o
}

func (o RecordingMapOutput) MapIndex(k pulumi.StringInput) RecordingOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Recording {
		return vs[0].(map[string]*Recording)[vs[1].(string)]
	}).(RecordingOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RecordingInput)(nil)).Elem(), &Recording{})
	pulumi.RegisterInputType(reflect.TypeOf((*RecordingArrayInput)(nil)).Elem(), RecordingArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RecordingMapInput)(nil)).Elem(), RecordingMap{})
	pulumi.RegisterOutputType(RecordingOutput{})
	pulumi.RegisterOutputType(RecordingArrayOutput{})
	pulumi.RegisterOutputType(RecordingMapOutput{})
}
