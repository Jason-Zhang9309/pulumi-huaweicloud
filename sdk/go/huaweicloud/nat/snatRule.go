// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package nat

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a SNAT rule resource within HuaweiCloud.
//
// ## Example Usage
// ### SNAT rule in VPC scenario
//
// ```go
// package main
//
// import (
//
//	"github.com/huaweicloud/pulumi-huaweicloud/sdk/go/huaweicloud/Nat"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := Nat.NewSnatRule(ctx, "snat1", &Nat.SnatRuleArgs{
//				NatGatewayId: pulumi.Any(_var.Natgw_id),
//				FloatingIpId: pulumi.Any(_var.Publicip_id),
//				SubnetId:     pulumi.Any(_var.Subent_id),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### SNAT rule in Direct Connect scenario
//
// ```go
// package main
//
// import (
//
//	"github.com/huaweicloud/pulumi-huaweicloud/sdk/go/huaweicloud/Nat"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := Nat.NewSnatRule(ctx, "snat2", &Nat.SnatRuleArgs{
//				NatGatewayId: pulumi.Any(_var.Natgw_id),
//				FloatingIpId: pulumi.Any(_var.Publicip_id),
//				SourceType:   pulumi.Int(1),
//				Cidr:         pulumi.String("192.168.10.0/24"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// # SNAT rules can be imported using the following format
//
// ```sh
//
//	$ pulumi import huaweicloud:Nat/snatRule:SnatRule snat_1 9e0713cb-0a2f-484e-8c7d-daecbb61dbe4
//
// ```
type SnatRule struct {
	pulumi.CustomResourceState

	// Specifies CIDR, which can be in the format of a network segment or a host IP
	// address. This parameter and `subnetId` are alternative. Changing this creates a new snat rule.
	Cidr pulumi.StringPtrOutput `pulumi:"cidr"`
	// Specifies the description of the snat rule.
	// The value is a string of no more than 255 characters, and angle brackets (<>) are not allowed.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The actual floating IP address.
	FloatingIpAddress pulumi.StringOutput `pulumi:"floatingIpAddress"`
	// Specifies the EIP ID this snat rule connects to.
	// Multiple EIPs are separated using commas (,). The number of EIP IDs cannot exceed 20.
	FloatingIpId pulumi.StringOutput `pulumi:"floatingIpId"`
	// ID of the nat gateway this snat rule belongs to. Changing this creates
	// a new snat rule.
	NatGatewayId pulumi.StringOutput `pulumi:"natGatewayId"`
	// Deprecated: use subnet_id instead
	NetworkId pulumi.StringPtrOutput `pulumi:"networkId"`
	// The region in which to create the snat rule resource. If omitted, the
	// provider-level region will be used. Changing this creates a new snat rule resource.
	Region pulumi.StringOutput `pulumi:"region"`
	// Specifies the scenario. The valid value is 0 (VPC scenario) and 1 (Direct
	// Connect scenario). Defaults to 0, only `cidr` can be specified over a Direct Connect connection. Changing this creates
	// a new snat rule.
	SourceType pulumi.IntPtrOutput `pulumi:"sourceType"`
	// The status of the snat rule.
	Status pulumi.StringOutput `pulumi:"status"`
	// ID of the subnet this snat rule connects to. This parameter and `cidr` are
	// alternative. Changing this creates a new snat rule.
	SubnetId pulumi.StringOutput `pulumi:"subnetId"`
}

// NewSnatRule registers a new resource with the given unique name, arguments, and options.
func NewSnatRule(ctx *pulumi.Context,
	name string, args *SnatRuleArgs, opts ...pulumi.ResourceOption) (*SnatRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.FloatingIpId == nil {
		return nil, errors.New("invalid value for required argument 'FloatingIpId'")
	}
	if args.NatGatewayId == nil {
		return nil, errors.New("invalid value for required argument 'NatGatewayId'")
	}
	var resource SnatRule
	err := ctx.RegisterResource("huaweicloud:Nat/snatRule:SnatRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSnatRule gets an existing SnatRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSnatRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SnatRuleState, opts ...pulumi.ResourceOption) (*SnatRule, error) {
	var resource SnatRule
	err := ctx.ReadResource("huaweicloud:Nat/snatRule:SnatRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SnatRule resources.
type snatRuleState struct {
	// Specifies CIDR, which can be in the format of a network segment or a host IP
	// address. This parameter and `subnetId` are alternative. Changing this creates a new snat rule.
	Cidr *string `pulumi:"cidr"`
	// Specifies the description of the snat rule.
	// The value is a string of no more than 255 characters, and angle brackets (<>) are not allowed.
	Description *string `pulumi:"description"`
	// The actual floating IP address.
	FloatingIpAddress *string `pulumi:"floatingIpAddress"`
	// Specifies the EIP ID this snat rule connects to.
	// Multiple EIPs are separated using commas (,). The number of EIP IDs cannot exceed 20.
	FloatingIpId *string `pulumi:"floatingIpId"`
	// ID of the nat gateway this snat rule belongs to. Changing this creates
	// a new snat rule.
	NatGatewayId *string `pulumi:"natGatewayId"`
	// Deprecated: use subnet_id instead
	NetworkId *string `pulumi:"networkId"`
	// The region in which to create the snat rule resource. If omitted, the
	// provider-level region will be used. Changing this creates a new snat rule resource.
	Region *string `pulumi:"region"`
	// Specifies the scenario. The valid value is 0 (VPC scenario) and 1 (Direct
	// Connect scenario). Defaults to 0, only `cidr` can be specified over a Direct Connect connection. Changing this creates
	// a new snat rule.
	SourceType *int `pulumi:"sourceType"`
	// The status of the snat rule.
	Status *string `pulumi:"status"`
	// ID of the subnet this snat rule connects to. This parameter and `cidr` are
	// alternative. Changing this creates a new snat rule.
	SubnetId *string `pulumi:"subnetId"`
}

type SnatRuleState struct {
	// Specifies CIDR, which can be in the format of a network segment or a host IP
	// address. This parameter and `subnetId` are alternative. Changing this creates a new snat rule.
	Cidr pulumi.StringPtrInput
	// Specifies the description of the snat rule.
	// The value is a string of no more than 255 characters, and angle brackets (<>) are not allowed.
	Description pulumi.StringPtrInput
	// The actual floating IP address.
	FloatingIpAddress pulumi.StringPtrInput
	// Specifies the EIP ID this snat rule connects to.
	// Multiple EIPs are separated using commas (,). The number of EIP IDs cannot exceed 20.
	FloatingIpId pulumi.StringPtrInput
	// ID of the nat gateway this snat rule belongs to. Changing this creates
	// a new snat rule.
	NatGatewayId pulumi.StringPtrInput
	// Deprecated: use subnet_id instead
	NetworkId pulumi.StringPtrInput
	// The region in which to create the snat rule resource. If omitted, the
	// provider-level region will be used. Changing this creates a new snat rule resource.
	Region pulumi.StringPtrInput
	// Specifies the scenario. The valid value is 0 (VPC scenario) and 1 (Direct
	// Connect scenario). Defaults to 0, only `cidr` can be specified over a Direct Connect connection. Changing this creates
	// a new snat rule.
	SourceType pulumi.IntPtrInput
	// The status of the snat rule.
	Status pulumi.StringPtrInput
	// ID of the subnet this snat rule connects to. This parameter and `cidr` are
	// alternative. Changing this creates a new snat rule.
	SubnetId pulumi.StringPtrInput
}

func (SnatRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*snatRuleState)(nil)).Elem()
}

type snatRuleArgs struct {
	// Specifies CIDR, which can be in the format of a network segment or a host IP
	// address. This parameter and `subnetId` are alternative. Changing this creates a new snat rule.
	Cidr *string `pulumi:"cidr"`
	// Specifies the description of the snat rule.
	// The value is a string of no more than 255 characters, and angle brackets (<>) are not allowed.
	Description *string `pulumi:"description"`
	// Specifies the EIP ID this snat rule connects to.
	// Multiple EIPs are separated using commas (,). The number of EIP IDs cannot exceed 20.
	FloatingIpId string `pulumi:"floatingIpId"`
	// ID of the nat gateway this snat rule belongs to. Changing this creates
	// a new snat rule.
	NatGatewayId string `pulumi:"natGatewayId"`
	// Deprecated: use subnet_id instead
	NetworkId *string `pulumi:"networkId"`
	// The region in which to create the snat rule resource. If omitted, the
	// provider-level region will be used. Changing this creates a new snat rule resource.
	Region *string `pulumi:"region"`
	// Specifies the scenario. The valid value is 0 (VPC scenario) and 1 (Direct
	// Connect scenario). Defaults to 0, only `cidr` can be specified over a Direct Connect connection. Changing this creates
	// a new snat rule.
	SourceType *int `pulumi:"sourceType"`
	// ID of the subnet this snat rule connects to. This parameter and `cidr` are
	// alternative. Changing this creates a new snat rule.
	SubnetId *string `pulumi:"subnetId"`
}

// The set of arguments for constructing a SnatRule resource.
type SnatRuleArgs struct {
	// Specifies CIDR, which can be in the format of a network segment or a host IP
	// address. This parameter and `subnetId` are alternative. Changing this creates a new snat rule.
	Cidr pulumi.StringPtrInput
	// Specifies the description of the snat rule.
	// The value is a string of no more than 255 characters, and angle brackets (<>) are not allowed.
	Description pulumi.StringPtrInput
	// Specifies the EIP ID this snat rule connects to.
	// Multiple EIPs are separated using commas (,). The number of EIP IDs cannot exceed 20.
	FloatingIpId pulumi.StringInput
	// ID of the nat gateway this snat rule belongs to. Changing this creates
	// a new snat rule.
	NatGatewayId pulumi.StringInput
	// Deprecated: use subnet_id instead
	NetworkId pulumi.StringPtrInput
	// The region in which to create the snat rule resource. If omitted, the
	// provider-level region will be used. Changing this creates a new snat rule resource.
	Region pulumi.StringPtrInput
	// Specifies the scenario. The valid value is 0 (VPC scenario) and 1 (Direct
	// Connect scenario). Defaults to 0, only `cidr` can be specified over a Direct Connect connection. Changing this creates
	// a new snat rule.
	SourceType pulumi.IntPtrInput
	// ID of the subnet this snat rule connects to. This parameter and `cidr` are
	// alternative. Changing this creates a new snat rule.
	SubnetId pulumi.StringPtrInput
}

func (SnatRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*snatRuleArgs)(nil)).Elem()
}

type SnatRuleInput interface {
	pulumi.Input

	ToSnatRuleOutput() SnatRuleOutput
	ToSnatRuleOutputWithContext(ctx context.Context) SnatRuleOutput
}

func (*SnatRule) ElementType() reflect.Type {
	return reflect.TypeOf((**SnatRule)(nil)).Elem()
}

func (i *SnatRule) ToSnatRuleOutput() SnatRuleOutput {
	return i.ToSnatRuleOutputWithContext(context.Background())
}

func (i *SnatRule) ToSnatRuleOutputWithContext(ctx context.Context) SnatRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SnatRuleOutput)
}

// SnatRuleArrayInput is an input type that accepts SnatRuleArray and SnatRuleArrayOutput values.
// You can construct a concrete instance of `SnatRuleArrayInput` via:
//
//	SnatRuleArray{ SnatRuleArgs{...} }
type SnatRuleArrayInput interface {
	pulumi.Input

	ToSnatRuleArrayOutput() SnatRuleArrayOutput
	ToSnatRuleArrayOutputWithContext(context.Context) SnatRuleArrayOutput
}

type SnatRuleArray []SnatRuleInput

func (SnatRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SnatRule)(nil)).Elem()
}

func (i SnatRuleArray) ToSnatRuleArrayOutput() SnatRuleArrayOutput {
	return i.ToSnatRuleArrayOutputWithContext(context.Background())
}

func (i SnatRuleArray) ToSnatRuleArrayOutputWithContext(ctx context.Context) SnatRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SnatRuleArrayOutput)
}

// SnatRuleMapInput is an input type that accepts SnatRuleMap and SnatRuleMapOutput values.
// You can construct a concrete instance of `SnatRuleMapInput` via:
//
//	SnatRuleMap{ "key": SnatRuleArgs{...} }
type SnatRuleMapInput interface {
	pulumi.Input

	ToSnatRuleMapOutput() SnatRuleMapOutput
	ToSnatRuleMapOutputWithContext(context.Context) SnatRuleMapOutput
}

type SnatRuleMap map[string]SnatRuleInput

func (SnatRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SnatRule)(nil)).Elem()
}

func (i SnatRuleMap) ToSnatRuleMapOutput() SnatRuleMapOutput {
	return i.ToSnatRuleMapOutputWithContext(context.Background())
}

func (i SnatRuleMap) ToSnatRuleMapOutputWithContext(ctx context.Context) SnatRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SnatRuleMapOutput)
}

type SnatRuleOutput struct{ *pulumi.OutputState }

func (SnatRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SnatRule)(nil)).Elem()
}

func (o SnatRuleOutput) ToSnatRuleOutput() SnatRuleOutput {
	return o
}

func (o SnatRuleOutput) ToSnatRuleOutputWithContext(ctx context.Context) SnatRuleOutput {
	return o
}

// Specifies CIDR, which can be in the format of a network segment or a host IP
// address. This parameter and `subnetId` are alternative. Changing this creates a new snat rule.
func (o SnatRuleOutput) Cidr() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SnatRule) pulumi.StringPtrOutput { return v.Cidr }).(pulumi.StringPtrOutput)
}

// Specifies the description of the snat rule.
// The value is a string of no more than 255 characters, and angle brackets (<>) are not allowed.
func (o SnatRuleOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SnatRule) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The actual floating IP address.
func (o SnatRuleOutput) FloatingIpAddress() pulumi.StringOutput {
	return o.ApplyT(func(v *SnatRule) pulumi.StringOutput { return v.FloatingIpAddress }).(pulumi.StringOutput)
}

// Specifies the EIP ID this snat rule connects to.
// Multiple EIPs are separated using commas (,). The number of EIP IDs cannot exceed 20.
func (o SnatRuleOutput) FloatingIpId() pulumi.StringOutput {
	return o.ApplyT(func(v *SnatRule) pulumi.StringOutput { return v.FloatingIpId }).(pulumi.StringOutput)
}

// ID of the nat gateway this snat rule belongs to. Changing this creates
// a new snat rule.
func (o SnatRuleOutput) NatGatewayId() pulumi.StringOutput {
	return o.ApplyT(func(v *SnatRule) pulumi.StringOutput { return v.NatGatewayId }).(pulumi.StringOutput)
}

// Deprecated: use subnet_id instead
func (o SnatRuleOutput) NetworkId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SnatRule) pulumi.StringPtrOutput { return v.NetworkId }).(pulumi.StringPtrOutput)
}

// The region in which to create the snat rule resource. If omitted, the
// provider-level region will be used. Changing this creates a new snat rule resource.
func (o SnatRuleOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *SnatRule) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// Specifies the scenario. The valid value is 0 (VPC scenario) and 1 (Direct
// Connect scenario). Defaults to 0, only `cidr` can be specified over a Direct Connect connection. Changing this creates
// a new snat rule.
func (o SnatRuleOutput) SourceType() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *SnatRule) pulumi.IntPtrOutput { return v.SourceType }).(pulumi.IntPtrOutput)
}

// The status of the snat rule.
func (o SnatRuleOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *SnatRule) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

// ID of the subnet this snat rule connects to. This parameter and `cidr` are
// alternative. Changing this creates a new snat rule.
func (o SnatRuleOutput) SubnetId() pulumi.StringOutput {
	return o.ApplyT(func(v *SnatRule) pulumi.StringOutput { return v.SubnetId }).(pulumi.StringOutput)
}

type SnatRuleArrayOutput struct{ *pulumi.OutputState }

func (SnatRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SnatRule)(nil)).Elem()
}

func (o SnatRuleArrayOutput) ToSnatRuleArrayOutput() SnatRuleArrayOutput {
	return o
}

func (o SnatRuleArrayOutput) ToSnatRuleArrayOutputWithContext(ctx context.Context) SnatRuleArrayOutput {
	return o
}

func (o SnatRuleArrayOutput) Index(i pulumi.IntInput) SnatRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SnatRule {
		return vs[0].([]*SnatRule)[vs[1].(int)]
	}).(SnatRuleOutput)
}

type SnatRuleMapOutput struct{ *pulumi.OutputState }

func (SnatRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SnatRule)(nil)).Elem()
}

func (o SnatRuleMapOutput) ToSnatRuleMapOutput() SnatRuleMapOutput {
	return o
}

func (o SnatRuleMapOutput) ToSnatRuleMapOutputWithContext(ctx context.Context) SnatRuleMapOutput {
	return o
}

func (o SnatRuleMapOutput) MapIndex(k pulumi.StringInput) SnatRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SnatRule {
		return vs[0].(map[string]*SnatRule)[vs[1].(string)]
	}).(SnatRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SnatRuleInput)(nil)).Elem(), &SnatRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*SnatRuleArrayInput)(nil)).Elem(), SnatRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SnatRuleMapInput)(nil)).Elem(), SnatRuleMap{})
	pulumi.RegisterOutputType(SnatRuleOutput{})
	pulumi.RegisterOutputType(SnatRuleArrayOutput{})
	pulumi.RegisterOutputType(SnatRuleMapOutput{})
}
