// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package rds

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manage an RDS PostgreSQL SQL limit resource within HuaweiCloud.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/huaweicloud/pulumi-huaweicloud/sdk/go/huaweicloud/Rds"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			cfg := config.New(ctx, "")
//			instanceId := cfg.RequireObject("instanceId")
//			dbName := cfg.RequireObject("dbName")
//			_, err := Rds.NewPgSqlLimit(ctx, "instance", &Rds.PgSqlLimitArgs{
//				InstanceId:     pulumi.Any(instanceId),
//				DbName:         pulumi.Any(dbName),
//				QueryId:        pulumi.String("5"),
//				MaxConcurrency: pulumi.Int(20),
//				MaxWaiting:     pulumi.Int(5),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// The SQL limit can be imported using the `instance_id`, `db_name` and `sql_limit_id`, separated by slashes, e.g. bash
//
// ```sh
//
//	$ pulumi import huaweicloud:Rds/pgSqlLimit:PgSqlLimit test <instance_id>/<db_name>/<sql_limit_id>
//
// ```
//
//	Note that the imported state may not be identical to your resource definition, due to some attributes missing from the API response, security or some other reason. The missing attributes include`query_id`, `query_string`. It is generally recommended running `terraform plan` after importing an RDS PostgreSQL SQL limit. You can then decide if changes should be applied to the RDS PostgreSQL SQL limit, or the resource definition should be updated to align with the RDS PostgreSQL SQL limit. Also, you can ignore changes as below. hcl resource "huaweicloud_rds_pg_sql_limit" "test" {
//
//	...
//
//	lifecycle {
//
//	ignore_changes = [
//
//	"query_id", "query_string",
//
//	]
//
//	} }
type PgSqlLimit struct {
	pulumi.CustomResourceState

	// Specifies the name of the database.
	DbName pulumi.StringOutput `pulumi:"dbName"`
	// Specifies the ID of RDS PostgreSQL instance.
	InstanceId pulumi.StringOutput `pulumi:"instanceId"`
	// Indicates whether the SQL limit is effective.
	IsEffective pulumi.BoolOutput `pulumi:"isEffective"`
	// Specifies the number of SQL statements executed simultaneously.
	// Value ranges from `0` to `50000`. `0` means no limit.
	MaxConcurrency pulumi.IntOutput `pulumi:"maxConcurrency"`
	// Specifies the max waiting time in seconds.
	MaxWaiting pulumi.IntOutput `pulumi:"maxWaiting"`
	// Specifies the query ID. Value ranges: **-9223372036854775808~9223372036854775807**.
	QueryId pulumi.StringPtrOutput `pulumi:"queryId"`
	// Specifies the text form of SQL statement.
	QueryString pulumi.StringPtrOutput `pulumi:"queryString"`
	// The region in which to create the rds PostgreSQL SQL limit resource. If omitted,
	// the provider-level region will be used. Changing this creates a new resource.
	Region pulumi.StringOutput `pulumi:"region"`
	// Specifies the query order for names that are not schema qualified.
	// Defaults to **public**,
	SearchPath pulumi.StringPtrOutput `pulumi:"searchPath"`
	// Indicates the ID of SQL limit.
	SqlLimitId pulumi.StringOutput `pulumi:"sqlLimitId"`
	// Specifies the SQL limit switch. Value options: **open**, **close**.
	Switch pulumi.StringOutput `pulumi:"switch"`
}

// NewPgSqlLimit registers a new resource with the given unique name, arguments, and options.
func NewPgSqlLimit(ctx *pulumi.Context,
	name string, args *PgSqlLimitArgs, opts ...pulumi.ResourceOption) (*PgSqlLimit, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DbName == nil {
		return nil, errors.New("invalid value for required argument 'DbName'")
	}
	if args.InstanceId == nil {
		return nil, errors.New("invalid value for required argument 'InstanceId'")
	}
	if args.MaxConcurrency == nil {
		return nil, errors.New("invalid value for required argument 'MaxConcurrency'")
	}
	if args.MaxWaiting == nil {
		return nil, errors.New("invalid value for required argument 'MaxWaiting'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource PgSqlLimit
	err := ctx.RegisterResource("huaweicloud:Rds/pgSqlLimit:PgSqlLimit", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPgSqlLimit gets an existing PgSqlLimit resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPgSqlLimit(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PgSqlLimitState, opts ...pulumi.ResourceOption) (*PgSqlLimit, error) {
	var resource PgSqlLimit
	err := ctx.ReadResource("huaweicloud:Rds/pgSqlLimit:PgSqlLimit", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering PgSqlLimit resources.
type pgSqlLimitState struct {
	// Specifies the name of the database.
	DbName *string `pulumi:"dbName"`
	// Specifies the ID of RDS PostgreSQL instance.
	InstanceId *string `pulumi:"instanceId"`
	// Indicates whether the SQL limit is effective.
	IsEffective *bool `pulumi:"isEffective"`
	// Specifies the number of SQL statements executed simultaneously.
	// Value ranges from `0` to `50000`. `0` means no limit.
	MaxConcurrency *int `pulumi:"maxConcurrency"`
	// Specifies the max waiting time in seconds.
	MaxWaiting *int `pulumi:"maxWaiting"`
	// Specifies the query ID. Value ranges: **-9223372036854775808~9223372036854775807**.
	QueryId *string `pulumi:"queryId"`
	// Specifies the text form of SQL statement.
	QueryString *string `pulumi:"queryString"`
	// The region in which to create the rds PostgreSQL SQL limit resource. If omitted,
	// the provider-level region will be used. Changing this creates a new resource.
	Region *string `pulumi:"region"`
	// Specifies the query order for names that are not schema qualified.
	// Defaults to **public**,
	SearchPath *string `pulumi:"searchPath"`
	// Indicates the ID of SQL limit.
	SqlLimitId *string `pulumi:"sqlLimitId"`
	// Specifies the SQL limit switch. Value options: **open**, **close**.
	Switch *string `pulumi:"switch"`
}

type PgSqlLimitState struct {
	// Specifies the name of the database.
	DbName pulumi.StringPtrInput
	// Specifies the ID of RDS PostgreSQL instance.
	InstanceId pulumi.StringPtrInput
	// Indicates whether the SQL limit is effective.
	IsEffective pulumi.BoolPtrInput
	// Specifies the number of SQL statements executed simultaneously.
	// Value ranges from `0` to `50000`. `0` means no limit.
	MaxConcurrency pulumi.IntPtrInput
	// Specifies the max waiting time in seconds.
	MaxWaiting pulumi.IntPtrInput
	// Specifies the query ID. Value ranges: **-9223372036854775808~9223372036854775807**.
	QueryId pulumi.StringPtrInput
	// Specifies the text form of SQL statement.
	QueryString pulumi.StringPtrInput
	// The region in which to create the rds PostgreSQL SQL limit resource. If omitted,
	// the provider-level region will be used. Changing this creates a new resource.
	Region pulumi.StringPtrInput
	// Specifies the query order for names that are not schema qualified.
	// Defaults to **public**,
	SearchPath pulumi.StringPtrInput
	// Indicates the ID of SQL limit.
	SqlLimitId pulumi.StringPtrInput
	// Specifies the SQL limit switch. Value options: **open**, **close**.
	Switch pulumi.StringPtrInput
}

func (PgSqlLimitState) ElementType() reflect.Type {
	return reflect.TypeOf((*pgSqlLimitState)(nil)).Elem()
}

type pgSqlLimitArgs struct {
	// Specifies the name of the database.
	DbName string `pulumi:"dbName"`
	// Specifies the ID of RDS PostgreSQL instance.
	InstanceId string `pulumi:"instanceId"`
	// Specifies the number of SQL statements executed simultaneously.
	// Value ranges from `0` to `50000`. `0` means no limit.
	MaxConcurrency int `pulumi:"maxConcurrency"`
	// Specifies the max waiting time in seconds.
	MaxWaiting int `pulumi:"maxWaiting"`
	// Specifies the query ID. Value ranges: **-9223372036854775808~9223372036854775807**.
	QueryId *string `pulumi:"queryId"`
	// Specifies the text form of SQL statement.
	QueryString *string `pulumi:"queryString"`
	// The region in which to create the rds PostgreSQL SQL limit resource. If omitted,
	// the provider-level region will be used. Changing this creates a new resource.
	Region *string `pulumi:"region"`
	// Specifies the query order for names that are not schema qualified.
	// Defaults to **public**,
	SearchPath *string `pulumi:"searchPath"`
	// Specifies the SQL limit switch. Value options: **open**, **close**.
	Switch *string `pulumi:"switch"`
}

// The set of arguments for constructing a PgSqlLimit resource.
type PgSqlLimitArgs struct {
	// Specifies the name of the database.
	DbName pulumi.StringInput
	// Specifies the ID of RDS PostgreSQL instance.
	InstanceId pulumi.StringInput
	// Specifies the number of SQL statements executed simultaneously.
	// Value ranges from `0` to `50000`. `0` means no limit.
	MaxConcurrency pulumi.IntInput
	// Specifies the max waiting time in seconds.
	MaxWaiting pulumi.IntInput
	// Specifies the query ID. Value ranges: **-9223372036854775808~9223372036854775807**.
	QueryId pulumi.StringPtrInput
	// Specifies the text form of SQL statement.
	QueryString pulumi.StringPtrInput
	// The region in which to create the rds PostgreSQL SQL limit resource. If omitted,
	// the provider-level region will be used. Changing this creates a new resource.
	Region pulumi.StringPtrInput
	// Specifies the query order for names that are not schema qualified.
	// Defaults to **public**,
	SearchPath pulumi.StringPtrInput
	// Specifies the SQL limit switch. Value options: **open**, **close**.
	Switch pulumi.StringPtrInput
}

func (PgSqlLimitArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*pgSqlLimitArgs)(nil)).Elem()
}

type PgSqlLimitInput interface {
	pulumi.Input

	ToPgSqlLimitOutput() PgSqlLimitOutput
	ToPgSqlLimitOutputWithContext(ctx context.Context) PgSqlLimitOutput
}

func (*PgSqlLimit) ElementType() reflect.Type {
	return reflect.TypeOf((**PgSqlLimit)(nil)).Elem()
}

func (i *PgSqlLimit) ToPgSqlLimitOutput() PgSqlLimitOutput {
	return i.ToPgSqlLimitOutputWithContext(context.Background())
}

func (i *PgSqlLimit) ToPgSqlLimitOutputWithContext(ctx context.Context) PgSqlLimitOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PgSqlLimitOutput)
}

// PgSqlLimitArrayInput is an input type that accepts PgSqlLimitArray and PgSqlLimitArrayOutput values.
// You can construct a concrete instance of `PgSqlLimitArrayInput` via:
//
//	PgSqlLimitArray{ PgSqlLimitArgs{...} }
type PgSqlLimitArrayInput interface {
	pulumi.Input

	ToPgSqlLimitArrayOutput() PgSqlLimitArrayOutput
	ToPgSqlLimitArrayOutputWithContext(context.Context) PgSqlLimitArrayOutput
}

type PgSqlLimitArray []PgSqlLimitInput

func (PgSqlLimitArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PgSqlLimit)(nil)).Elem()
}

func (i PgSqlLimitArray) ToPgSqlLimitArrayOutput() PgSqlLimitArrayOutput {
	return i.ToPgSqlLimitArrayOutputWithContext(context.Background())
}

func (i PgSqlLimitArray) ToPgSqlLimitArrayOutputWithContext(ctx context.Context) PgSqlLimitArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PgSqlLimitArrayOutput)
}

// PgSqlLimitMapInput is an input type that accepts PgSqlLimitMap and PgSqlLimitMapOutput values.
// You can construct a concrete instance of `PgSqlLimitMapInput` via:
//
//	PgSqlLimitMap{ "key": PgSqlLimitArgs{...} }
type PgSqlLimitMapInput interface {
	pulumi.Input

	ToPgSqlLimitMapOutput() PgSqlLimitMapOutput
	ToPgSqlLimitMapOutputWithContext(context.Context) PgSqlLimitMapOutput
}

type PgSqlLimitMap map[string]PgSqlLimitInput

func (PgSqlLimitMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PgSqlLimit)(nil)).Elem()
}

func (i PgSqlLimitMap) ToPgSqlLimitMapOutput() PgSqlLimitMapOutput {
	return i.ToPgSqlLimitMapOutputWithContext(context.Background())
}

func (i PgSqlLimitMap) ToPgSqlLimitMapOutputWithContext(ctx context.Context) PgSqlLimitMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PgSqlLimitMapOutput)
}

type PgSqlLimitOutput struct{ *pulumi.OutputState }

func (PgSqlLimitOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PgSqlLimit)(nil)).Elem()
}

func (o PgSqlLimitOutput) ToPgSqlLimitOutput() PgSqlLimitOutput {
	return o
}

func (o PgSqlLimitOutput) ToPgSqlLimitOutputWithContext(ctx context.Context) PgSqlLimitOutput {
	return o
}

// Specifies the name of the database.
func (o PgSqlLimitOutput) DbName() pulumi.StringOutput {
	return o.ApplyT(func(v *PgSqlLimit) pulumi.StringOutput { return v.DbName }).(pulumi.StringOutput)
}

// Specifies the ID of RDS PostgreSQL instance.
func (o PgSqlLimitOutput) InstanceId() pulumi.StringOutput {
	return o.ApplyT(func(v *PgSqlLimit) pulumi.StringOutput { return v.InstanceId }).(pulumi.StringOutput)
}

// Indicates whether the SQL limit is effective.
func (o PgSqlLimitOutput) IsEffective() pulumi.BoolOutput {
	return o.ApplyT(func(v *PgSqlLimit) pulumi.BoolOutput { return v.IsEffective }).(pulumi.BoolOutput)
}

// Specifies the number of SQL statements executed simultaneously.
// Value ranges from `0` to `50000`. `0` means no limit.
func (o PgSqlLimitOutput) MaxConcurrency() pulumi.IntOutput {
	return o.ApplyT(func(v *PgSqlLimit) pulumi.IntOutput { return v.MaxConcurrency }).(pulumi.IntOutput)
}

// Specifies the max waiting time in seconds.
func (o PgSqlLimitOutput) MaxWaiting() pulumi.IntOutput {
	return o.ApplyT(func(v *PgSqlLimit) pulumi.IntOutput { return v.MaxWaiting }).(pulumi.IntOutput)
}

// Specifies the query ID. Value ranges: **-9223372036854775808~9223372036854775807**.
func (o PgSqlLimitOutput) QueryId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PgSqlLimit) pulumi.StringPtrOutput { return v.QueryId }).(pulumi.StringPtrOutput)
}

// Specifies the text form of SQL statement.
func (o PgSqlLimitOutput) QueryString() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PgSqlLimit) pulumi.StringPtrOutput { return v.QueryString }).(pulumi.StringPtrOutput)
}

// The region in which to create the rds PostgreSQL SQL limit resource. If omitted,
// the provider-level region will be used. Changing this creates a new resource.
func (o PgSqlLimitOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *PgSqlLimit) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// Specifies the query order for names that are not schema qualified.
// Defaults to **public**,
func (o PgSqlLimitOutput) SearchPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PgSqlLimit) pulumi.StringPtrOutput { return v.SearchPath }).(pulumi.StringPtrOutput)
}

// Indicates the ID of SQL limit.
func (o PgSqlLimitOutput) SqlLimitId() pulumi.StringOutput {
	return o.ApplyT(func(v *PgSqlLimit) pulumi.StringOutput { return v.SqlLimitId }).(pulumi.StringOutput)
}

// Specifies the SQL limit switch. Value options: **open**, **close**.
func (o PgSqlLimitOutput) Switch() pulumi.StringOutput {
	return o.ApplyT(func(v *PgSqlLimit) pulumi.StringOutput { return v.Switch }).(pulumi.StringOutput)
}

type PgSqlLimitArrayOutput struct{ *pulumi.OutputState }

func (PgSqlLimitArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PgSqlLimit)(nil)).Elem()
}

func (o PgSqlLimitArrayOutput) ToPgSqlLimitArrayOutput() PgSqlLimitArrayOutput {
	return o
}

func (o PgSqlLimitArrayOutput) ToPgSqlLimitArrayOutputWithContext(ctx context.Context) PgSqlLimitArrayOutput {
	return o
}

func (o PgSqlLimitArrayOutput) Index(i pulumi.IntInput) PgSqlLimitOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *PgSqlLimit {
		return vs[0].([]*PgSqlLimit)[vs[1].(int)]
	}).(PgSqlLimitOutput)
}

type PgSqlLimitMapOutput struct{ *pulumi.OutputState }

func (PgSqlLimitMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PgSqlLimit)(nil)).Elem()
}

func (o PgSqlLimitMapOutput) ToPgSqlLimitMapOutput() PgSqlLimitMapOutput {
	return o
}

func (o PgSqlLimitMapOutput) ToPgSqlLimitMapOutputWithContext(ctx context.Context) PgSqlLimitMapOutput {
	return o
}

func (o PgSqlLimitMapOutput) MapIndex(k pulumi.StringInput) PgSqlLimitOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *PgSqlLimit {
		return vs[0].(map[string]*PgSqlLimit)[vs[1].(string)]
	}).(PgSqlLimitOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PgSqlLimitInput)(nil)).Elem(), &PgSqlLimit{})
	pulumi.RegisterInputType(reflect.TypeOf((*PgSqlLimitArrayInput)(nil)).Elem(), PgSqlLimitArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PgSqlLimitMapInput)(nil)).Elem(), PgSqlLimitMap{})
	pulumi.RegisterOutputType(PgSqlLimitOutput{})
	pulumi.RegisterOutputType(PgSqlLimitArrayOutput{})
	pulumi.RegisterOutputType(PgSqlLimitMapOutput{})
}
